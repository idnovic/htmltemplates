{"version":3,"sources":["webpack://js2flowchart/webpack/universalModuleDefinition","webpack://js2flowchart/webpack/bootstrap","webpack://js2flowchart/./index.js","webpack://js2flowchart/./node_modules/ansi-regex/index.js","webpack://js2flowchart/./node_modules/ansi-styles/index.js","webpack://js2flowchart/./node_modules/babel-code-frame/lib/index.js","webpack://js2flowchart/./node_modules/babel-generator/lib/buffer.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/base.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/classes.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/expressions.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/flow.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/index.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/jsx.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/methods.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/modules.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/statements.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/template-literals.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/types.js","webpack://js2flowchart/./node_modules/babel-generator/lib/generators/typescript.js","webpack://js2flowchart/./node_modules/babel-generator/lib/index.js","webpack://js2flowchart/./node_modules/babel-generator/lib/node/index.js","webpack://js2flowchart/./node_modules/babel-generator/lib/node/parentheses.js","webpack://js2flowchart/./node_modules/babel-generator/lib/node/whitespace.js","webpack://js2flowchart/./node_modules/babel-generator/lib/printer.js","webpack://js2flowchart/./node_modules/babel-generator/lib/source-map.js","webpack://js2flowchart/./node_modules/babel-helper-function-name/lib/index.js","webpack://js2flowchart/./node_modules/babel-helper-get-function-arity/lib/index.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/get-iterator.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/json/stringify.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/number/max-safe-integer.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/object/create.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/object/get-own-property-symbols.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/object/keys.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/symbol.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/symbol/for.js","webpack://js2flowchart/./node_modules/babel-runtime/core-js/symbol/iterator.js","webpack://js2flowchart/./node_modules/babel-runtime/helpers/typeof.js","webpack://js2flowchart/./node_modules/babel-template/lib/index.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/cache.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/context.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/hub.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/index.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/ancestry.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/comments.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/context.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/conversion.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/evaluation.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/family.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/index.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/inference/index.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/inference/inferer-reference.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/inference/inferers.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/introspection.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/lib/hoister.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/lib/removal-hooks.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/lib/virtual-types.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/modification.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/removal.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/path/replacement.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/scope/binding.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/scope/index.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/scope/lib/renamer.js","webpack://js2flowchart/./node_modules/babel-traverse/lib/visitors.js","webpack://js2flowchart/./node_modules/babel-types/lib/constants.js","webpack://js2flowchart/./node_modules/babel-types/lib/converters.js","webpack://js2flowchart/./node_modules/babel-types/lib/definitions/core.js","webpack://js2flowchart/./node_modules/babel-types/lib/definitions/es2015.js","webpack://js2flowchart/./node_modules/babel-types/lib/definitions/experimental.js","webpack://js2flowchart/./node_modules/babel-types/lib/definitions/flow.js","webpack://js2flowchart/./node_modules/babel-types/lib/definitions/index.js","webpack://js2flowchart/./node_modules/babel-types/lib/definitions/init.js","webpack://js2flowchart/./node_modules/babel-types/lib/definitions/jsx.js","webpack://js2flowchart/./node_modules/babel-types/lib/definitions/misc.js","webpack://js2flowchart/./node_modules/babel-types/lib/flow.js","webpack://js2flowchart/./node_modules/babel-types/lib/index.js","webpack://js2flowchart/./node_modules/babel-types/lib/react.js","webpack://js2flowchart/./node_modules/babel-types/lib/retrievers.js","webpack://js2flowchart/./node_modules/babel-types/lib/validators.js","webpack://js2flowchart/./node_modules/babylon/lib/index.js","webpack://js2flowchart/./node_modules/chalk/index.js","webpack://js2flowchart/./node_modules/core-js/library/fn/get-iterator.js","webpack://js2flowchart/./node_modules/core-js/library/fn/json/stringify.js","webpack://js2flowchart/./node_modules/core-js/library/fn/number/max-safe-integer.js","webpack://js2flowchart/./node_modules/core-js/library/fn/object/create.js","webpack://js2flowchart/./node_modules/core-js/library/fn/object/get-own-property-symbols.js","webpack://js2flowchart/./node_modules/core-js/library/fn/object/keys.js","webpack://js2flowchart/./node_modules/core-js/library/fn/symbol/for.js","webpack://js2flowchart/./node_modules/core-js/library/fn/symbol/index.js","webpack://js2flowchart/./node_modules/core-js/library/fn/symbol/iterator.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_a-function.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_add-to-unscopables.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_an-object.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_array-includes.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_classof.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_cof.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_core.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_ctx.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_defined.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_descriptors.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_dom-create.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_enum-bug-keys.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_enum-keys.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_export.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_fails.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_global.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_has.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_hide.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_html.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_ie8-dom-define.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_iobject.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_is-array.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_is-object.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_iter-create.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_iter-define.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_iter-step.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_iterators.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_library.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_meta.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-create.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-dp.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-dps.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-gopd.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-gopn-ext.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-gopn.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-gops.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-gpo.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-keys-internal.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-keys.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-pie.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_object-sap.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_property-desc.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_redefine.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_set-to-string-tag.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_shared-key.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_shared.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_string-at.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_to-absolute-index.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_to-integer.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_to-iobject.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_to-length.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_to-object.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_to-primitive.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_uid.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_wks-define.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_wks-ext.js","webpack://js2flowchart/./node_modules/core-js/library/modules/_wks.js","webpack://js2flowchart/./node_modules/core-js/library/modules/core.get-iterator-method.js","webpack://js2flowchart/./node_modules/core-js/library/modules/core.get-iterator.js","webpack://js2flowchart/./node_modules/core-js/library/modules/es6.array.iterator.js","webpack://js2flowchart/./node_modules/core-js/library/modules/es6.number.max-safe-integer.js","webpack://js2flowchart/./node_modules/core-js/library/modules/es6.object.create.js","webpack://js2flowchart/./node_modules/core-js/library/modules/es6.object.keys.js","webpack://js2flowchart/./node_modules/core-js/library/modules/es6.string.iterator.js","webpack://js2flowchart/./node_modules/core-js/library/modules/es6.symbol.js","webpack://js2flowchart/./node_modules/core-js/library/modules/es7.symbol.async-iterator.js","webpack://js2flowchart/./node_modules/core-js/library/modules/es7.symbol.observable.js","webpack://js2flowchart/./node_modules/core-js/library/modules/web.dom.iterable.js","webpack://js2flowchart/./node_modules/debug/src/browser.js","webpack://js2flowchart/./node_modules/debug/src/debug.js","webpack://js2flowchart/./node_modules/deepmerge/dist/cjs.js","webpack://js2flowchart/./node_modules/escape-string-regexp/index.js","webpack://js2flowchart/./node_modules/esutils/lib/ast.js","webpack://js2flowchart/./node_modules/esutils/lib/code.js","webpack://js2flowchart/./node_modules/esutils/lib/keyword.js","webpack://js2flowchart/./node_modules/esutils/lib/utils.js","webpack://js2flowchart/./node_modules/globals/index.js","webpack://js2flowchart/./node_modules/has-ansi/index.js","webpack://js2flowchart/./node_modules/invariant/browser.js","webpack://js2flowchart/./node_modules/is-fullwidth-code-point/index.js","webpack://js2flowchart/./node_modules/js-tokens/index.js","webpack://js2flowchart/./node_modules/jsesc/jsesc.js","webpack://js2flowchart/./node_modules/lodash/_DataView.js","webpack://js2flowchart/./node_modules/lodash/_Hash.js","webpack://js2flowchart/./node_modules/lodash/_ListCache.js","webpack://js2flowchart/./node_modules/lodash/_Map.js","webpack://js2flowchart/./node_modules/lodash/_MapCache.js","webpack://js2flowchart/./node_modules/lodash/_Promise.js","webpack://js2flowchart/./node_modules/lodash/_Set.js","webpack://js2flowchart/./node_modules/lodash/_SetCache.js","webpack://js2flowchart/./node_modules/lodash/_Stack.js","webpack://js2flowchart/./node_modules/lodash/_Symbol.js","webpack://js2flowchart/./node_modules/lodash/_Uint8Array.js","webpack://js2flowchart/./node_modules/lodash/_WeakMap.js","webpack://js2flowchart/./node_modules/lodash/_apply.js","webpack://js2flowchart/./node_modules/lodash/_arrayEach.js","webpack://js2flowchart/./node_modules/lodash/_arrayFilter.js","webpack://js2flowchart/./node_modules/lodash/_arrayIncludes.js","webpack://js2flowchart/./node_modules/lodash/_arrayIncludesWith.js","webpack://js2flowchart/./node_modules/lodash/_arrayLikeKeys.js","webpack://js2flowchart/./node_modules/lodash/_arrayMap.js","webpack://js2flowchart/./node_modules/lodash/_arrayPush.js","webpack://js2flowchart/./node_modules/lodash/_arraySome.js","webpack://js2flowchart/./node_modules/lodash/_assignValue.js","webpack://js2flowchart/./node_modules/lodash/_assocIndexOf.js","webpack://js2flowchart/./node_modules/lodash/_baseAssign.js","webpack://js2flowchart/./node_modules/lodash/_baseAssignIn.js","webpack://js2flowchart/./node_modules/lodash/_baseAssignValue.js","webpack://js2flowchart/./node_modules/lodash/_baseClone.js","webpack://js2flowchart/./node_modules/lodash/_baseCreate.js","webpack://js2flowchart/./node_modules/lodash/_baseEach.js","webpack://js2flowchart/./node_modules/lodash/_baseFindIndex.js","webpack://js2flowchart/./node_modules/lodash/_baseFor.js","webpack://js2flowchart/./node_modules/lodash/_baseForOwn.js","webpack://js2flowchart/./node_modules/lodash/_baseGet.js","webpack://js2flowchart/./node_modules/lodash/_baseGetAllKeys.js","webpack://js2flowchart/./node_modules/lodash/_baseGetTag.js","webpack://js2flowchart/./node_modules/lodash/_baseHas.js","webpack://js2flowchart/./node_modules/lodash/_baseHasIn.js","webpack://js2flowchart/./node_modules/lodash/_baseIndexOf.js","webpack://js2flowchart/./node_modules/lodash/_baseIsArguments.js","webpack://js2flowchart/./node_modules/lodash/_baseIsEqual.js","webpack://js2flowchart/./node_modules/lodash/_baseIsEqualDeep.js","webpack://js2flowchart/./node_modules/lodash/_baseIsMap.js","webpack://js2flowchart/./node_modules/lodash/_baseIsMatch.js","webpack://js2flowchart/./node_modules/lodash/_baseIsNaN.js","webpack://js2flowchart/./node_modules/lodash/_baseIsNative.js","webpack://js2flowchart/./node_modules/lodash/_baseIsRegExp.js","webpack://js2flowchart/./node_modules/lodash/_baseIsSet.js","webpack://js2flowchart/./node_modules/lodash/_baseIsTypedArray.js","webpack://js2flowchart/./node_modules/lodash/_baseIteratee.js","webpack://js2flowchart/./node_modules/lodash/_baseKeys.js","webpack://js2flowchart/./node_modules/lodash/_baseKeysIn.js","webpack://js2flowchart/./node_modules/lodash/_baseMap.js","webpack://js2flowchart/./node_modules/lodash/_baseMatches.js","webpack://js2flowchart/./node_modules/lodash/_baseMatchesProperty.js","webpack://js2flowchart/./node_modules/lodash/_baseProperty.js","webpack://js2flowchart/./node_modules/lodash/_basePropertyDeep.js","webpack://js2flowchart/./node_modules/lodash/_baseRepeat.js","webpack://js2flowchart/./node_modules/lodash/_baseRest.js","webpack://js2flowchart/./node_modules/lodash/_baseSetToString.js","webpack://js2flowchart/./node_modules/lodash/_baseTimes.js","webpack://js2flowchart/./node_modules/lodash/_baseToString.js","webpack://js2flowchart/./node_modules/lodash/_baseUnary.js","webpack://js2flowchart/./node_modules/lodash/_baseUniq.js","webpack://js2flowchart/./node_modules/lodash/_baseValues.js","webpack://js2flowchart/./node_modules/lodash/_cacheHas.js","webpack://js2flowchart/./node_modules/lodash/_castPath.js","webpack://js2flowchart/./node_modules/lodash/_cloneArrayBuffer.js","webpack://js2flowchart/./node_modules/lodash/_cloneBuffer.js","webpack://js2flowchart/./node_modules/lodash/_cloneDataView.js","webpack://js2flowchart/./node_modules/lodash/_cloneRegExp.js","webpack://js2flowchart/./node_modules/lodash/_cloneSymbol.js","webpack://js2flowchart/./node_modules/lodash/_cloneTypedArray.js","webpack://js2flowchart/./node_modules/lodash/_copyArray.js","webpack://js2flowchart/./node_modules/lodash/_copyObject.js","webpack://js2flowchart/./node_modules/lodash/_copySymbols.js","webpack://js2flowchart/./node_modules/lodash/_copySymbolsIn.js","webpack://js2flowchart/./node_modules/lodash/_coreJsData.js","webpack://js2flowchart/./node_modules/lodash/_createAssigner.js","webpack://js2flowchart/./node_modules/lodash/_createBaseEach.js","webpack://js2flowchart/./node_modules/lodash/_createBaseFor.js","webpack://js2flowchart/./node_modules/lodash/_createSet.js","webpack://js2flowchart/./node_modules/lodash/_defineProperty.js","webpack://js2flowchart/./node_modules/lodash/_equalArrays.js","webpack://js2flowchart/./node_modules/lodash/_equalByTag.js","webpack://js2flowchart/./node_modules/lodash/_equalObjects.js","webpack://js2flowchart/./node_modules/lodash/_freeGlobal.js","webpack://js2flowchart/./node_modules/lodash/_getAllKeys.js","webpack://js2flowchart/./node_modules/lodash/_getAllKeysIn.js","webpack://js2flowchart/./node_modules/lodash/_getMapData.js","webpack://js2flowchart/./node_modules/lodash/_getMatchData.js","webpack://js2flowchart/./node_modules/lodash/_getNative.js","webpack://js2flowchart/./node_modules/lodash/_getPrototype.js","webpack://js2flowchart/./node_modules/lodash/_getRawTag.js","webpack://js2flowchart/./node_modules/lodash/_getSymbols.js","webpack://js2flowchart/./node_modules/lodash/_getSymbolsIn.js","webpack://js2flowchart/./node_modules/lodash/_getTag.js","webpack://js2flowchart/./node_modules/lodash/_getValue.js","webpack://js2flowchart/./node_modules/lodash/_hasPath.js","webpack://js2flowchart/./node_modules/lodash/_hashClear.js","webpack://js2flowchart/./node_modules/lodash/_hashDelete.js","webpack://js2flowchart/./node_modules/lodash/_hashGet.js","webpack://js2flowchart/./node_modules/lodash/_hashHas.js","webpack://js2flowchart/./node_modules/lodash/_hashSet.js","webpack://js2flowchart/./node_modules/lodash/_initCloneArray.js","webpack://js2flowchart/./node_modules/lodash/_initCloneByTag.js","webpack://js2flowchart/./node_modules/lodash/_initCloneObject.js","webpack://js2flowchart/./node_modules/lodash/_isIndex.js","webpack://js2flowchart/./node_modules/lodash/_isIterateeCall.js","webpack://js2flowchart/./node_modules/lodash/_isKey.js","webpack://js2flowchart/./node_modules/lodash/_isKeyable.js","webpack://js2flowchart/./node_modules/lodash/_isMasked.js","webpack://js2flowchart/./node_modules/lodash/_isPrototype.js","webpack://js2flowchart/./node_modules/lodash/_isStrictComparable.js","webpack://js2flowchart/./node_modules/lodash/_listCacheClear.js","webpack://js2flowchart/./node_modules/lodash/_listCacheDelete.js","webpack://js2flowchart/./node_modules/lodash/_listCacheGet.js","webpack://js2flowchart/./node_modules/lodash/_listCacheHas.js","webpack://js2flowchart/./node_modules/lodash/_listCacheSet.js","webpack://js2flowchart/./node_modules/lodash/_mapCacheClear.js","webpack://js2flowchart/./node_modules/lodash/_mapCacheDelete.js","webpack://js2flowchart/./node_modules/lodash/_mapCacheGet.js","webpack://js2flowchart/./node_modules/lodash/_mapCacheHas.js","webpack://js2flowchart/./node_modules/lodash/_mapCacheSet.js","webpack://js2flowchart/./node_modules/lodash/_mapToArray.js","webpack://js2flowchart/./node_modules/lodash/_matchesStrictComparable.js","webpack://js2flowchart/./node_modules/lodash/_memoizeCapped.js","webpack://js2flowchart/./node_modules/lodash/_nativeCreate.js","webpack://js2flowchart/./node_modules/lodash/_nativeKeys.js","webpack://js2flowchart/./node_modules/lodash/_nativeKeysIn.js","webpack://js2flowchart/./node_modules/lodash/_nodeUtil.js","webpack://js2flowchart/./node_modules/lodash/_objectToString.js","webpack://js2flowchart/./node_modules/lodash/_overArg.js","webpack://js2flowchart/./node_modules/lodash/_overRest.js","webpack://js2flowchart/./node_modules/lodash/_root.js","webpack://js2flowchart/./node_modules/lodash/_setCacheAdd.js","webpack://js2flowchart/./node_modules/lodash/_setCacheHas.js","webpack://js2flowchart/./node_modules/lodash/_setToArray.js","webpack://js2flowchart/./node_modules/lodash/_setToString.js","webpack://js2flowchart/./node_modules/lodash/_shortOut.js","webpack://js2flowchart/./node_modules/lodash/_stackClear.js","webpack://js2flowchart/./node_modules/lodash/_stackDelete.js","webpack://js2flowchart/./node_modules/lodash/_stackGet.js","webpack://js2flowchart/./node_modules/lodash/_stackHas.js","webpack://js2flowchart/./node_modules/lodash/_stackSet.js","webpack://js2flowchart/./node_modules/lodash/_strictIndexOf.js","webpack://js2flowchart/./node_modules/lodash/_stringToPath.js","webpack://js2flowchart/./node_modules/lodash/_toKey.js","webpack://js2flowchart/./node_modules/lodash/_toSource.js","webpack://js2flowchart/./node_modules/lodash/assign.js","webpack://js2flowchart/./node_modules/lodash/clone.js","webpack://js2flowchart/./node_modules/lodash/cloneDeep.js","webpack://js2flowchart/./node_modules/lodash/constant.js","webpack://js2flowchart/./node_modules/lodash/defaults.js","webpack://js2flowchart/./node_modules/lodash/eq.js","webpack://js2flowchart/./node_modules/lodash/get.js","webpack://js2flowchart/./node_modules/lodash/has.js","webpack://js2flowchart/./node_modules/lodash/hasIn.js","webpack://js2flowchart/./node_modules/lodash/identity.js","webpack://js2flowchart/./node_modules/lodash/includes.js","webpack://js2flowchart/./node_modules/lodash/isArguments.js","webpack://js2flowchart/./node_modules/lodash/isArray.js","webpack://js2flowchart/./node_modules/lodash/isArrayLike.js","webpack://js2flowchart/./node_modules/lodash/isBuffer.js","webpack://js2flowchart/./node_modules/lodash/isFunction.js","webpack://js2flowchart/./node_modules/lodash/isInteger.js","webpack://js2flowchart/./node_modules/lodash/isLength.js","webpack://js2flowchart/./node_modules/lodash/isMap.js","webpack://js2flowchart/./node_modules/lodash/isObject.js","webpack://js2flowchart/./node_modules/lodash/isObjectLike.js","webpack://js2flowchart/./node_modules/lodash/isPlainObject.js","webpack://js2flowchart/./node_modules/lodash/isRegExp.js","webpack://js2flowchart/./node_modules/lodash/isSet.js","webpack://js2flowchart/./node_modules/lodash/isString.js","webpack://js2flowchart/./node_modules/lodash/isSymbol.js","webpack://js2flowchart/./node_modules/lodash/isTypedArray.js","webpack://js2flowchart/./node_modules/lodash/keys.js","webpack://js2flowchart/./node_modules/lodash/keysIn.js","webpack://js2flowchart/./node_modules/lodash/map.js","webpack://js2flowchart/./node_modules/lodash/memoize.js","webpack://js2flowchart/./node_modules/lodash/noop.js","webpack://js2flowchart/./node_modules/lodash/property.js","webpack://js2flowchart/./node_modules/lodash/repeat.js","webpack://js2flowchart/./node_modules/lodash/stubArray.js","webpack://js2flowchart/./node_modules/lodash/stubFalse.js","webpack://js2flowchart/./node_modules/lodash/toFinite.js","webpack://js2flowchart/./node_modules/lodash/toInteger.js","webpack://js2flowchart/./node_modules/lodash/toNumber.js","webpack://js2flowchart/./node_modules/lodash/toString.js","webpack://js2flowchart/./node_modules/lodash/uniq.js","webpack://js2flowchart/./node_modules/lodash/values.js","webpack://js2flowchart/./node_modules/ms/index.js","webpack://js2flowchart/./node_modules/node-libs-browser/node_modules/process/browser.js","webpack://js2flowchart/./node_modules/source-map/lib/array-set.js","webpack://js2flowchart/./node_modules/source-map/lib/base64-vlq.js","webpack://js2flowchart/./node_modules/source-map/lib/base64.js","webpack://js2flowchart/./node_modules/source-map/lib/binary-search.js","webpack://js2flowchart/./node_modules/source-map/lib/mapping-list.js","webpack://js2flowchart/./node_modules/source-map/lib/quick-sort.js","webpack://js2flowchart/./node_modules/source-map/lib/source-map-consumer.js","webpack://js2flowchart/./node_modules/source-map/lib/source-map-generator.js","webpack://js2flowchart/./node_modules/source-map/lib/source-node.js","webpack://js2flowchart/./node_modules/source-map/lib/util.js","webpack://js2flowchart/./node_modules/source-map/source-map.js","webpack://js2flowchart/./node_modules/string-width/index.js","webpack://js2flowchart/./node_modules/strip-ansi/index.js","webpack://js2flowchart/./node_modules/supports-color/index.js","webpack://js2flowchart/./node_modules/to-fast-properties/index.js","webpack://js2flowchart/./node_modules/trim-right/index.js","webpack://js2flowchart/(webpack)/buildin/global.js","webpack://js2flowchart/(webpack)/buildin/module.js","webpack://js2flowchart/./node_modules/xml-escape/index.js","webpack://js2flowchart/./src/builder/FlowTreeBuilder.js","webpack://js2flowchart/./src/builder/FlowTreeModifier.js","webpack://js2flowchart/./src/builder/abstraction-levels/functionDependencies.js","webpack://js2flowchart/./src/builder/abstraction-levels/functions.js","webpack://js2flowchart/./src/builder/abstractionLevelsConfigurator.js","webpack://js2flowchart/./src/builder/astBuilder.js","webpack://js2flowchart/./src/builder/astParserConfig.js","webpack://js2flowchart/./src/builder/converters/Harmony.js","webpack://js2flowchart/./src/builder/converters/core.js","webpack://js2flowchart/./src/builder/entryDefinitionsMap.js","webpack://js2flowchart/./src/builder/modifiers/modifiersFactory.js","webpack://js2flowchart/./src/presentation-generator/PresentationGenerator.js","webpack://js2flowchart/./src/render/svg/SVGBase.js","webpack://js2flowchart/./src/render/svg/SVGRender.js","webpack://js2flowchart/./src/render/svg/appearance/StyleThemeFactory.js","webpack://js2flowchart/./src/render/svg/appearance/TextContentConfigurator.js","webpack://js2flowchart/./src/render/svg/appearance/themes/BlackAndWhite.js","webpack://js2flowchart/./src/render/svg/appearance/themes/Blurred.js","webpack://js2flowchart/./src/render/svg/appearance/themes/DefaultBaseTheme.js","webpack://js2flowchart/./src/render/svg/appearance/themes/Light.js","webpack://js2flowchart/./src/render/svg/connections/ConnectionArrow.js","webpack://js2flowchart/./src/render/svg/shapes/BaseShape.js","webpack://js2flowchart/./src/render/svg/shapes/BreakStatement.js","webpack://js2flowchart/./src/render/svg/shapes/CallExpression.js","webpack://js2flowchart/./src/render/svg/shapes/CatchClause.js","webpack://js2flowchart/./src/render/svg/shapes/ClassDeclaration.js","webpack://js2flowchart/./src/render/svg/shapes/ConditionRhombus.js","webpack://js2flowchart/./src/render/svg/shapes/ContinueStatement.js","webpack://js2flowchart/./src/render/svg/shapes/DebuggerStatement.js","webpack://js2flowchart/./src/render/svg/shapes/DestructedNode.js","webpack://js2flowchart/./src/render/svg/shapes/ExportDeclaration.js","webpack://js2flowchart/./src/render/svg/shapes/ImportDeclaration.js","webpack://js2flowchart/./src/render/svg/shapes/ImportSpecifier.js","webpack://js2flowchart/./src/render/svg/shapes/LoopRhombus.js","webpack://js2flowchart/./src/render/svg/shapes/ObjectProperty.js","webpack://js2flowchart/./src/render/svg/shapes/Rectangle.js","webpack://js2flowchart/./src/render/svg/shapes/ReturnStatement.js","webpack://js2flowchart/./src/render/svg/shapes/Rhombus.js","webpack://js2flowchart/./src/render/svg/shapes/RootCircle.js","webpack://js2flowchart/./src/render/svg/shapes/SwitchCase.js","webpack://js2flowchart/./src/render/svg/shapes/SwitchStatement.js","webpack://js2flowchart/./src/render/svg/shapes/ThrowStatement.js","webpack://js2flowchart/./src/render/svg/shapes/TryStatement.js","webpack://js2flowchart/./src/render/svg/shapes/VerticalEdgedRectangle.js","webpack://js2flowchart/./src/render/svg/shapesDefinitionsMap.js","webpack://js2flowchart/./src/render/svg/shapesFactory.js","webpack://js2flowchart/./src/render/svg/svgObjectsBuilder.js","webpack://js2flowchart/./src/shared/constants.js","webpack://js2flowchart/./src/shared/utils/composition.js","webpack://js2flowchart/./src/shared/utils/flatten.js","webpack://js2flowchart/./src/shared/utils/geometry.js","webpack://js2flowchart/./src/shared/utils/iteratorBuilder.js","webpack://js2flowchart/./src/shared/utils/logger.js","webpack://js2flowchart/./src/shared/utils/string.js","webpack://js2flowchart/./src/shared/utils/svgPrimitives.js","webpack://js2flowchart/./src/shared/utils/traversal.js","webpack://js2flowchart/./src/shared/utils/traversalWithTreeLevelsPointer.js","webpack://js2flowchart/./src/shared/utils/treeLevelsPointer.js"],"names":["createFlowTreeBuilder","FlowTreeBuilder","createFlowTreeModifier","createFlowTreeModifierFromBuilder","createSVGRender","SVGRender","createShapesTreeEditor","ShapesTreeEditor","createPresentationGenerator","PresentationGenerator","ABSTRACTION_LEVELS","DEFINED_MODIFIERS","MODIFIER_PRESETS","TOKEN_TYPES","MODIFIED_TYPES","convertCodeToSvg","code","printConfig","convertFlowTreeToSvg","convertCodeToFlowTree","flowTreeBuilder","build","flowTree","svgRender","shapesTree","buildShapesTree","print","buildFlowTree","astTree","astVisitorConfig","treeNodes","root","length","type","PROGRAM","name","body","modifiers","setModifier","modifier","addModifier","registerNewModifier","test","updates","create","destructNodeTree","newNameFn","applyToFlowTree","applyTo","astParser","astVisitor","astParserConfig","definitionsMap","DefinitionsList","globalIgnore","defaultModifier","setAbstractionLevel","level","resetAbstractionLevelToNormal","setIgnoreFilter","fn","ast","buildAst","buildFlowTreeFromAst","e","message","stack","executeApplyFn","apply","node","UpdatesMap","prefixName","parent","applyModifierUpdates","tree","nodes","Object","keys","filter","i","forEach","updateName","includes","subTreeUpdate","modifiersList","concat","push","item","runModifier","isNodeContainsFunctionCall","CALL_EXPRESSION","getCustomAssignmentExpression","assignmentExpression","DefinitionsMap","ASSIGNMENT_EXPRESSION","getName","right","ignore","path","getCustomVariableDeclarator","variableDeclarator","VARIABLE_DECLARATOR","init","getFunctionDependenciesLevel","defined","custom","getCustomFunctionDeclaration","functionDeclaration","FUNCTION","nameConfig","OBJECT_PROPERTY","key","getFunctionsLevel","FUNCTION_DEPENDENCIES","CLASS","CLASS_DECLARATION","IMPORT","IMPORT_DECLARATION","IMPORT_SPECIFIER","IMPORT_DEFAULT_SPECIFIER","EXPORT","EXPORT_NAMED_DECLARATION","EXPORT_DEFAULT_DECLARATION","rebuildConfigForAbstractionLevel","definedLevels","customLevels","Array","isArray","indexOf","babylon","parseCodeToAST","config","parse","defaultAstConfig","loc","buildVisitor","treeNodesDestination","pointer","wrapByGlobalIgnore","visit","reduce","acc","reversed","exit","visitSimpleEntry","enter","enterComplexEntry","exitComplexEntry","entryConfig","getBasicEntryConfig","pushEntry","pushComplexEntry","stepIn","entry","getCurrent","getStatementParentKey","statementParent","find","parentKey","TOKEN_KEYS","isStatementOrBlock","stepOut","nameOptions","isBodyEntry","BODY","subType","sourceType","plugins","importDeclarationConverter","source","exportNamedDeclarationConverter","getExportedTokenName","exportDefaultDeclarationConverter","declaration","specifiers","getExportDeclarations","FUNCTION_DECLARATION","ARROW_FUNCTION_EXPRESSION","id","VARIABLE_DECLARATION","declarations","IDENTIFIER","left","classDeclarationConverter","superClass","objectPatternConverter","arrayPatternConverter","idleConverter","identifierConverter","SPREAD_PROPERTY","functionConverter","paramsCode","getFunctionParametersCode","params","getAnonymousFunctionName","CLASS_METHOD","OBJECT_METHOD","kind","CLASS_FUNCTION_KINDS","CONSTRUCTOR","pathParentType","parentId","map","p","join","returnConverter","argument","CONDITIONAL_EXPRESSION","OBJECT_EXPRESSION","isFunctionType","loopConverter","innerPart","FOR_OF_STATEMENT","leftPart","getVariableDeclarations","continueConverter","label","conditionalConverter","tryConverter","catchConverter","param","finallyConverter","switchStatementConverter","discriminant","caseConverter","breakConverter","withStatementConverter","object","programConverter","throwStatementConverter","debuggerConverter","variables","variableDeclaratorConverter","v","parentKind","isNodeContainsFunc","variableName","OBJECT_PATTERN","ARRAY_PATTERN","NEW_EXPRESSION","callExpressionConverter","objectExpressionConverter","assignmentExpressionConverter","getLeftAssignmentName","operator","argumentsCode","arguments","getArgumentName","callee","MEMBER_EXPRESSION","property","chain","value","STRING_LITERAL","objectPropertyConverter","getFirstCallee","FUNCTION_EXPRESSION","functions","singleTypeFilter","getStatementParent","CONSEQUENT","ALTERNATE","listKey","isReturnStatement","isLoop","isConditional","RETURN","BINARY_EXPRESSION","UPDATE_EXPRESSION","LOGICAL_EXPRESSION","ASSIGNMENT_PATTERN","REST_PROPERTY","SPREAD_ELEMENT","ARRAY_EXPRESSION","UNARY_EXPRESSION","SWITCH_STATEMENT","SWITCH_CASE","isVariableDeclaration","TEST","THROW_STATEMENT","LOOP","CONTINUE","CONDITIONAL","BREAK","TRY_STATEMENT","CATCH_CLAUSE","WITH_STATEMENT","DEBUGGER_STATEMENT","NUMERIC_LITERAL","properties","parentPath","extractNodeName","field","split","testNode","destructionModifier","DESTRUCTED","arrowFunctionReturnModifier","expressionCallbacksModifier","parentBody","index","sibling","n","es5ArrayIterators","buildTreeByAbstractionLevels","levels","generateExportSlideTree","generateImportExportSlideTree","generateClassFunctionSlideTree","generateClassFunctionDependenciesSlideTree","generateRegularSlideTree","buildSlides","slides","slide","SVGBase","state","shapes","arrowConnections","getShapes","addShapes","addArrowConnections","printChildren","svgString","calculateDimensions","boundaries","getBoundaries","padding","w","Math","ceil","max","x","h","y","updateShapeTheme","shape","shapeStyles","connectionArrowStyles","updateTheme","getAssignedConnectionArrow","getLoopedConnectionArrow","findShape","fnTest","startIndex","svgObjectsTree","applyShapeStyles","blur","blurredTheme","connectionArrow","getShapeType","getFieldName","focus","blurShapeBranch","shapeBranch","focusShapeBranch","fns","flatShape","branchIndex","customStyleTheme","theme","applyTheme","newThemeStyles","applyDefaultTheme","applyBlackAndWhiteTheme","applyBlurredTheme","applyLightTheme","applyColorBasedTheme","colors","ThemeNamesMap","DEFAULT","BLACK_AND_WHITE","BLURRED","LIGHT","Themes","getTheme","themeName","applyStyleToTheme","getDefaultTheme","getBlackAndWhiteTheme","getBlurredTheme","getLightTheme","styles","buildColorsBasedTheme","MAX_NAME_STR_LENGTH","NAME_SPLITTER_TOKENS","getNameSplitterTokensIterator","Colors","DefaultColors","strokeColor","defaultFillColor","textColor","arrowFillColor","rectangleFillColor","rectangleDotFillColor","functionFillColor","rootCircleFillColor","loopFillColor","conditionFillColor","destructedNodeFillColor","classFillColor","debuggerFillColor","exportFillColor","throwFillColor","tryFillColor","objectFillColor","callFillColor","debugModeFillColor","buildTheme","BaseShape","color","strokeWidth","fillColor","fontFamily","fontSize","lineHeight","symbolHeight","symbolWidth","horizontalPadding","verticalPadding","childOffset","margin","roundBorder","complexTypeExtraSpace","debugFontSize","debugTextColor","ConnectionArrow","arrow","size","line","curveTurnRadius","lineTurnOffset","Shape","Rectangle","dot","offset","radius","VerticalEdgedRectangle","edgeOffset","RootCircle","LoopRhombus","thinPartOffset","rhombusSize","doubleLayerOffsetA","doubleLayerOffsetB","positionTopShift","ConditionRhombus","alternateBranchOffset","markOffset","RootStartPoint","center","ReturnStatement","handlerLength","sizeX","sizeY","DestructedNode","suffix","width","space","ClassDeclaration","DebuggerStatement","ExportDeclaration","ImportDeclaration","ImportSpecifier","ThrowStatement","TryStatement","CatchClause","SwitchStatement","BreakStatement","SwitchCase","ContinueStatement","ObjectProperty","CallExpression","getAlignedColors","defaultColor","themeCopy","ENTITY_FIELD_NAME","setupSelectors","setupUpdateBehaviour","newTheme","setupPrintBehaviour","printLine","points","printArrow","point","arrowPoints","printArrowByType","arrowSize","ARROW_TYPE","RIGHT","LEFT","DOWN","linePoints","arrowPoint","arrowType","noArrow","originalTheme","delegateInit","themeFieldName","position","getInitialState","getThemeFieldName","nameParts","totalNamePartsNumber","maxNamePartLength","nodePathId","initialPosition","setupInitialProperties","fromPoint","calculateFromPoint","toPoint","calculateToPoint","backPoint","calculateBackPoint","childOffsetPoint","calculateChildOffsetPoint","calculateBoundaries","extractBasicState","calculatePosition","dimensions","setupInitialSelectors","getBody","getBackPoint","getChildOffsetPoint","getDimensions","getId","getFromPoint","getMargin","getNode","getNodeType","getNodePathId","getNodeKey","getParent","getPosition","getToPoint","setupSharedPrint","printName","newPosition","part","printDebugInfo","debug","setupGetChildBoundaries","getChildBoundaries","filterFn","flattedTree","setupStateModifiers","addChild","child","setParent","connectChild","assignConnectionArrow","setupBasicBehaviour","assign","setupCompleteState","initialState","calculateNameBasedWidth","calculateNameBasedHeight","calculateWidth","calculateHeight","min","calculateAlternateFromPoint","alternateFromPoint","setupAdditionalSelectors","getAlternateFromPoint","setupConditionRhombusBehavior","getConsequentBranchChildBoundary","getAlternativeBranchChildOffsetPoint","rightLimit","checkIfChildExist","printConditionMarks","R","text","positive","alternative","rH","namePosition","setupDestructedNodeBehaviour","suffixTheme","suffix1","suffix2","LoopMarksMap","FOR_IN_STATEMENT","FOR_STATEMENT","WHILE_STATEMENT","DO_WHILE_STATEMENT","calculateMidPoint","midPoint","getMidPoint","loopedConnectionArrow","setupLoopRhombusBehavior","assignLoopedConnectionArrow","setupRectangleBehavior","dotTheme","setupReturnStatementBehaviour","arrowTheme","r","setupCircleBehavior","setChildOffsetPoint","setupVerticalEdgedRectangleBehavior","getShapeForNode","createShapeForNode","styleTheme","shapeStyle","createRootCircle","createConnectionArrow","connectionArrowStyle","arrowConfig","getConnectionConfig","startPoint","endPoint","boundaryPoint","buildSVGObjectsTree","svg","shapeStructures","buildShapeStructures","connections","buildConnections","list","shapesList","latestNode","parentNode","parentShape","addExtraSpacingBeforeShape","alternatePoint","complexNodeTypes","pushArrow","connection","latestShape","latestParentShape","buildConnectionConfig","isNoArrow","toShape","fromShape","EXPRESSION_STATEMENT","THIS_EXPRESSION","UP","METHOD","CUSTOM","assignState","extensionsList","mergeObjectStructures","destination","flatTree","flatList","calculateShapesBoundaries","Error","first","minX","maxX","minY","maxY","addOffsetToPoints","offsetPoint","buildIterator","getNext","reset","logError","console","error","generateId","replace","random","c","toString","getPathId","queue","shift","toUpperCase","splitNameString","str","maxLineLength","nameSplitterTokensIterator","strLength","slice","parts","currentPositionIndex","splitter","splitterIndex","getMaxStringLengthFromList","current","currentLength","SvgStyleFieldsMap","from","to","extractStylePropsFromTheme","extractStyleAttrsFromTheme","getRhombus","getRoundedRectangle","getRectangle","getLine","x1","y1","x2","y2","getCircle","getText","getClosedPath","pointStr","getCurvedPath","previousPoint","getLinePointStr","getArcEndPointStr","getShiftedByArcNextPointValue","pointValue","previousPointValue","getArcEndPointValue","levelsTraversal","onNode","options","traversal","nodeBody","traversalSearch","result","complexTraversal","onStepIn","onStepOut","levelsPointer","setupPointer","cache","step","pop"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;AClFA;;;;AAOA;;;;AACA;;;;AACA;;;;AAEO,IAAMA,wDAAwBC,yBAA9B;AACA,IAAMC,0DAAyBC,uCAA/B;;AAEA,IAAMC,4CAAkBC,mBAAxB;AACA,IAAMC,0DAAyBC,2BAA/B;;AAEA,IAAMC,oEAA8BC,+BAApC;;QAEEC,kB,GAAAA,mC;QAAoBC,iB,GAAAA,kC;QAAmBC,gB,GAAAA,iC;QAAkBC,W,GAAAA,sB;QAAaC,c,GAAAA,yB;AAExE,IAAMC,8CAAmB,SAAnBA,gBAAmB,CAACC,IAAD,EAAOC,WAAP;AAAA,WAAuBC,qBAAqBC,sBAAsBH,IAAtB,CAArB,EAAkDC,WAAlD,CAAvB;AAAA,CAAzB;;AAEA,IAAME,wDAAwB,SAAxBA,qBAAwB,CAACH,IAAD,EAAU;AAC3C,QAAMI,kBAAkBpB,uBAAxB;;AAEA,WAAOoB,gBAAgBC,KAAhB,CAAsBL,IAAtB,CAAP;AACH,CAJM;;AAMA,IAAME,sDAAuB,SAAvBA,oBAAuB,CAACI,QAAD,EAAWL,WAAX,EAA2B;AAC3D,QAAMM,YAAYnB,iBAAlB;;AAEA,QAAMoB,aAAaD,UAAUE,eAAV,CAA0BH,QAA1B,CAAnB;;AAEA,WAAOE,WAAWE,KAAX,CAAiBT,WAAjB,CAAP;AACH,CANM,C;;;;;;;;;;;;AC7BM;AACb;AACA,6BAA6B,YAAY,IAAI,IAAI,MAAM,IAAI;AAC3D;;;;;;;;;;;;;ACHA,8CAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;AChEY;;AAEb;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,oDAAW;;AAEnC;;AAEA,eAAe,mBAAO,CAAC,oDAAS;;AAEhC;;AAEA,aAAa,mBAAO,CAAC,4CAAO;;AAE5B;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mEAAmE,aAAa;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA,oC;;;;;;;;;;;;AC5Ia;;AAEb;AACA;;AAEA,wCAAwC,mBAAO,CAAC,sDAAY;;AAE5D,sCAAsC,uCAAuC,gBAAgB;;AAE7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED,yB;;;;;;;;;;;;AC5Oa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,aAAa,mBAAO,CAAC,uEAAS;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzDa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACnJa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,gCAAgC,mBAAO,CAAC,iEAAS;;AAEjD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/Oa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,eAAe,mBAAO,CAAC,2EAAW;;AAElC,aAAa,mBAAO,CAAC,uEAAS;;AAE9B,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB,GAAG;AACH,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,kBAAkB;AAClB,GAAG;AACH,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACriBa;;AAEb;;AAEA,wBAAwB,mBAAO,CAAC,+FAAqB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,mBAAmB,mBAAO,CAAC,mFAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,kBAAkB,mBAAO,CAAC,iFAAc;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,eAAe,mBAAO,CAAC,2EAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,eAAe,mBAAO,CAAC,2EAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,eAAe,mBAAO,CAAC,2EAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,aAAa,mBAAO,CAAC,uEAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,qEAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,qEAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,WAAW,mBAAO,CAAC,mEAAO;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,kBAAkB,mBAAO,CAAC,iFAAc;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,E;;;;;;;;;;;;ACtIY;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;;AAEA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;;ACpHa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,uBAAuB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC5Ia;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3Ma;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;;AAEA,eAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7Ta;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,yCAAyC;AAC1E;AACA;;AAEA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7Ba;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,oCAAoC,mBAAO,CAAC,4CAAO;;AAEnD,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACpJa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe;AACf;;AAEA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe;;AAEf;AACA;AACA;;AAEA,gJAAgJ;AAChJ;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AClnBa;;AAEb;AACA;AACA;;AAEA,wCAAwC,mBAAO,CAAC,sEAAc;;AAE9D,sCAAsC,mBAAO,CAAC,gEAAW;;AAEzD,sCAAsC,uCAAuC,gBAAgB;;AAE7F,+CAA+C,0DAA0D,2CAA2C,iCAAiC;;AAErL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1Ga;;AAEb;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,mBAAO,CAAC,2EAAc;;AAE/D,qCAAqC,mBAAO,CAAC,6EAAe;;AAE5D,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA,mJAAmJ;AACnJ;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACrHa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACrNa;;AAEb;AACA;;AAEA,kCAAkC,mBAAO,CAAC,gDAAY;;AAEtD,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,mBAAmB,8BAA8B;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC,E;;;;;;;;;;;;AC9KY;;AAEb;AACA;;AAEA,wCAAwC,mBAAO,CAAC,4DAAkB;;AAElE,qCAAqC,mBAAO,CAAC,sDAAe;;AAE5D,qCAAqC,mBAAO,CAAC,8DAAU;;AAEvD,gCAAgC,mBAAO,CAAC,gEAAQ;;AAEhD,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,iDAAiD,mBAAO,CAAC,4EAAc;;AAEvE,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oCAAoC;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,kCAAkC;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;;AAEA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA,iJAAiJ;AACjJ;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3jBa;;AAEb;AACA;;AAEA,wCAAwC,mBAAO,CAAC,2DAAY;;AAE5D,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;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CA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,uB;;;;;;;;;;;;AC9Ha;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,oCAAoC,mBAAO,CAAC,gEAAS;;AAErD,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA,4BAA4B,cAAc;AAC1C;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC/La;;AAEb;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACpCa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,mBAAO,CAAC,4DAAU;;AAEtD,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0IAA0I;AAC1I;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uJAAuJ;AACvJ;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACvQa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,sDAAsD,mBAAO,CAAC,0FAA4B;;AAE1F,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7bA,8CAAa;;AAEb;AACA;AACA;;AAEA,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8IAA8I;AAC9I;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sJAAsJ;AACtJ;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qJAAqJ;AACrJ;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;;ACrca;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,mBAAO,CAAC,gEAAS;;AAErD,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,i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;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC9Ka;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,+CAA+C,mBAAO,CAAC,kGAAqB;;AAE5E,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,C;;;;;;;;;;;;ACjNa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,mBAAO,CAAC,0DAAiB;;AAEhE,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,8BAA8B;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qJAAqJ;AACrJ;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,6JAA6J;AAC7J;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/Ta;;AAEb;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,kBAAkB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED,8B;;;;;;;;;;;;ACzLa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD,sB;;;;;;;;;;;;ACnCa;;AAEb;AACA;;AAEA,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;;;;;;;;;AC3Ka;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,4DAAU;;AAE/B,sCAAsC,mBAAO,CAAC,4EAAe;;AAE7D,oCAAoC,mBAAO,CAAC,gEAAS;;AAErD,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;;AAEA;;AAEA,kJAAkJ;AAClJ;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACzNa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,mBAAO,CAAC,wFAAqB;;AAEjD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAO,CAAC,sEAAkB;;AAEhD,oCAAoC,mBAAO,CAAC,4DAAU;;AAEtD,qCAAqC,mBAAO,CAAC,gEAAS;;AAEtD,eAAe,mBAAO,CAAC,oDAAS;;AAEhC,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yJAAyJ;AACzJ;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,C;;;;;;;;;;;;AC1Pa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,0B;;;;;;;;;;;;ACtEa;;AAEb;AACA;;AAEA,uCAAuC,mBAAO,CAAC,0DAAiB;;AAEhE,qCAAqC,mBAAO,CAAC,sDAAe;;AAE5D,sCAAsC,mBAAO,CAAC,6EAAe;;AAE7D,oCAAoC,mBAAO,CAAC,4DAAU;;AAEtD,uCAAuC,mBAAO,CAAC,0DAAiB;;AAEhE,uCAAuC,mBAAO,CAAC,qEAAW;;AAE1D,sCAAsC,mBAAO,CAAC,gDAAS;;AAEvD,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,aAAa,mBAAO,CAAC,4DAAU;;AAE/B;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uJAAuJ;AACvJ;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL,6JAA6J;AAC7J;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0JAA0J;AAC1J;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mKAAmK;AACnK;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kKAAkK;AAClK;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,0KAA0K;AAC1K;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD,wB;;;;;;;;;;;;ACl+Ba;;AAEb;AACA;;AAEA,sCAAsC,mBAAO,CAAC,sEAAY;;AAE1D,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,0B;;;;;;;;;;;;AC/Ha;;AAEb;AACA;AACA;AACA;;AAEA,2CAA2C,mBAAO,CAAC,6FAA0B;;AAE7E,gCAAgC,mBAAO,CAAC,4DAAa;;AAErD,oCAAoC,mBAAO,CAAC,oDAAc;;AAE1D,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8IAA8I;AAC9I;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wJAAwJ;AACxJ;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,+HAA+H,kBAAkB;AACjJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kJAAkJ;AAClJ;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrSa;;AAEb;AACA;;AAEA,WAAW,mBAAO,CAAC,4FAAkC;;AAErD;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mH;;;;;;;;;;;;ACrCa;;AAEb;;AAEA,sBAAsB,mBAAO,CAAC,sHAA+C;;AAE7E;;AAEA,iBAAiB,mBAAO,CAAC,oGAAsC;;AAE/D;;AAEA,oBAAoB,mBAAO,CAAC,gGAAoC;;AAEhE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAO,CAAC,oEAAsB;;AAEnD;;AAEA,gBAAgB,mBAAO,CAAC,0DAAiB;;AAEzC;;AAEA,aAAa,mBAAO,CAAC,wDAAS;;AAE9B;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qJAAqJ;AACrJ;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA,6KAA6K;AAC7K;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,+JAA+J;AAC/J;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC7Va;;AAEb,aAAa,mBAAO,CAAC,yDAAU;;AAE/B;;AAEA,iBAAiB,mBAAO,CAAC,iEAAc;;AAEvC,cAAc,mBAAO,CAAC,oEAAS;;AAE/B;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;AC5rBY;;AAEb,aAAa,mBAAO,CAAC,oEAAS;;AAE9B;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACjWY;;AAEb,aAAa,mBAAO,CAAC,oEAAS;;AAE9B;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACtGY;;AAEb,aAAa,mBAAO,CAAC,oEAAS;;AAE9B;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;AC5RY;;AAEb;AACA;;AAEA,oBAAoB,mBAAO,CAAC,gGAAoC;;AAEhE;;AAEA,iBAAiB,mBAAO,CAAC,oGAAsC;;AAE/D;;AAEA,eAAe,mBAAO,CAAC,oFAA8B;;AAErD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,yDAAU;;AAE/B;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE,aAAa;AAC9E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,qEAAqE,eAAe;AACpF;AACA;;AAEA;AACA;;AAEA,uJAAuJ;AACvJ;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,qEAAqE,eAAe;AACpF;AACA;;AAEA;AACA;;AAEA,+JAA+J;AAC/J;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mEAAmE,eAAe;AAClF;AACA;;AAEA;AACA,6JAA6J;AAC7J;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yLAAyL;AACzL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,e;;;;;;;;;;;;ACxPa;;AAEb,mBAAO,CAAC,oEAAS;;AAEjB,mBAAO,CAAC,kEAAQ;;AAEhB,mBAAO,CAAC,sEAAU;;AAElB,mBAAO,CAAC,kEAAQ;;AAEhB,mBAAO,CAAC,gEAAO;;AAEf,mBAAO,CAAC,kEAAQ;;AAEhB,mBAAO,CAAC,kFAAgB,E;;;;;;;;;;;;ACdX;;AAEb,aAAa,mBAAO,CAAC,oEAAS;;AAE9B;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;AClJY;;AAEb,aAAa,mBAAO,CAAC,oEAAS;;AAE9B;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACpBY;;AAEb;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,wDAAS;;AAE9B;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,C;;;;;;;;;;;;AC3Ga;;AAEb;AACA;;AAEA,6BAA6B,mBAAO,CAAC,sIAAuD;;AAE5F;;AAEA,oBAAoB,mBAAO,CAAC,gGAAoC;;AAEhE;;AAEA,YAAY,mBAAO,CAAC,8FAAmC;;AAEvD;;AAEA,iBAAiB,mBAAO,CAAC,oGAAsC;;AAE/D;;AAEA,iBAAiB,mBAAO,CAAC,gEAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAO,CAAC,kEAAc;;AAExC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,kBAAkB,mBAAO,CAAC,kEAAc;;AAExC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,kBAAkB,mBAAO,CAAC,kEAAc;;AAExC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,YAAY,mBAAO,CAAC,sDAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,wBAAwB,mBAAO,CAAC,sEAAoB;;AAEpD;;AAEA,aAAa,mBAAO,CAAC,oDAAc;;AAEnC;;AAEA,YAAY,mBAAO,CAAC,kDAAa;;AAEjC;;AAEA,mBAAO,CAAC,8EAAoB;;AAE5B,mBAAmB,mBAAO,CAAC,0EAAe;;AAE1C,cAAc,mBAAO,CAAC,wDAAS;;AAE/B;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,yJAAyJ;AACzJ;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,8JAA8J;AAC9J;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4JAA4J;AAC5J;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sKAAsK;AACtK;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+KAA+K;AAC/K;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4KAA4K;AAC5K;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4JAA4J;AAC5J;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,mKAAmK;AACnK;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,2JAA2J;AAC3J;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oKAAoK;AACpK;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACl0Ba;;AAEb;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,wDAAS;;AAE9B;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,0BAA0B;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC/Ea;;AAEb;;AAEA,cAAc,mBAAO,CAAC,kGAAqC;;AAE3D;;AAEA;AACA;;AAEA,aAAa,mBAAO,CAAC,wDAAS;;AAE9B;;AAEA,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACnHa;;AAEb;;AAEA,YAAY,mBAAO,CAAC,8FAAmC;;AAEvD;;AAEA,eAAe,mBAAO,CAAC,oFAA8B;;AAErD;;AAEA,oBAAoB,mBAAO,CAAC,gGAAoC;;AAEhE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAO,CAAC,kEAAc;;AAExC,eAAe,mBAAO,CAAC,oDAAS;;AAEhC;;AAEA,aAAa,mBAAO,CAAC,wDAAS;;AAE9B;;AAEA,iBAAiB,mBAAO,CAAC,gEAAa;;AAEtC,uCAAuC,6BAA6B,YAAY,EAAE,OAAO,iBAAiB,mBAAmB,uBAAuB,4EAA4E,EAAE,EAAE,sBAAsB,eAAe,EAAE;;AAE3Q,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iKAAiK;AACjK;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,cAAc;AACtD;;AAEA;AACA,4GAA4G,kBAAkB;AAC9H;;AAEA;AACA,wDAAwD,aAAa;AACrE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,8JAA8J;AAC9J;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACxQa;;AAEb,8CAA8C,cAAc;;AAE5D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,0BAA0B;AAC1B;AACA;AACA,GAAG;AACH,6BAA6B;AAC7B;AACA;AACA,GAAG;AACH,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,wBAAwB;AACxB;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iCAAiC;AACjC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC,mCAAmC;AACnC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,8DAA8D,gCAAgC;AAC9F;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0DAA0D,8BAA8B;AACxF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,EAAE,cAAc,EAAE;AAC3C,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sEAAsE,qCAAqC;AAC3G;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oDAAoD,4BAA4B;AAChF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,eAAe,8BAA8B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,6BAA6B;AACtF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,8DAA8D,gCAAgC;AAC9F;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,mFAAmF,qCAAqC;AACxH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA,KAAK;AACL,yDAAyD,+BAA+B;AACxF;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4DAA4D,+BAA+B;AAC3F;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4FAA4F,aAAa;AACzG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4EAA4E,eAAe;AAC3F;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,gDAAgD,2BAA2B;AAC3E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC3zTA,+CAAa;AACb,yBAAyB,mBAAO,CAAC,0EAAsB;AACvD,iBAAiB,mBAAO,CAAC,wDAAa;AACtC,gBAAgB,mBAAO,CAAC,sDAAY;AACpC,cAAc,mBAAO,CAAC,kDAAU;AAChC,oBAAoB,mBAAO,CAAC,8DAAgB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;;AAE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O,CAAC,8EAAgB;AAC1C,qBAAqB,mBAAO,CAAC,0FAAsB;AACnD,qBAAqB,mBAAO,CAAC,4EAAe;AAC5C,eAAe,mBAAO,CAAC,8DAAQ;AAC/B,8CAA8C;AAC9C;AACA;AACA;;AAEA,8BAA8B,aAAa;;AAE3C;AACA;AACA;AACA;AACA;AACA,yCAAyC,oCAAoC;AAC7E,6CAA6C,oCAAoC;AACjF,KAAK,4BAA4B,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA,kCAAkC,2BAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;ACrEA;AACA,UAAU;AACV;;;;;;;;;;;;ACFA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA,WAAW,mBAAO,CAAC,8DAAQ;AAC3B,eAAe,mBAAO,CAAC,0EAAc;AACrC,UAAU,mBAAO,CAAC,8DAAQ;AAC1B,cAAc,mBAAO,CAAC,0EAAc;AACpC;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,kEAAU;AAChC,iDAAiD;AACjD,CAAC;AACD;AACA,qBAAqB;AACrB;AACA,SAAS;AACT,GAAG,EAAE;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpDA;AACA,eAAe,mBAAO,CAAC,0EAAc;AACrC,UAAU,mBAAO,CAAC,4EAAe;AACjC,kBAAkB,mBAAO,CAAC,kFAAkB;AAC5C,eAAe,mBAAO,CAAC,4EAAe;AACtC,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,4EAAe;AACtC;AAC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mBAAO,CAAC,8EAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,sBAAsB,uBAAuB,WAAW,IAAI;AAC5D,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA,KAAK;AACL;AACA,sBAAsB,mCAAmC;AACzD,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,gCAAgC;AAChG;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,EAAE,mBAAO,CAAC,8EAAgB;AAC1B,EAAE,mBAAO,CAAC,4EAAe;AACzB,EAAE,mBAAO,CAAC,8EAAgB;;AAE1B,sBAAsB,mBAAO,CAAC,sEAAY;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0DAA0D,kBAAkB;;AAE5E;AACA;AACA;AACA,oBAAoB,uBAAuB;;AAE3C,oDAAoD,6BAA6B;;AAEjF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,0BAA0B,eAAe,EAAE;AAC3C,0BAA0B,gBAAgB;AAC1C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO,QAAQ,iCAAiC;AACpG,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,oCAAoC,mBAAO,CAAC,gEAAS;AACrD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzOA,mBAAO,CAAC,4EAAe;;;;;;;;;;;;ACAvB,mBAAO,CAAC,4EAAe;;;;;;;;;;;;ACAvB,mBAAO,CAAC,0FAAsB;AAC9B,aAAa,mBAAO,CAAC,oEAAW;AAChC,WAAW,mBAAO,CAAC,gEAAS;AAC5B,gBAAgB,mBAAO,CAAC,0EAAc;AACtC,oBAAoB,mBAAO,CAAC,8DAAQ;;AAEpC;AACA;AACA;AACA;AACA;;AAEA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,kDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,sCAAI;;AAE/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACzMa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;;;;;;;;;;;;;AChGa;;AAEb,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;AC/IA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA,wCAAwC;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;;AAEA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;ACtIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,mBAAO,CAAC,kDAAQ;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,cAAc;;AAE5C;AACA;AACA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,cAAc;;AAE5C;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;ACpKA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,kBAAkB,mBAAO,CAAC,gDAAO;AACjC,mBAAmB,mBAAO,CAAC,kDAAQ;AACnC,sBAAsB,mBAAO,CAAC,wDAAW;AACzC,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;;;AChCA,iBAAiB,mBAAO,CAAC,2DAAgB;;;;;;;;;;;;;ACA5B;AACb,gBAAgB,mBAAO,CAAC,sDAAY;AACpC,wCAAwC;AACxC;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,IAAqC;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C,yBAAyB,EAAE;AACrE;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;;;;;;;;;;;;AChDa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC7CA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,6FAA6F,MAAM,OAAO,IAAI,GAAG,IAAI,KAAK,iJAAiJ,8BAA8B,IAAI,8CAA8C,kJAAkJ,EAAE,MAAM,aAAa,2BAA2B,EAAE,mBAAmB,IAAI,GAAG,IAAI,GAAG,IAAI,OAAO,IAAI,WAAW,OAAO;;AAEjmB;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe;AACf;AACA,aAAa;AACb,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE,IAEU;AACZ;AACA,EAAE,mCAAO;AACT;AACA,GAAG;AAAA,oGAAC;AACJ,EAAE,MAAM,EAQN;;AAEF,CAAC;;;;;;;;;;;;;ACxVD,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,WAAW,mBAAO,CAAC,+CAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,cAAc,mBAAO,CAAC,qDAAY;AAClC,cAAc,mBAAO,CAAC,qDAAY;AAClC,cAAc,mBAAO,CAAC,qDAAY;;AAElC;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/BA,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,sBAAsB,mBAAO,CAAC,qEAAoB;AAClD,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/BA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,WAAW,mBAAO,CAAC,+CAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;;ACNA,oBAAoB,mBAAO,CAAC,iEAAkB;AAC9C,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,kBAAkB,mBAAO,CAAC,6DAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/BA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,WAAW,mBAAO,CAAC,+CAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;;ACNA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,WAAW,mBAAO,CAAC,+CAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;;ACNA,eAAe,mBAAO,CAAC,uDAAa;AACpC,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,kBAAkB,mBAAO,CAAC,6DAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,eAAe,mBAAO,CAAC,uDAAa;AACpC,eAAe,mBAAO,CAAC,uDAAa;AACpC,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA,WAAW,mBAAO,CAAC,+CAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;;ACLA,WAAW,mBAAO,CAAC,+CAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;;ACLA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,WAAW,mBAAO,CAAC,+CAAS;;AAE5B;AACA;;AAEA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,MAAM;AACjB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA,kBAAkB,mBAAO,CAAC,6DAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,kBAAkB,mBAAO,CAAC,2DAAe;AACzC,cAAc,mBAAO,CAAC,mDAAW;AACjC,eAAe,mBAAO,CAAC,qDAAY;AACnC,cAAc,mBAAO,CAAC,qDAAY;AAClC,mBAAmB,mBAAO,CAAC,6DAAgB;;AAE3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA,sBAAsB,mBAAO,CAAC,qEAAoB;AAClD,SAAS,mBAAO,CAAC,yCAAM;;AAEvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3BA,SAAS,mBAAO,CAAC,yCAAM;;AAEvB;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,WAAW,mBAAO,CAAC,6CAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChBA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,aAAa,mBAAO,CAAC,iDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChBA,qBAAqB,mBAAO,CAAC,mEAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA,YAAY,mBAAO,CAAC,iDAAU;AAC9B,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,oBAAoB,mBAAO,CAAC,iEAAkB;AAC9C,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,aAAa,mBAAO,CAAC,mDAAW;AAChC,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,sBAAsB,mBAAO,CAAC,qEAAoB;AAClD,cAAc,mBAAO,CAAC,mDAAW;AACjC,eAAe,mBAAO,CAAC,qDAAY;AACnC,YAAY,mBAAO,CAAC,+CAAS;AAC7B,eAAe,mBAAO,CAAC,qDAAY;AACnC,YAAY,mBAAO,CAAC,+CAAS;AAC7B,WAAW,mBAAO,CAAC,6CAAQ;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;AC1KA,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;AC7BA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,qBAAqB,mBAAO,CAAC,mEAAmB;;AAEhD;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,aAAa,aAAa;AAC1B;AACA;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WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClFA,aAAa,mBAAO,CAAC,mDAAW;AAChC,mBAAmB,mBAAO,CAAC,6DAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjBA,YAAY,mBAAO,CAAC,iDAAU;AAC9B,kBAAkB,mBAAO,CAAC,6DAAgB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACXA,iBAAiB,mBAAO,CAAC,yDAAc;AACvC,eAAe,mBAAO,CAAC,uDAAa;AACpC,eAAe,mBAAO,CAAC,qDAAY;AACnC,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;A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AACA;;AAEA;;;;;;;;;;;;ACbA,cAAc,mBAAO,CAAC,qDAAY;;AAElC;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;;AClCA,eAAe,mBAAO,CAAC,qDAAY;AACnC,eAAe,mBAAO,CAAC,uDAAa;AACpC,kBAAkB,mBAAO,CAAC,6DAAgB;;AAE1C;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChBA,eAAe,mBAAO,CAAC,qDAAY;AACnC,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnBA,aAAa,mBAAO,CAAC,mDAAW;AAChC,eAAe,mBAAO,CAAC,uDAAa;AACpC,cAAc,mBAAO,CAAC,mDAAW;AACjC,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACbA,eAAe,mBAAO,CAAC,uDAAa;AACpC,oBAAoB,mBAAO,CAAC,iEAAkB;AAC9C,wBAAwB,mBAAO,CAAC,yEAAsB;AACtD,eAAe,mBAAO,CAAC,uDAAa;AACpC,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvEA,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACZA,cAAc,mBAAO,CAAC,mDAAW;AACjC,YAAY,mBAAO,CAAC,iDAAU;AAC9B,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;AACA;AA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;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClBA,gBAAgB,mBAAO,CAAC,yDAAc;;AAEtC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;ACVA,eAAe,mBAAO,CAAC,uDAAa;AACpC,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClFA,aAAa,mBAAO,CAAC,mDAAW;AAChC,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,SAAS,mBAAO,CAAC,yCAAM;AACvB,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/GA,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxFA;AACA;;AAEA;;;;;;;;;;;;;ACHA,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,WAAW,mBAAO,CAAC,6CAAQ;;AAE3B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfA,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,aAAa,mBAAO,CAAC,iDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;A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ClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChBA,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7BA,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA,uBAAuB,mBAAO,CAAC,uEAAqB;AACpD,oBAAoB,mBAAO,CAAC,iEAAkB;AAC9C,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,sBAAsB,mBAAO,CAAC,qEAAoB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5EA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,kBAAkB,mBAAO,CAAC,6DAAgB;;AAE1C;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA,SAAS,mBAAO,CAAC,yCAAM;AACvB,kBAAkB,mBAAO,CAAC,2DAAe;AACzC,cAAc,mBAAO,CAAC,qDAAY;AAClC,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7BA,cAAc,mBAAO,CAAC,mDAAW;AACjC,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACdA,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnBA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACjBA,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACZA,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AClBA,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfA,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA,WAAW,mBAAO,CAAC,+CAAS;AAC5B,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,UAAU,mBAAO,CAAC,6CAAQ;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjBA,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfA,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACfA,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnBA,cAAc,mBAAO,CAAC,mDAAW;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA,gBAAgB,mBAAO,CAAC,yDAAc;;AAEtC;AACA;;AAEA;;;;;;;;;;;;ACLA,cAAc,mBAAO,CAAC,qDAAY;;AAElC;AACA;;AAEA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnBA,+DAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;;;;;;;;;;;;AC7BA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACdA,YAAY,mBAAO,CAAC,iDAAU;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnCA,iBAAiB,mBAAO,CAAC,2DAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACRA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;;ACjBA,sBAAsB,mBAAO,CAAC,qEAAoB;AAClD,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;;AAEA;;;;;;;;;;;;ACbA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA,gBAAgB,mBAAO,CAAC,yDAAc;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACbA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,UAAU,mBAAO,CAAC,6CAAQ;AAC1B,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA,oBAAoB,mBAAO,CAAC,iEAAkB;;AAE9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;;;;;;;;;;;AC1BA,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,kBAAkB,mBAAO,CAAC,2DAAe;AACzC,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,WAAW,mBAAO,CAAC,6CAAQ;;AAE3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;ACzDA,gBAAgB,mBAAO,CAAC,yDAAc;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA,mBAAmB,SAAS,GAAG,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnCA,gBAAgB,mBAAO,CAAC,yDAAc;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA;AACA,mBAAmB,SAAS,GAAG,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,SAAS;AACtB;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,WAAW,SAAS,GAAG,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA,eAAe,mBAAO,CAAC,uDAAa;AACpC,SAAS,mBAAO,CAAC,yCAAM;AACvB,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,aAAa,mBAAO,CAAC,iDAAU;;AAE/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA,eAAe,SAAS,GAAG,SAAS,GAAG,SAAS;AAChD,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA,cAAc,mBAAO,CAAC,qDAAY;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,iBAAiB,QAAQ,OAAO,SAAS,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA,cAAc,mBAAO,CAAC,qDAAY;AAClC,cAAc,mBAAO,CAAC,qDAAY;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,aAAa,QAAQ;AACrB;AACA;AACA,iBAAiB,OAAO,SAAS;AACjC,yBAAyB,gBAAgB,SAAS,GAAG;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,cAAc,mBAAO,CAAC,qDAAY;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,aAAa,QAAQ;AACrB;AACA;AACA,0BAA0B,gBAAgB,SAAS,GAAG;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpBA,kBAAkB,mBAAO,CAAC,6DAAgB;AAC1C,kBAAkB,mBAAO,CAAC,2DAAe;AACzC,eAAe,mBAAO,CAAC,qDAAY;AACnC,gBAAgB,mBAAO,CAAC,uDAAa;AACrC,aAAa,mBAAO,CAAC,iDAAU;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpDA,sBAAsB,mBAAO,CAAC,qEAAoB;AAClD,mBAAmB,mBAAO,CAAC,6DAAgB;;AAE3C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA,6BAA6B,kBAAkB,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB,EAAE;AAClE;AACA;AACA;;AAEA;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzBA,iBAAiB,mBAAO,CAAC,yDAAc;AACvC,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA,yDAAW,mBAAO,CAAC,+CAAS;AAC5B,gBAAgB,mBAAO,CAAC,uDAAa;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrCA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA,gBAAgB,mBAAO,CAAC,uDAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,mBAAmB,mBAAO,CAAC,6DAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7DA,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,cAAc,mBAAO,CAAC,mDAAW;AACjC,mBAAmB,mBAAO,CAAC,6DAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7BA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,mBAAmB,mBAAO,CAAC,6DAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC5BA,uBAAuB,mBAAO,CAAC,uEAAqB;AACpD,gBAAgB,mBAAO,CAAC,yDAAc;AACtC,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA,oBAAoB,mBAAO,CAAC,iEAAkB;AAC9C,eAAe,mBAAO,CAAC,uDAAa;AACpC,kBAAkB,mBAAO,CAAC,2DAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA,oBAAoB,mBAAO,CAAC,iEAAkB;AAC9C,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,kBAAkB,mBAAO,CAAC,2DAAe;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/BA,eAAe,mBAAO,CAAC,uDAAa;AACpC,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,cAAc,mBAAO,CAAC,qDAAY;AAClC,cAAc,mBAAO,CAAC,mDAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B;AACA;AACA;AACA,MAAM,mBAAmB;AACzB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpDA,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChBA,mBAAmB,mBAAO,CAAC,+DAAiB;AAC5C,uBAAuB,mBAAO,CAAC,uEAAqB;AACpD,YAAY,mBAAO,CAAC,iDAAU;AAC9B,YAAY,mBAAO,CAAC,iDAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,SAAS;AACtB;AACA;AACA;AACA,MAAM,OAAO,SAAS,EAAE;AACxB,MAAM,OAAO,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/BA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,qBAAqB,mBAAO,CAAC,mEAAmB;AAChD,gBAAgB,mBAAO,CAAC,uDAAa;AACrC,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjBA,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzCA,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACnCA,eAAe,mBAAO,CAAC,qDAAY;AACnC,eAAe,mBAAO,CAAC,qDAAY;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjEA,mBAAmB,mBAAO,CAAC,+DAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3BA,eAAe,mBAAO,CAAC,uDAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA,iBAAiB,mBAAO,CAAC,2DAAe;AACxC,WAAW,mBAAO,CAAC,6CAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvJA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxHA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,yDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;;;;;;;;;;AC3IA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;;AAEhB,mBAAmB;AACnB,oBAAoB;;AAEpB,gBAAgB;AAChB,gBAAgB;;AAEhB,gBAAgB;AAChB,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AClEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC9GA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9EA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjHA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAQ;AAC3B,mBAAmB,mBAAO,CAAC,uEAAiB;AAC5C,eAAe,mBAAO,CAAC,+DAAa;AACpC,gBAAgB,mBAAO,CAAC,iEAAc;AACtC,gBAAgB,mBAAO,CAAC,iEAAc;;AAEtC;AACA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sDAAsD,YAAY;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wCAAwC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB,EAAE;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C,qBAAqB,+CAA+C;AACpE;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA,qBAAqB,4BAA4B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzjCA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,iEAAc;AACtC,WAAW,mBAAO,CAAC,qDAAQ;AAC3B,eAAe,mBAAO,CAAC,+DAAa;AACpC,kBAAkB,mBAAO,CAAC,qEAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/ZA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,mBAAO,CAAC,qFAAwB;AACzD,WAAW,mBAAO,CAAC,qDAAQ;;AAE3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH,UAAU;AACV;;AAEA;;;;;;;;;;;;AC5ZA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AChaA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mBAAO,CAAC,yFAA4B;AACjE,4BAA4B,mBAAO,CAAC,uFAA2B;AAC/D,qBAAqB,mBAAO,CAAC,uEAAmB;;;;;;;;;;;;;ACPnC;AACb,kBAAkB,mBAAO,CAAC,sDAAY;AACtC,6BAA6B,mBAAO,CAAC,gFAAyB;;AAE9D;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,gBAAgB;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACnCa;AACb,gBAAgB,mBAAO,CAAC,sDAAY;;AAEpC;AACA;AACA;;;;;;;;;;;;;ACLA,+CAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;ACjDY;AACb;AACA;AACA;AACA,0BAA0B;AAC1B,gBAAgB,4BAA4B,EAAE;AAC9C,M;AACA;AACA;AACA,eAAe;AACf;;;;;;;;;;;;;ACVa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACTA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,gBAAgB;AAChB,eAAe;AACf,C;;;;;;;;;;;;;;;;;;;;;ACrBA;;;;AAEA;;AACA;;AACA;;AAIA;;;;AACA;;AAOA;;AACA;;;;;;AAEA,IAAMU,gBAAgB,SAAhBA,aAAgB,CAACC,OAAD,EAAUC,gBAAV,EAA+B;AACjD,QAAMC,YAAY,EAAlB;;AAEA,iCAASF,OAAT,EAAkB,8BAAaC,gBAAb,EAA+BC,SAA/B,CAAlB;;AAEA,QAAMC,OAAQD,UAAUE,MAAV,IAAoBF,UAAU,CAAV,CAArB,IAAsC,EAAnD;AACA,WAAOC,KAAKE,IAAL,KAAcpB,uBAAYqB,OAA1B,GACDH,IADC,GAED,EAAEI,MAAM,MAAR,EAAgBF,MAAMpB,uBAAYqB,OAAlC,EAA2CE,MAAMN,SAAjD,EAFN;AAGH,CATD;;AAWA;AACO,IAAM5B,0DAAyB,SAAzBA,sBAAyB,GAAM;AACxC,QAAMmC,YAAY,iCAAlB;;AAEA,WAAO;AACHC,mBADG,uBACSC,QADT,EACmB;AAClBF,sBAAUG,WAAV,CAAsBD,QAAtB;AACH,SAHE;AAKHE,2BALG,+BAKiBC,IALjB,EAKuBC,OALvB,EAKgC;AAC/BN,sBAAUO,MAAV,CAAiBF,IAAjB,EAAuBC,OAAvB;AACH,SAPE;AASHE,wBATG,4BAScH,IATd,EASoBI,SATpB,EAS+B;AAC9B,iBAAKR,WAAL,CAAiB,2CAAoBI,IAApB,EAA0BI,SAA1B,CAAjB;AACH,SAXE;AAaHC,uBAbG,2BAaazB,QAbb,EAauB;AACtBe,sBAAUW,OAAV,CAAkB1B,QAAlB;AACA,mBAAOA,QAAP;AACH;AAhBE,KAAP;AAkBH,CArBM;;kBAuBQ,YAA8C;AAAA,mFAAP,EAAO;AAAA,8BAA3C2B,SAA2C;AAAA,QAA3CA,SAA2C,kCAA/B,EAA+B;AAAA,+BAA3BC,UAA2B;AAAA,QAA3BA,UAA2B,mCAAd,EAAc;;AACzD,QAAMC,+BACCF,SADD,CAAN;;AAIA,QAAMpB;AACFuB,qDAAoBC,oCAApB,EADE;AAEFC,sBAAc;AAFZ,OAGCJ,UAHD,CAAN;;AAMA,QAAMK,kBAAkBrD,wBAAxB;AACAqD,oBAAgBjB,WAAhB,CAA4B,oDAA5B;AACAiB,oBAAgBjB,WAAhB,CAA4B,oDAA5B;;AAEA,WAAO;AACHkB,2BADG,+BACiBC,KADjB,EACwB;AACvB5B,6BAAiBuB,cAAjB,GAAkC,qEAAiCK,KAAjC,CAAlC;AACH,SAHE;AAKHC,qCALG,2CAK6B;AAC5B7B,6BAAiBuB,cAAjB,gCAAsCC,oCAAtC;AACH,SAPE;AASHM,uBATG,2BASaC,EATb,EASiB;AAChB/B,6BAAiByB,YAAjB,GAAgCM,EAAhC;AACH,SAXE;AAaHvC,aAbG,iBAaGL,IAbH,EAaS;AACR,gBAAM6C,MAAM,KAAKC,QAAL,CAAc9C,IAAd,CAAZ;AACA,mBAAO,KAAK+C,oBAAL,CAA0BF,GAA1B,CAAP;AACH,SAhBE;AAkBHC,gBAlBG,oBAkBM9C,IAlBN,EAkBY;AACX,mBAAO,gCAAeA,IAAf,EAAqBmC,eAArB,CAAP;AACH,SApBE;AAsBHY,4BAtBG,gCAsBkBF,GAtBlB,EAsBuB;AACtB,gBAAIvC,WAAW,EAAf;;AAEA,gBAAI;AACAA,2BAAWK,cAAckC,GAAd,EAAmBhC,gBAAnB,CAAX;AACA0B,gCAAgBR,eAAhB,CAAgCzB,QAAhC;AACH,aAHD,CAGE,OAAO0C,CAAP,EAAU;AACR,sCAAS,kCAAkCA,EAAEC,OAA7C,EAAsDD,EAAEE,KAAxD;AACA,sBAAMF,CAAN;AACH;;AAED,mBAAO1C,QAAP;AACH;AAlCE,KAAP;AAoCH,C;;QAEQX,iB,GAAAA,mC;QAAmBC,gB,GAAAA,kC;QAAkBF,kB,GAAAA,iD;;;;;;;;;;;;;;;;;;AC3G9C;;AAEA,IAAMyD,iBAAiB,SAAjBA,cAAiB,CAACC,KAAD,EAAQC,IAAR;AAAA,WAAkB,OAAOD,KAAP,KAAiB,UAAjB,GAA8BA,MAAMC,IAAN,CAA9B,GAA4CD,KAA9D;AAAA,CAAvB;;AAEA,IAAME,aAAa;AACfnC,QADe,gBACVkC,IADU,EACJD,KADI,EACG;AACdC,aAAKlC,IAAL,GAAYgC,eAAeC,KAAf,EAAsBC,IAAtB,CAAZ;AACH,KAHc;AAKfE,cALe,sBAKJF,IALI,EAKED,KALF,EAKS;AACpBC,aAAKE,UAAL,GAAkBJ,eAAeC,KAAf,EAAsBC,IAAtB,CAAlB;AACH,KAPc;AASfpC,QATe,gBASVoC,IATU,EASJD,KATI,EASG;AACdC,aAAKpC,IAAL,GAAYkC,eAAeC,KAAf,EAAsBC,IAAtB,CAAZ;AACH,KAXc;AAafjC,QAbe,gBAaViC,IAbU,EAaJD,KAbI,EAaG;AACdC,aAAKjC,IAAL,GAAY+B,eAAeC,KAAf,EAAsBC,IAAtB,CAAZ;AACH,KAfc;AAiBfG,UAjBe,kBAiBRH,IAjBQ,EAiBFD,KAjBE,EAiBK;AAChBC,aAAKG,MAAL,GAAcL,eAAeC,KAAf,EAAsBC,IAAtB,CAAd;AACH;AAnBc,CAAnB;;AAsBA,IAAMI,uBAAuB,SAAvBA,oBAAuB,CAACC,IAAD,EAAOnC,QAAP,EAAoB;AAC7C,QAAMoC,QAAQ,gCAAgBD,IAAhB,EAAsBnC,SAASG,IAA/B,CAAd;;AAEA,QAAI,CAACiC,MAAM3C,MAAX,EAAmB;;AAEnB,QAAMW,UAAUiC,OAAOC,IAAP,CAAYtC,SAASI,OAAT,IAAoB,EAAhC,CAAhB;;AAEAA,YAAQmC,MAAR,CAAe;AAAA,eAAKC,MAAM,eAAX;AAAA,KAAf,EAA2CC,OAA3C,CAAmD,sBAAc;AAC7DL,cAAMK,OAAN,CAAc,gBAAQ;AAClBV,uBAAWW,UAAX,EAAuBZ,IAAvB,EAA6B9B,SAASI,OAAT,CAAiBsC,UAAjB,CAA7B;AACH,SAFD;AAGH,KAJD;;AAMA,QAAItC,QAAQuC,QAAR,CAAiB,eAAjB,CAAJ,EAAuC;AACnC3C,iBAASI,OAAT,CAAiBwC,aAAjB,CAA+BR,KAA/B,EAAsCD,IAAtC;AACH;AACJ,CAhBD;;kBAkBe,YAAM;AACjB,QAAMU,gBAAgB,EAAtB;;AAEA,WAAO;AACH5C,mBADG,uBACSD,QADT,EACmB;AAClB,eAAG8C,MAAH,CAAU9C,QAAV,EAAoByC,OAApB,CAA4B;AAAA,uBAAQI,cAAcE,IAAd,CAAmBC,IAAnB,CAAR;AAAA,aAA5B;AACH,SAHE;AAKH3C,cALG,kBAKIF,IALJ,EAKUC,OALV,EAKmB;AAClB,iBAAKH,WAAL,CAAiB,EAAEE,UAAF,EAAQC,gBAAR,EAAjB;AACH,SAPE;AASH6C,mBATG,uBASSd,IATT,EASenC,QATf,EASyB;AACxBkC,iCAAqBC,IAArB,EAA2BnC,QAA3B;AACH,SAXE;AAaHS,eAbG,mBAaK0B,IAbL,EAaW;AAAA;;AACVU,0BAAcJ,OAAd,CAAsB;AAAA,uBAAY,MAAKQ,WAAL,CAAiBd,IAAjB,EAAuBnC,QAAvB,CAAZ;AAAA,aAAtB;AACH;AAfE,KAAP;AAiBH,C;;;;;;;;;;;;;;;;;;;;;;;AChED;;AACA;;AACA;;AACA;;AAEA,IAAMkD,6BAA6B,SAA7BA,0BAA6B,OAAQ;AACvC,WAAOpB,QAAQA,KAAKpC,IAAL,KAAcpB,uBAAY6E,eAAzC;AACH,CAFD;;AAIA,IAAMC,gCAAgC,SAAhCA,6BAAgC,GAAM;AACxC,QAAMC,uBAAuBC,oCAAehF,uBAAYiF,qBAA3B,CAA7B;;AAEA,wBACOF,oBADP;AAEIG,iBAAS;AAAA,gBAAG1B,IAAH,QAAGA,IAAH;AAAA,mBAAc,mCAAwB,EAAEA,MAAMA,KAAK2B,KAAb,EAAxB,CAAd;AAAA,SAFb;AAGIC,gBAAQ;AAAA,mBACJL,qBAAqBK,MAArB,CAA4BC,IAA5B,KAAqC,CAACT,2BAA2BS,KAAK7B,IAAL,CAAU2B,KAArC,CADlC;AAAA;AAHZ;AAMH,CATD;;AAWA,IAAMG,8BAA8B,SAA9BA,2BAA8B,GAAM;AACtC,QAAMC,qBAAqBP,oCAAehF,uBAAYwF,mBAA3B,CAA3B;;AAEA,wBACOD,kBADP;AAEIL,iBAAS;AAAA,gBAAG1B,IAAH,SAAGA,IAAH;AAAA,mBAAc,mCAAwB,EAAEA,MAAMA,KAAKiC,IAAb,EAAxB,CAAd;AAAA,SAFb;AAGIL,gBAAQ;AAAA,mBACJG,mBAAmBH,MAAnB,CAA0BC,IAA1B,KAAmC,CAACT,2BAA2BS,KAAK7B,IAAL,CAAUiC,IAArC,CADhC;AAAA;AAHZ;AAMH,CATD;;AAWO,IAAMC,sEAA+B,SAA/BA,4BAA+B;AAAA,WAAO;AAC/CC,iBAAS,CAAC3F,uBAAY6E,eAAb,CADsC;AAE/Ce,gBAAQ,CACJ,8CADI,EAEJd,+BAFI,EAGJQ,6BAHI;AAFuC,KAAP;AAAA,CAArC,C;;;;;;;;;;;;;;;;;;;;;AC/BP;;AACA;;AAEO,IAAMO,sEAA+B,SAA/BA,4BAA+B,GAAM;AAC9C,QAAMC,sBAAsBd,oCAAehF,uBAAY+F,QAA3B,CAA5B;;AAEA,wBACOD,mBADP;AAEIZ,iBAAS,uBAAQ;AACb,gBAAIc,aAAaF,oBAAoBZ,OAApB,CAA4BG,IAA5B,CAAjB;;AAEA,gBAAIA,KAAK1B,MAAL,CAAYvC,IAAZ,KAAqBpB,uBAAYiG,eAAjC,IAAoDZ,KAAK1B,MAAL,CAAYuC,GAApE,EAAyE;AACrEF,0CACOA,UADP;AAEI1E,0BAAM+D,KAAK1B,MAAL,CAAYuC,GAAZ,CAAgB5E,IAAhB,GAAuB,IAAvB,GAA8B0E,WAAW1E;AAFnD;AAIH;;AAED,mBAAO0E,UAAP;AACH,SAbL;AAcIZ,gBAAQ;AAAA,mBACHU,oBAAoBV,MAApB,IAA8BU,oBAAoBV,MAApB,CAA2BC,IAA3B,CAA/B,IACAA,KAAK1B,MAAL,CAAYvC,IAAZ,KAAqBpB,uBAAY6E,eAF7B;AAAA;AAdZ;AAkBH,CArBM;;AAuBA,IAAMsB,gDAAoB,SAApBA,iBAAoB,GAAM;AACnC,WAAO;AACHR,iBAAS,EADN;AAEHC,gBAAQ,CAACC,8BAAD;AAFL,KAAP;AAIH,CALM,C;;;;;;;;;;;;;;;;;;;;;AC1BP;;AACA;;AACA;;AACA;;;;AAEO,IAAMhG,kDAAqB;AAC9BkG,cAAU,mCADoB;AAE9BK,2BAAuB,yDAFO;AAG9BC,WAAO,CAACrG,uBAAYsG,iBAAb,CAHuB;AAI9BC,YAAQ,CACJvG,uBAAYwG,kBADR,EAEJxG,uBAAYyG,gBAFR,EAGJzG,uBAAY0G,wBAHR,CAJsB;AAS9BC,YAAQ,CAAC3G,uBAAY4G,wBAAb,EAAuC5G,uBAAY6G,0BAAnD;AATsB,CAA3B;;AAYA,IAAMC,8EAAmC,SAAnCA,gCAAmC,QAAS;AACrD,QAAIC,gBAAgB,CAAC/G,uBAAYqB,OAAb,CAApB;AAAA,QACI2F,eAAe,EADnB;;AAGA,OAAGxC,MAAH,CAAU5B,KAAV,EAAiBuB,OAAjB,CAAyB,gBAAQ;AAC7B,YAAI,OAAOO,IAAP,KAAgB,QAApB,EAA8B;AAC1B,mBAAOqC,cAActC,IAAd,CAAmBC,IAAnB,CAAP;AACH;;AAED,YAAIuC,MAAMC,OAAN,CAAcxC,IAAd,CAAJ,EAAyB;AACrB,mBAAQqC,gBAAgBA,cAAcvC,MAAd,8BAAyBE,IAAzB,GAAxB;AACH;;AAED,YAAI,QAAOA,IAAP,yCAAOA,IAAP,OAAgB,QAApB,EAA8B;AAC1BqC,4BAAgBA,cAAcvC,MAAd,8BAA0BE,KAAKiB,OAAL,IAAgB,EAA1C,GAAhB;AACAqB,2BAAeA,aAAaxC,MAAb,8BAAyBE,KAAKkB,MAAL,IAAe,EAAxC,GAAf;AACH;AACJ,KAbD;;AAeA,WAAOpD,qCAAgByB,MAAhB,CAAuB;AAAA,eAAQ8C,cAAcI,OAAd,CAAsBzC,KAAKtD,IAA3B,MAAqC,CAAC,CAA9C;AAAA,KAAvB,EAAwEoD,MAAxE,CACHwC,YADG,CAAP;AAGH,CAtBM,C;;;;;;;;;;;;;;;;;;;;;ACjBP;;IAAYI,O;;AACZ;;AAEA;;AACA;;AACA;;AACA;;;;AAEA;;;;;;;;AAEO,IAAMC,0CAAiB,SAAjBA,cAAiB,CAAClH,IAAD,EAAuB;AAAA,QAAhBmH,MAAgB,uEAAP,EAAO;;AACjD,QAAItE,MAAM,EAAV;;AAEA,QAAI;AACAA,cAAMoE,QAAQG,KAAR,CAAcpH,IAAd,EAAoB,wCAAsBqH,yBAAtB,EAAwCF,MAAxC,CAApB,CAAN;AACH,KAFD,CAEE,OAAOnE,CAAP,EAAU;AACR,8BAAS,8BAA8BA,EAAEC,OAAzC,EAAkDD,EAAEsE,GAApD,EAAyDtE,EAAEE,KAA3D;AACA,cAAMF,CAAN;AACH;;AAED,WAAOH,GAAP;AACH,CAXM;;AAaA,IAAM0E,sCAAe,SAAfA,YAAe,OAAmCC,oBAAnC,EAA4D;AAAA,QAAzDpF,cAAyD,QAAzDA,cAAyD;AAAA,QAAzCE,YAAyC,QAAzCA,YAAyC;;AACpF,QAAMmF,UAAU,qCAAaD,oBAAb,CAAhB;AAAA,QACIE,qBAAqB,SAArBA,kBAAqB;AAAA,eAAS;AAAA,mBAAQC,MAAMzC,IAAN,EAAY5C,YAAZ,CAAR;AAAA,SAAT;AAAA,KADzB;;AAGA,WAAOF,eAAewF,MAAf,CAAsB,UAACC,GAAD,EAAMtD,IAAN,EAAe;AACxC,YAAI,CAACA,KAAKnD,IAAV,EAAgB;AACZyG,gBAAItD,KAAKtD,IAAT,IAAiBsD,KAAKuD,QAAL,GACX,EAAEC,MAAML,mBAAmBM,iBAAiBzD,IAAjB,EAAuBkD,OAAvB,CAAnB,CAAR,EADW,GAEXC,mBAAmBM,iBAAiBzD,IAAjB,EAAuBkD,OAAvB,CAAnB,CAFN;AAGH,SAJD,MAIO;AACHI,gBAAItD,KAAKtD,IAAT,IAAiB;AACbgH,uBAAOP,mBAAmBQ,kBAAkB3D,IAAlB,EAAwBkD,OAAxB,CAAnB,CADM;AAEbM,sBAAML,mBAAmBS,iBAAiB5D,IAAjB,EAAuBkD,OAAvB,CAAnB;AAFO,aAAjB;AAIH;;AAED,eAAOI,GAAP;AACH,KAbM,EAaJ,EAbI,CAAP;AAcH,CAlBM;;AAoBP;AACA,IAAMG,mBAAmB,SAAnBA,gBAAmB,CAACzD,IAAD,EAAOkD,OAAP;AAAA,WAAmB,UAACvC,IAAD,EAAO5C,YAAP,EAAwB;AAChE,YAAIiC,KAAKU,MAAL,IAAeV,KAAKU,MAAL,CAAYC,IAAZ,CAAnB,EAAsC;;AAEtC,YAAMkD,2BACCC,oBAAoB9D,IAApB,EAA0BW,IAA1B,CADD,CAAN;;AAIA,YAAI5C,gBAAgBA,aAAa8F,WAAb,CAApB,EAA+C;;AAE/CE,kBAAUb,OAAV,EAAmBW,WAAnB;AACH,KAVwB;AAAA,CAAzB;;AAYA,IAAMF,oBAAoB,SAApBA,iBAAoB,CAAC3D,IAAD,EAAOkD,OAAP;AAAA,WAAmB,UAACvC,IAAD,EAAO5C,YAAP,EAAwB;AACjE,YAAIiC,KAAKU,MAAL,IAAeV,KAAKU,MAAL,CAAYC,IAAZ,CAAnB,EAAsC;;AAEtC,YAAMkD,cAAcG,iBAAiBhE,IAAjB,EAAuBkD,OAAvB,EAAgCvC,IAAhC,EAAsC5C,YAAtC,CAApB;;AAEAmF,gBAAQe,MAAR,CAAeJ,WAAf;AACH,KANyB;AAAA,CAA1B;;AAQA,IAAMG,mBAAmB,SAAnBA,gBAAmB,CAAChE,IAAD,EAAOkD,OAAP,EAAgBvC,IAAhB,EAAsB5C,YAAtB,EAAuC;AAC5D,QAAM8F,2BACCC,oBAAoB9D,IAApB,EAA0BW,IAA1B,CADD;AAEF9D,cAAM;AAFJ,MAAN;;AAKA,QAAI,EAAEkB,gBAAgBA,aAAa8F,WAAb,CAAlB,CAAJ,EAAkD;AAC9CE,kBAAUb,OAAV,EAAmBW,WAAnB;AACH;;AAED,WAAOA,WAAP;AACH,CAXD;;AAaA,IAAME,YAAY,SAAZA,SAAY,CAACb,OAAD,EAAUgB,KAAV,EAAoB;AAClC,QAAMjF,SAASiE,QAAQiB,UAAR,EAAf;AACAD,UAAMjF,MAAN,GAAeA,MAAf;;AAEA,KAACA,OAAOpC,IAAP,IAAeoC,MAAhB,EAAwBc,IAAxB,CAA6BmE,KAA7B;AACH,CALD;;AAOA,IAAME,wBAAwB,SAAxBA,qBAAwB,OAAQ;AAClC,QAAMC,kBACF1D,KAAK2D,IAAL,CAAU;AAAA,eAAQ3D,KAAK4D,SAAL,KAAmBC,sBAAW7H,OAA9B,IAAyCgE,KAAK8D,kBAAL,EAAjD;AAAA,KAAV,KAAyF,EAD7F;AAEA,WAAOJ,gBAAgB7C,GAAvB;AACH,CAJD;;AAMA,IAAMoC,mBAAmB,SAAnBA,gBAAmB,CAAC5D,IAAD,EAAOkD,OAAP;AAAA,WAAmB,gBAAQ;AAChD,YAAIlD,KAAKU,MAAL,IAAeV,KAAKU,MAAL,CAAYC,IAAZ,CAAnB,EAAsC;;AAEtCuC,gBAAQwB,OAAR;AACH,KAJwB;AAAA,CAAzB;;AAMA,IAAMZ,sBAAsB,SAAtBA,mBAAsB,CAAC9D,IAAD,EAAOW,IAAP,EAAgB;AACxC,QAAM/D,OAAOoD,KAAKQ,OAAL,CAAaG,IAAb,CAAb;AAAA,QACIgE,cAAc,OAAO/H,IAAP,KAAgB,QAAhB,GAA2B,EAAEA,UAAF,EAA3B,GAAsCA,IADxD;;AAGA,QAAMgG,sBACC+B,WADD;AAEFjI,cAAMsD,KAAKtD,IAFT;AAGF8E,aAAK4C,sBAAsBzD,IAAtB,CAHH;AAIFiE,qBAAajE,KAAKa,GAAL,KAAagD,sBAAWK;AAJnC,MAAN;;AAOA,QAAI,CAACjC,OAAOhG,IAAZ,EAAkB;AACdgG,eAAOhG,IAAP,GAAc,EAAd;AACH;;AAED,QAAIoD,KAAKtD,IAAL,KAAciE,KAAK7B,IAAL,CAAUpC,IAA5B,EAAkC;AAC9BkG,eAAOkC,OAAP,GAAiBnE,KAAK7B,IAAL,CAAUpC,IAA3B;AACH;;AAED,WAAOkG,MAAP;AACH,CApBD,C;;;;;;;;;;;;;;;;;kBChGe;AACXmC,gBAAY,QADD;AAEXC,aAAS,CAAC,kBAAD,EAAqB,KAArB,EAA4B,YAA5B;AAFE,C;;;;;;;;;;;;;;;;;;;;ACAf;;;;AACA;;;;AAEO,IAAMC,kEAA6B,SAA7BA,0BAA6B;AAAA,QAAGnG,IAAH,QAAGA,IAAH;AAAA,WAAc,gBAAgB,8BAASA,KAAKoG,MAAd,EAAsBzJ,IAApD;AAAA,CAAnC;;AAEA,IAAM0J,4EAAkC,SAAlCA,+BAAkC;AAAA,QAAGrG,IAAH,SAAGA,IAAH;AAAA,sBAAuBsG,qBAAqBtG,IAArB,CAAvB;AAAA,CAAxC;;AAEA,IAAMuG,gFAAoC,SAApCA,iCAAoC;AAAA,QAAGvG,IAAH,SAAGA,IAAH;AAAA,+BAC3BsG,qBAAqBtG,IAArB,CAD2B;AAAA,CAA1C;;AAGP,IAAMsG,uBAAuB,SAAvBA,oBAAuB,OAAQ;AAAA,QACzBE,WADyB,GACG3E,IADH,CACzB2E,WADyB;AAAA,QACZC,UADY,GACG5E,IADH,CACZ4E,UADY;;;AAGjC,QAAID,WAAJ,EAAiB;AACb,eAAO,MAAME,sBAAsBF,WAAtB,CAAb;AACH;;AAED,QAAIC,UAAJ,EAAgB;AACZ,eAAO,EAAP;AACH;;AAED,WAAO,8BAASA,UAAT,EAAqB9J,IAA5B;AACH,CAZD;;AAcA,IAAM+J,wBAAwB,SAAxBA,qBAAwB,cAAe;AACzC,QACI,CAAClK,uBAAYmK,oBAAb,EAAmCnK,uBAAYoK,yBAA/C,EAA0EjD,OAA1E,CACI6C,YAAY5I,IADhB,MAEM,CAAC,CAHX,EAIE;AACE,eAAO4I,YAAYK,EAAZ,GAAiBL,YAAYK,EAAZ,CAAe/I,IAAhC,GAAuC,UAA9C;AACH;;AAED,QAAI0I,YAAY5I,IAAZ,KAAqBpB,uBAAYsK,oBAArC,EAA2D;AACvD,eAAON,YAAYO,YAAZ,CAAyB,CAAzB,EAA4BF,EAA5B,CAA+B/I,IAAtC;AACH;;AAED,QAAI0I,YAAY5I,IAAZ,KAAqBpB,uBAAYwK,UAArC,EAAiD;AAC7C,eAAOR,YAAY1I,IAAnB;AACH;;AAED,QAAI0I,YAAY5I,IAAZ,KAAqBpB,uBAAYiF,qBAArC,EAA4D;AACxD,eAAO+E,YAAYS,IAAZ,CAAiBnJ,IAAxB;AACH;AACJ,CApBD;;AAsBO,IAAMoJ,gEAA4B,SAA5BA,yBAA4B,QAAc;AAAA,QAAXlH,IAAW,SAAXA,IAAW;;AACnD,sBAAgB,8BAASA,KAAK6G,EAAd,EAAkBlK,IAAlC,UACIqD,KAAKmH,UAAL,iBAA8B,8BAASnH,KAAKmH,UAAd,EAA0BxK,IAAxD,GAAiE,EADrE;AAGH,CAJM;;AAMA,IAAMyK,0DAAyB,SAAzBA,sBAAyB;AAAA,WAAM,OAAN;AAAA,CAA/B;;AAEA,IAAMC,wDAAwB,SAAxBA,qBAAwB;AAAA,WAAM,OAAN;AAAA,CAA9B,C;;;;;;;;;;;;;;;;;;;ACtDP;;;;AACA;;;;AAEO,IAAMC,wCAAgB,SAAhBA,aAAgB,OAAQ;AACjC,WAAO,8BAASzF,KAAK7B,IAAd,EAAoBrD,IAA3B;AACH,CAFM;;AAIA,IAAM4K,oDAAsB,SAAtBA,mBAAsB,OAAQ;AACvC,QAAI1F,KAAK1B,MAAL,CAAYvC,IAAZ,KAAqBpB,uBAAYgL,eAArC,EAAsD;AAClD,eAAO,QAAQF,cAAczF,IAAd,CAAf;AACH;;AAED,WAAOyF,cAAczF,IAAd,CAAP;AACH,CANM;;AAQP;AACO,IAAM4F,gDAAoB,SAApBA,iBAAoB,OAAQ;AACrC,QAAMzH,OAAO6B,KAAK7B,IAAlB;AAAA,QACI0H,aAAaC,0BAA0B3H,KAAK4H,MAA/B,CADjB;;AAGA,QAAI9J,OAAO,EAAX;;AAEA,QAAIkC,KAAK6G,EAAT,EAAa;AACT/I,eAAO+J,yBAAyBhG,IAAzB,IAAiC,WAAjC,GAA+C7B,KAAK6G,EAAL,CAAQ/I,IAAvD,GAA8D4J,UAArE;AACH,KAFD,MAEO,IAAI1H,KAAKpC,IAAL,KAAcpB,uBAAYoK,yBAA9B,EAAyD;AAC5D9I,eAAO+J,yBAAyBhG,IAAzB,IAAiC6F,UAAjC,GAA8C,KAArD;AACH,KAFM,MAEA,IAAI1H,KAAKpC,IAAL,KAAcpB,uBAAYsL,YAA1B,IAA0C9H,KAAKpC,IAAL,KAAcpB,uBAAYuL,aAAxE,EAAuF;AAC1FjK,eACIkC,KAAKgI,IAAL,KAAcC,gCAAqBC,WAAnC,GACM,gBAAgBR,UADtB,GAEM1H,KAAK0C,GAAL,CAAS5E,IAAT,GAAgB4J,UAH1B;AAIH,KALM,MAKA;AACH5J,eAAO+J,yBAAyBhG,IAAzB,IAAiC,UAAjC,GAA8C6F,UAArD;AACH;;AAED,WAAO,EAAE5J,UAAF,EAAQqK,gBAAgBtG,KAAK1B,MAAL,CAAYvC,IAApC,EAAP;AACH,CApBM;;AAsBA,IAAMiK,8DAA2B,SAA3BA,wBAA2B,OAAQ;AAC5C,QAAM1H,SAAS0B,KAAK1B,MAApB;;AAEA,QACI,CAACA,MAAD,IACCA,OAAOvC,IAAP,KAAgBpB,uBAAYwF,mBAA5B,IACG7B,OAAOvC,IAAP,KAAgBpB,uBAAYiF,qBAD/B,IAEGtB,OAAOvC,IAAP,KAAgBpB,uBAAYiG,eAJpC,EAKE;AACE,eAAO,EAAP;AACH;;AAED,QAAItC,OAAO8G,IAAX,EAAiB;AACb,eAAO,8BAAS9G,OAAO8G,IAAhB,EAAsBtK,IAAtB,GAA6B,KAApC;AACH;;AAED,QAAMyL,WAAWjI,OAAO0G,EAAxB;AACA,WAAOuB,WAAWA,SAAStK,IAAT,GAAgB,KAA3B,GAAmC,EAA1C;AACH,CAlBM;;AAoBA,IAAM6J,gEAA4B,SAA5BA,yBAA4B,SAAU;AAC/C,iBAAWC,OACNS,GADM,CACF,aAAK;AACN,YAAIC,EAAExK,IAAN,EAAY;AACR,mBAAOwK,EAAExK,IAAT;AACH;;AAED,eAAO,8BAASwK,CAAT,EAAY3L,IAAnB;AACH,KAPM,EAQN4L,IARM,CAQD,IARC,CAAX;AASH,CAVM;;AAYA,IAAMC,4CAAkB,SAAlBA,eAAkB,OAAQ;AACnC,QAAMxI,OAAO6B,KAAK7B,IAAlB;AACA,QACIA,KAAKyI,QAAL,KACC,CAACjM,uBAAYkM,sBAAb,EAAqClM,uBAAYmM,iBAAjD,EAAoE9H,QAApE,CACGb,KAAKyI,QAAL,CAAc7K,IADjB,KAGGgL,eAAe5I,KAAKyI,QAAL,CAAc7K,IAA7B,CAJJ,CADJ,EAME;AACE,eAAO,QAAP;AACH;;AAED,WAAOiE,KAAK7B,IAAL,CAAUyI,QAAV,eAA+B,8BAAS5G,KAAK7B,IAAL,CAAUyI,QAAnB,EAA6B9L,IAA5D,GAAqE,QAA5E;AACH,CAbM;AAcP;;AAEA;AACO,IAAMkM,wCAAgB,SAAhBA,aAAgB,OAAc;AAAA,QAAX7I,IAAW,QAAXA,IAAW;;AACvC,QAAIA,KAAK3B,IAAT,EAAe;AACX,eAAO,8BAAS2B,KAAK3B,IAAd,EAAoB1B,IAA3B;AACH;;AAED,QAAIqD,KAAKiH,IAAL,IAAajH,KAAK2B,KAAtB,EAA6B;AACzB,YAAMmH,YAAY9I,KAAKpC,IAAL,KAAcpB,uBAAYuM,gBAA1B,GAA6C,IAA7C,GAAoD,IAAtE;AACA,YAAMC,WACFhJ,KAAKiH,IAAL,CAAUrJ,IAAV,KAAmBpB,uBAAYsK,oBAA/B,GACMmC,wBAAwBjJ,KAAKiH,IAAL,CAAUF,YAAlC,CADN,GAEM,8BAAS/G,KAAKiH,IAAd,EAAoBtK,IAH9B;;AAKA,eAAUqM,QAAV,SAAsBF,SAAtB,SAAmC,8BAAS9I,KAAK2B,KAAd,EAAqBhF,IAAxD;AACH;AACJ,CAdM;;AAgBA,IAAMuM,gDAAoB,SAApBA,iBAAoB,OAAQ;AACrC,WAAOrH,KAAK7B,IAAL,CAAUmJ,KAAV,iBAA8B,8BAAStH,KAAK7B,IAAL,CAAUmJ,KAAnB,EAA0BxM,IAAxD,GAAiE,UAAxE;AACH,CAFM;AAGP;;AAEO,IAAMyM,sDAAuB,SAAvBA,oBAAuB,OAAQ;AACxC,iBAAW,8BAASvH,KAAK7B,IAAL,CAAU3B,IAAnB,EAAyB1B,IAApC;AACH,CAFM;;AAIP;AACO,IAAM0M,sCAAe,SAAfA,YAAe,OAAQ;AAChC;AACH,CAFM;;AAIA,IAAMC,0CAAiB,SAAjBA,cAAiB,OAAQ;AAClC,WAAOzH,KAAK7B,IAAL,CAAUuJ,KAAV,eAA4B,8BAAS1H,KAAK7B,IAAL,CAAUuJ,KAAnB,EAA0B5M,IAAtD,SAAgE,kBAAvE;AACH,CAFM;;AAIA,IAAM6M,8CAAmB,SAAnBA,gBAAmB,OAAQ;AACpC;AACA;AACA;;AAEA,WAAO,oBAAP;AACH,CANM;AAOP;;AAEA;AACO,IAAMC,8DAA2B,SAA3BA,wBAA2B,OAAQ;AAC5C,wBAAkB,8BAAS5H,KAAK7B,IAAL,CAAU0J,YAAnB,EAAiC/M,IAAnD;AACH,CAFM;;AAIA,IAAMgN,wCAAgB,SAAhBA,aAAgB,OAAQ;AACjC,WAAO9H,KAAK7B,IAAL,CAAU3B,IAAV,aAAyB,8BAASwD,KAAK7B,IAAL,CAAU3B,IAAnB,EAAyB1B,IAAlD,SAA4D,UAAnE;AACH,CAFM;;AAIA,IAAMiN,0CAAiB,SAAjBA,cAAiB,OAAQ;AAClC,WAAO/H,KAAK7B,IAAL,CAAUmJ,KAAV,cAA2B,8BAAStH,KAAK7B,IAAL,CAAUmJ,KAAnB,EAA0BxM,IAArD,SAA+D,OAAtE;AACH,CAFM;AAGP;;AAEO,IAAMkN,0DAAyB,SAAzBA,sBAAyB,OAAQ;AAC1C,sBAAgB,8BAAShI,KAAK7B,IAAL,CAAU8J,MAAnB,EAA2BnN,IAA3C;AACH,CAFM;;AAIA,IAAMoN,8CAAmB,SAAnBA,gBAAmB,OAAQ;AACpC,WAAUlI,KAAK7B,IAAL,CAAUpC,IAApB,iBAAoCiE,KAAK7B,IAAL,CAAUiG,UAA9C;AACH,CAFM;;AAIA,IAAM+D,4DAA0B,SAA1BA,uBAA0B,OAAQ;AAC3C,sBAAgB,8BAASnI,KAAK7B,IAAL,CAAUyI,QAAnB,EAA6B9L,IAA7C;AACH,CAFM;;AAIA,IAAMsN,gDAAoB,SAApBA,iBAAoB,OAAQ;AACrC;AACH,CAFM;;AAIA,IAAMhB,4DAA0B,SAA1BA,uBAA0B;AAAA,WACnCiB,UAAU7B,GAAV,CAAc;AAAA,eAAK8B,4BAA4B,EAAEnK,MAAMoK,CAAR,EAA5B,CAAL;AAAA,KAAd,EAA6D7B,IAA7D,CAAkE,IAAlE,CADmC;AAAA,CAAhC;;AAGA,IAAM4B,oEAA8B,SAA9BA,2BAA8B,OAAQ;AAC/C,QAAMnK,OAAO6B,KAAK7B,IAAlB;AAAA,QACIqK,aAAcxI,KAAK1B,MAAL,IAAe0B,KAAK1B,MAAL,CAAY6H,IAA5B,IAAqC,EADtD;;AAGA,QACIhI,KAAKiC,IAAL,KACCqI,mBAAmBtK,KAAKiC,IAAxB,KAAiCjC,KAAKiC,IAAL,CAAUrE,IAAV,KAAmBpB,uBAAYkM,sBADjE,CADJ,EAGE;AACE,eAAU2B,UAAV,SAAwBrK,KAAK6G,EAAL,CAAQ/I,IAAhC;AACH;;AAED,QAAIyM,eAAe,EAAnB;AACA,QAAIvK,KAAK6G,EAAL,CAAQjJ,IAAR,KAAiBpB,uBAAYgO,cAAjC,EAAiD;AAC7CD,uBAAe,OAAf;AACH,KAFD,MAEO,IAAIvK,KAAK6G,EAAL,CAAQjJ,IAAR,KAAiBpB,uBAAYiO,aAAjC,EAAgD;AACnDF,uBAAe,OAAf;AACH,KAFM,MAEA;AACHA,uBAAevK,KAAK6G,EAAL,CAAQ/I,IAAvB;AACH;;AAED,QACIkC,KAAKiC,IAAL,IACA,CAACzF,uBAAY6E,eAAb,EAA8B7E,uBAAYkO,cAA1C,EAA0D7J,QAA1D,CAAmEb,KAAKiC,IAAL,CAAUrE,IAA7E,CAFJ,EAGE;AACE,eAAUyM,UAAH,SAAiBE,YAAjB,WAAqCI,wBAAwB,EAAE3K,MAAMA,KAAKiC,IAAb,EAAxB,CAA5C;AACH;;AAED,QAAIjC,KAAKiC,IAAL,IAAajC,KAAKiC,IAAL,CAAUrE,IAAV,KAAmBpB,uBAAYmM,iBAAhD,EAAmE;AAC/D,eAAU0B,UAAV,SAAwBE,YAAxB,WAA0CK,2BAA1C;AACH;;AAED,QAAI5K,KAAK6G,EAAL,IAAW7G,KAAK6G,EAAL,CAAQjJ,IAAR,KAAiBpB,uBAAYgO,cAA5C,EAA4D;AACxD,eAAUH,UAAV,iBAAgCrK,KAAKiC,IAAL,CAAUnE,IAA1C;AACH;;AAED,QAAIkC,KAAK6G,EAAL,IAAW7G,KAAK6G,EAAL,CAAQjJ,IAAR,KAAiBpB,uBAAYiO,aAA5C,EAA2D;AACvD,eAAUJ,UAAV,iBAAgCrK,KAAKiC,IAAL,CAAUnE,IAA1C;AACH;;AAED,WAAOuM,aAAa,GAAb,GAAmB,8BAASrK,IAAT,EAAerD,IAAzC;AACH,CAxCM;;AA0CA,IAAMkO,wEAAgC,SAAhCA,6BAAgC,QAAc;AAAA,QAAX7K,IAAW,SAAXA,IAAW;;AACvD,QAAIsK,mBAAmBtK,KAAK2B,KAAxB,KAAkC3B,KAAK2B,KAAL,CAAW/D,IAAX,KAAoBpB,uBAAYkM,sBAAtE,EAA8F;AAC1F,eAAUoC,sBAAsB9K,KAAKiH,IAA3B,CAAV,SAA8CjH,KAAK+K,QAAnD;AACH;;AAED,QAAI/K,KAAK2B,KAAL,CAAW/D,IAAX,KAAoBpB,uBAAYmM,iBAApC,EAAuD;AACnD,eAAUmC,sBAAsB9K,KAAKiH,IAA3B,CAAV,SACIjH,KAAK+K,QADT,SAEIH,2BAFJ;AAGH;;AAED,QAAI,CAACpO,uBAAY6E,eAAb,EAA8B7E,uBAAYkO,cAA1C,EAA0D7J,QAA1D,CAAmEb,KAAK2B,KAAL,CAAW/D,IAA9E,CAAJ,EAAyF;AACrF,eAAUkN,sBAAsB9K,KAAKiH,IAA3B,CAAV,SAA8CjH,KAAK+K,QAAnD,SAA+DJ,wBAAwB;AACnF3K,kBAAMA,KAAK2B;AADwE,SAAxB,CAA/D;AAGH;;AAED,WAAO,8BAAS3B,IAAT,EAAerD,IAAtB;AACH,CAlBM;;AAoBP,IAAMmO,wBAAwB,SAAxBA,qBAAwB,OAAQ;AAClC,QAAI9K,KAAKlC,IAAT,EAAe;AACX,eAAOkC,KAAKlC,IAAZ;AACH;;AAED,WAAO,8BAASkC,IAAT,EAAerD,IAAtB;AACH,CAND;;AAQO,IAAMgO,4DAA0B,SAA1BA,uBAA0B,QAAc;AAAA,QAAX3K,IAAW,SAAXA,IAAW;;AACjD,QAAIgL,gBAAgB,EAApB;;AAEA,QAAIhL,KAAKiL,SAAL,IAAkBjL,KAAKiL,SAAL,CAAetN,MAArC,EAA6C;AACzCqN,wBAAgBhL,KAAKiL,SAAL,CAAe5C,GAAf,CAAmB6C,eAAnB,EAAoC3C,IAApC,CAAyC,IAAzC,CAAhB;AACH;;AAED,QAAM4C,SAASnL,KAAKmL,MAApB;AACA,QACIA,OAAOvN,IAAP,KAAgBpB,uBAAY4O,iBAA5B,IACAD,OAAOrB,MAAP,CAAclM,IAAd,KAAuBpB,uBAAY6E,eAFvC,EAGE;AACE,eAAO,EAAEvD,YAAUqN,OAAOE,QAAP,CAAgBvN,IAA1B,SAAkCkN,aAAlC,MAAF,EAAsDM,OAAO,IAA7D,EAAP;AACH,KALD,MAKO,IAAIN,aAAJ,EAAmB;AACtB,eAAU,8BAAShL,KAAKmL,MAAd,EAAsBxO,IAAhC,SAAwCqO,aAAxC;AACH;;AAED,WAAO,8BAAShL,IAAT,EAAerD,IAAtB;AACH,CAlBM;;AAoBP,IAAMuO,kBAAkB,SAAlBA,eAAkB,WAAY;AAChC,QAAIZ,mBAAmB7B,QAAnB,CAAJ,EAAkC,OAAO,KAAP;AAClC,QAAIA,SAAS7K,IAAT,KAAkBpB,uBAAYmM,iBAAlC,EAAqD,OAAOiC,2BAAP;;AAErD,QAAInC,SAAS3K,IAAb,EAAmB,OAAO2K,SAAS3K,IAAhB;AACnB,QAAI2K,SAAS8C,KAAb,EACI,OAAO9C,SAAS7K,IAAT,KAAkBpB,uBAAYgP,cAA9B,UACG/C,SAAS8C,KADZ,UAED9C,SAAS8C,KAFf;;AAIJ,WAAO,8BAAS9C,QAAT,EAAmB9L,IAA1B;AACH,CAXD;;AAaO,IAAMiO,gEAA4B,SAA5BA,yBAA4B,OAAQ;AAC7C,QAAM9M,OAAO,KAAb;AACA,QAAI+D,IAAJ,EAAU,OAAO,EAAE/D,UAAF,EAAQqK,gBAAgBtG,KAAK1B,MAAL,CAAYvC,IAApC,EAAP;;AAEV,WAAOE,IAAP;AACH,CALM;;AAOA,IAAM2N,4DAA0B,SAA1BA,uBAA0B,OAAQ;AAC3C,QAAMzL,OAAO6B,KAAK7B,IAAlB;;AAEA,QAAIA,KAAKuL,KAAL,IAAc3C,eAAe5I,KAAKuL,KAAL,CAAW3N,IAA1B,CAAlB,EAAmD;AAC/C,eAAOoC,KAAK0C,GAAL,CAAS5E,IAAT,GAAgB,IAAvB;AACH;;AAED,QAAIkC,KAAKuL,KAAL,IAAcvL,KAAKuL,KAAL,CAAW3N,IAAX,KAAoBpB,uBAAYmM,iBAAlD,EAAqE;AACjE,eAAO3I,KAAK0C,GAAL,CAAS5E,IAAT,GAAgB,IAAhB,GAAuB8M,2BAA9B;AACH;;AAED,WAAO,8BAAS5K,IAAT,EAAerD,IAAtB;AACH,CAZM;;AAcP,IAAM+O,iBAAiB,SAAjBA,cAAiB,SAAU;AAC7B,QAAI,CAACP,MAAL,EAAa,OAAOA,MAAP;AACb,QACIA,OAAOvN,IAAP,KAAgBpB,uBAAY4O,iBAA5B,IACAD,OAAOrB,MAAP,CAAclM,IAAd,KAAuBpB,uBAAY6E,eAFvC,EAGE;AACE,eAAOqK,eAAeP,OAAOrB,MAAtB,CAAP;AACH;;AAED,WAAOqB,MAAP;AACH,CAVD;;AAYO,IAAMvC,0CAAiB,SAAjBA,cAAiB,OAAQ;AAClC,WAAO,CACHpM,uBAAYmP,mBADT,EAEHnP,uBAAY+F,QAFT,EAGH/F,uBAAYoK,yBAHT,EAIHpK,uBAAYmK,oBAJT,EAKL9F,QALK,CAKIjD,IALJ,CAAP;AAMH,CAPM;;AASA,IAAM0M,kDAAqB,SAArBA,kBAAqB,OAAQ;AACtC,QAAMsB,YAAY,CAACpP,uBAAYoK,yBAAb,EAAwCpK,uBAAYmP,mBAApD,CAAlB;;AAEA,WAAO3L,QAAQ4L,UAAUjI,OAAV,CAAkB3D,KAAKpC,IAAvB,MAAiC,CAAC,CAAjD;AACH,CAJM,C;;;;;;;;;;;;;;;;;;;;;ACpTP;;AACA;;AAyBA;;;;AASA,IAAMiO,mBAAmB,SAAnBA,gBAAmB,OAAQ;AAC7B,QAAMtG,kBAAkB1D,KAAKiK,kBAAL,EAAxB;AAAA,QACI3L,SAAS0B,KAAK1B,MAAL,IAAe,EAD5B;;AAGA,QAAI,CAACuF,sBAAWqG,UAAZ,EAAwBrG,sBAAWsG,SAAnC,EAA8CnL,QAA9C,CAAuDgB,KAAKa,GAA5D,CAAJ,EAAsE;AAClE,eAAO,KAAP;AACH;;AAED,WACI,CAAC,QAAD,EAAW7B,QAAX,CAAoBgB,KAAKoK,OAAzB,KACC1G,gBAAgB2G,iBAAhB,MAAuCrK,KAAKa,GAAL,KAAa,MADrD,IAEC,CAAC6C,gBAAgB4G,MAAhB,MACE5G,gBAAgB6G,aAAhB,EADF,IAEEjM,OAAOvC,IAAP,KAAgBpB,uBAAYkM,sBAF/B,KAGG,CAAC,MAAD,EAAS,MAAT,EAAiB,OAAjB,EAA0B7H,QAA1B,CAAmCgB,KAAK4D,SAAxC,CALJ,IAMC,CACGjJ,uBAAY6P,MADf,EAEG7P,uBAAY6E,eAFf,EAGG7E,uBAAY8P,iBAHf,EAIG9P,uBAAY+P,iBAJf,EAKG/P,uBAAYiF,qBALf,EAMGjF,uBAAYgQ,kBANf,EAOGhQ,uBAAYwF,mBAPf,EAQGxF,uBAAY4O,iBARf,EASG5O,uBAAYkO,cATf,EAUGlO,uBAAYmK,oBAVf,EAWGnK,uBAAYmP,mBAXf,EAYGnP,uBAAYoK,yBAZf,EAaGpK,uBAAY+F,QAbf,EAcG/F,uBAAYiG,eAdf,EAeGjG,uBAAYiQ,kBAff,EAgBGjQ,uBAAYkQ,aAhBf,EAiBGlQ,uBAAYmQ,cAjBf,EAkBGnQ,uBAAYoQ,gBAlBf,EAmBGpQ,uBAAYqQ,gBAnBf,EAoBGrQ,uBAAY0G,wBApBf,EAqBG1G,uBAAYyG,gBArBf,EAsBGzG,uBAAYwG,kBAtBf,EAuBGxG,uBAAY6G,0BAvBf,EAwBG7G,uBAAY4G,wBAxBf,EAyBG5G,uBAAYsG,iBAzBf,EA0BGtG,uBAAYsL,YA1Bf,EA2BGtL,uBAAYsQ,gBA3Bf,EA4BGtQ,uBAAYuQ,WA5Bf,EA6BClM,QA7BD,CA6BUV,OAAOvC,IA7BjB,MA8BI,CAACuC,OAAOpC,IAAR,IAAgBoC,OAAOpC,IAAP,CAAYH,IAAZ,KAAqBiE,KAAK7B,IAAL,CAAUpC,IA9BnD,CAPL;AAuCH,CA/CD;;AAiDO,IAAM4D,kGACRhF,uBAAY+F,QADJ,EACe;AACpB3E,UAAMpB,uBAAY+F,QADE;AAEpBb,aAAS+F,uBAFW;AAGpB1J,UAAM;AAHc,CADf,oCAMRvB,uBAAY6P,MANJ,EAMa;AAClBzO,UAAMpB,uBAAY6P,MADA;AAElB3K,aAAS8G,qBAFS;;AAIlBzK,UAAM;AAJY,CANb,oCAYRvB,uBAAYwF,mBAZJ,EAY0B;AAC/BpE,UAAMpB,uBAAYwF,mBADa;AAE/BjE,UAAM,IAFyB;AAG/B2D,aAASyI,iCAHsB;AAI/BvI,YAAQ,sBAAQ;AACZ,YAAM2D,kBAAkB1D,KAAKiK,kBAAL,EAAxB;AACA,eACI,CAACjK,KAAK7B,IAAL,CAAUiC,IAAX,IAAmB,8BAAmBJ,KAAK7B,IAAL,CAAUiC,IAA7B,CAAnB,IAAyDsD,gBAAgB4G,MAAhB,EAD7D;AAGH;AAT8B,CAZ1B,oCAuBR3P,uBAAYiF,qBAvBJ,EAuB4B;AACjC7D,UAAMpB,uBAAYiF,qBADe;AAEjC1D,UAAM,IAF2B;AAGjC2D,aAASmJ,mCAHwB;AAIjCjJ,YAAQ,sBAAQ;AACZ,YAAM2D,kBAAkB1D,KAAKiK,kBAAL,EAAxB;;AAEA,eACIvG,gBAAgByH,qBAAhB,MACAnL,KAAK1B,MAAL,CAAYvC,IAAZ,KAAqBpB,uBAAYgQ,kBADjC,IAECjH,gBAAgB6G,aAAhB,MAAmCvK,KAAKa,GAAL,KAAagD,sBAAWuH,IAF5D,IAGA,8BAAmBpL,KAAK7B,IAAL,CAAU2B,KAA7B,CAJJ;AAMH;AAbgC,CAvB5B,oCAsCRnF,uBAAY6E,eAtCJ,EAsCsB;AAC3BzD,UAAMpB,uBAAY6E,eADS;AAE3BtD,UAAM,KAFqB;AAG3B0G,cAAU,IAHiB;AAI3B/C,aAASiJ,6BAJkB;AAK3B/I,YAAQ,sBAAQ;AACZ,YAAM2D,kBAAkB1D,KAAKiK,kBAAL,EAAxB;AAAA,YACI3L,SAAS0B,KAAK1B,MAAL,IAAe,EAD5B;;AAGA,YAAIA,OAAOvC,IAAP,KAAgBpB,uBAAYoK,yBAAhC,EAA2D,OAAO,KAAP;;AAE3D,eACIrB,gBAAgByH,qBAAhB,MACA,CACIxQ,uBAAY6P,MADhB,EAEI7P,uBAAY6E,eAFhB,EAGI7E,uBAAYkO,cAHhB,EAIIlO,uBAAYqQ,gBAJhB,EAKIrQ,uBAAY8P,iBALhB,EAMEzL,QANF,CAMWV,OAAOvC,IANlB,CADA,IAQC2H,gBAAgB6G,aAAhB,MACGjM,OAAO9B,IADV,IAEG8B,OAAO9B,IAAP,CAAYT,IAAZ,KAAqBpB,uBAAY6E,eAVrC,IAWAQ,KAAK1B,MAAL,CAAYvC,IAAZ,KAAqBpB,uBAAYiF,qBAZrC,CAY2D;AAZ3D;AAcH;AAzB0B,CAtCtB,oCAiERjF,uBAAY+P,iBAjEJ,EAiEwB;AAC7B3O,UAAMpB,uBAAY+P,iBADW;AAE7B7K,aAAS4F,mBAFoB;AAG7B1F,YAAQ;AAAA,eAAQC,KAAKiK,kBAAL,GAA0BkB,qBAA1B,EAAR;AAAA;AAHqB,CAjExB,oCAsERxQ,uBAAYkO,cAtEJ,EAsEqB;AAC1B9M,UAAMpB,uBAAYkO,cADQ;AAE1BhJ,aAAS4F,mBAFiB;AAG1B1F,YAAQ;AAAA,eACJC,KAAKiK,kBAAL,GAA0BkB,qBAA1B,MACAnL,KAAK1B,MAAL,CAAYvC,IAAZ,KAAqBpB,uBAAYiF,qBADjC,IAEAI,KAAK1B,MAAL,CAAYvC,IAAZ,KAAqBpB,uBAAY0Q,eAH7B;AAAA;AAHkB,CAtErB,oCA8ER1Q,uBAAY2Q,IA9EJ,EA8EW;AAChBvP,UAAMpB,uBAAY2Q,IADF;AAEhBzL,aAASmH,mBAFO;AAGhB9K,UAAM;AAHU,CA9EX,oCAmFRvB,uBAAY4Q,QAnFJ,EAmFe;AACpBxP,UAAMpB,uBAAY4Q,QADE;AAEpB1L,aAASwH,uBAFW;AAGpBnL,UAAM;AAHc,CAnFf,oCAwFRvB,uBAAY6Q,WAxFJ,EAwFkB;AACvBzP,UAAMpB,uBAAY6Q,WADK;AAEvB3L,aAAS0H,0BAFc;AAGvBrL,UAAM;AAHiB,CAxFlB,oCA6FRvB,uBAAYsQ,gBA7FJ,EA6FuB;AAC5BlP,UAAMpB,uBAAYsQ,gBADU;AAE5BpL,aAAS+H,8BAFmB;AAG5B1L,UAAM;AAHsB,CA7FvB,oCAkGRvB,uBAAYuQ,WAlGJ,EAkGkB;AACvBnP,UAAMpB,uBAAYuQ,WADK;AAEvBrL,aAASiI,mBAFc;AAGvB5L,UAAM;AAHiB,CAlGlB,oCAuGRvB,uBAAY8Q,KAvGJ,EAuGY;AACjB1P,UAAMpB,uBAAY8Q,KADD;AAEjB5L,aAASkI,oBAFQ;AAGjB7L,UAAM;AAHW,CAvGZ,oCA4GRvB,uBAAY+Q,aA5GJ,EA4GoB;AACzB3P,UAAMpB,uBAAY+Q,aADO;AAEzB7L,aAAS2H,kBAFgB;AAGzBtL,UAAM;AAHmB,CA5GpB,oCAiHRvB,uBAAYgR,YAjHJ,EAiHmB;AACxB5P,UAAMpB,uBAAYgR,YADM;AAExB9L,aAAS4H,oBAFe;AAGxBvL,UAAM;AAHkB,CAjHnB,oCAsHRvB,uBAAYiR,cAtHJ,EAsHqB;AAC1B7P,UAAMpB,uBAAYiR,cADQ,EACQ;AAClC/L,aAASmI,4BAFiB;AAG1B9L,UAAM;AAHoB,CAtHrB,oCA2HRvB,uBAAYqB,OA3HJ,EA2Hc;AACnBD,UAAMpB,uBAAYqB,OADC,EACQ;AAC3B6D,aAASqI,sBAFU;AAGnBhM,UAAM;AAHa,CA3Hd,oCAgIRvB,uBAAY0Q,eAhIJ,EAgIsB;AAC3BtP,UAAMpB,uBAAY0Q,eADS;AAE3BxL,aAASsI,6BAFkB;AAG3BjM,UAAM;AAHqB,CAhItB,oCAqIRvB,uBAAYkR,kBArIJ,EAqIyB;AAC9B9P,UAAMpB,uBAAYkR,kBADY;AAE9BhM,aAASuI,uBAFqB;AAG9BlM,UAAM;AAHwB,CArIzB,oCA0IRvB,uBAAY8P,iBA1IJ,EA0IwB;AAC7B1O,UAAMpB,uBAAY8P,iBADW;AAE7B5K,aAAS4F,mBAFoB;AAG7B1F,YAAQiK;AAHqB,CA1IxB,oCA+IRrP,uBAAYwK,UA/IJ,EA+IiB;AACtBpJ,UAAMpB,uBAAYwK,UADI;AAEtBtF,aAAS6F,yBAFa;AAGtB3F,YAAQiK;AAHc,CA/IjB,oCAoJRrP,uBAAYgP,cApJJ,EAoJqB;AAC1B5N,UAAMpB,uBAAYgP,cADQ;AAE1B9J,aAAS4F,mBAFiB;AAG1B1F,YAAQiK;AAHkB,CApJrB,oCAyJRrP,uBAAYmR,eAzJJ,EAyJsB;AAC3B/P,UAAMpB,uBAAYmR,eADS;AAE3BjM,aAAS4F,mBAFkB;AAG3B1F,YAAQiK;AAHmB,CAzJtB,oCA8JRrP,uBAAYmM,iBA9JJ,EA8JwB;AAC7B/K,UAAMpB,uBAAYmM,iBADW;AAE7BjH,aAASkJ,+BAFoB;AAG7BhJ,YAAQ,sBAAQ;AACZ,YAAM5B,OAAO6B,KAAK7B,IAAlB;AACA,YAAIA,KAAK4N,UAAL,IAAmB,CAAC5N,KAAK4N,UAAL,CAAgBjQ,MAAxC,EAAgD;AAC5C,mBAAO,IAAP;AACH;;AAED,eAAO,CACHnB,uBAAYiG,eADT,EAEHjG,uBAAYiF,qBAFT,EAGHjF,uBAAYwF,mBAHT,EAILnB,QAJK,CAIIgB,KAAK1B,MAAL,CAAYvC,IAJhB,CAAP;AAKH,KAd4B;AAe7BG,UAAM;AAfuB,CA9JxB,oCA+KRvB,uBAAYiG,eA/KJ,EA+KsB;AAC3B7E,UAAMpB,uBAAYiG,eADS;AAE3Bf,aAAS+J,6BAFkB;AAG3B7J,YAAQ,sBAAQ;AACZ,YAAMiM,aAAahM,KAAKgM,UAAxB;AACA,eAAO,CAAC,QAAD,EAAW,MAAX,EAAmBhN,QAAnB,CAA4BgN,WAAWpI,SAAvC,CAAP;AACH,KAN0B;AAO3B1H,UAAM;AAPqB,CA/KtB,oCA0LRvB,uBAAYwG,kBA1LJ,EA0LyB;AAC9BpF,UAAMpB,uBAAYwG,kBADY;AAE9BtB,aAASyE,mCAFqB;AAG9BpI,UAAM;AAHwB,CA1LzB,oCA+LRvB,uBAAY0G,wBA/LJ,EA+L+B;AACpCtF,UAAMpB,uBAAY0G,wBADkB;AAEpCxB,aAAS4F;AAF2B,CA/L/B,oCAmMR9K,uBAAYyG,gBAnMJ,EAmMuB;AAC5BrF,UAAMpB,uBAAYyG,gBADU;AAE5BvB,aAAS4F;AAFmB,CAnMvB,oCAuMR9K,uBAAY6G,0BAvMJ,EAuMiC;AACtCzF,UAAMpB,uBAAY6G,0BADoB;AAEtC3B,aAAS6E,0CAF6B;AAGtCxI,UAAM;AAHgC,CAvMjC,oCA4MRvB,uBAAY4G,wBA5MJ,EA4M+B;AACpCxF,UAAMpB,uBAAY4G,wBADkB;AAEpC1B,aAAS2E,wCAF2B;AAGpCtI,UAAM;AAH8B,CA5M/B,oCAiNRvB,uBAAYsG,iBAjNJ,EAiNwB;AAC7BlF,UAAMpB,uBAAYsG,iBADW;AAE7BpB,aAASwF,kCAFoB;AAG7BnJ,UAAM;AAHuB,CAjNxB,oCAsNRvB,uBAAYgO,cAtNJ,EAsNqB;AAC1B5M,UAAMpB,uBAAYgO,cADQ;AAE1B9I,aAAS0F,+BAFiB;AAG1BxF,YAAQ,sBAAQ;AACZ,eACIC,KAAKoK,OAAL,KAAiB,QAAjB,IACA,CAACzP,uBAAYwF,mBAAb,EAAkCxF,uBAAYiQ,kBAA9C,EAAkE5L,QAAlE,CACIgB,KAAK1B,MAAL,CAAYvC,IADhB,CAFJ;AAMH,KAVyB;AAW1BG,UAAM;AAXoB,CAtNrB,oCAmORvB,uBAAYiO,aAnOJ,EAmOoB;AACzB7M,UAAMpB,uBAAYiO,aADO;AAEzB/I,aAAS2F,8BAFgB;AAGzBzF,YAAQ,sBAAQ;AACZ,eACIC,KAAKoK,OAAL,KAAiB,QAAjB,IACA,CAACzP,uBAAYwF,mBAAb,EAAkCxF,uBAAYiQ,kBAA9C,EAAkE5L,QAAlE,CACIgB,KAAK1B,MAAL,CAAYvC,IADhB,CAFJ;AAMH,KAVwB;AAWzBG,UAAM;AAXmB,CAnOpB,mBAAN;;AAkPA,IAAMiB,4CAAkBuB,OAAOC,IAAP,CAAYgB,cAAZ,EAA4B6G,GAA5B,CAAgC;AAAA,WAAO7G,eAAekB,GAAf,CAAP;AAAA,CAAhC,CAAxB,C;;;;;;;;;;;;;;;;;;;ACtUP;;;;AAEA,IAAMoL,kBAAkB,SAAlBA,eAAkB,CAAC9N,IAAD,EAAO+N,KAAP,EAAiB;AACrC,QAAMjQ,OAAOkC,KAAKlC,IAAL,CAAUkQ,KAAV,OAAoBD,KAApB,QAA8B,CAA9B,CAAb;;AAEA,QAAIjQ,KAAK+C,QAAL,CAAc,GAAd,CAAJ,EAAwB;AACpB,eAAO/C,KAAKkQ,KAAL,CAAW,GAAX,CAAP;AACH;;AAED,WAAO,CAAClQ,IAAD,CAAP;AACH,CARD;;AAUA,IAAMmQ,WAAW,SAAXA,QAAW,CAACjO,IAAD,EAAO+N,KAAP;AAAA,WAAiB/N,KAAKlC,IAAL,CAAU+C,QAAV,OAAuBkN,KAAvB,OAAjB;AAAA,CAAjB;;AAEO,IAAMzR,gDAAoB;AAC7BqE,aAAS;AACLtC,cAAM;AAAA,mBAAQ4P,SAASjO,IAAT,EAAe,SAAf,CAAR;AAAA,SADD;AAEL1B,iBAAS;AACLR,kBAAM;AAAA,qCAAoBgQ,gBAAgB9N,IAAhB,EAAsB,SAAtB,EAAiC,CAAjC,CAApB;AAAA,aADD;AAELpC,kBAAMpB,uBAAY2Q,IAFb;AAGLpP,kBAAM;AAAA,oDAAYiC,KAAKjC,IAAL,CAAU,CAAV,EAAaA,IAAzB;AAAA;AAHD;AAFJ,KADoB;;AAU7B0C,YAAQ;AACJpC,cAAM;AAAA,mBAAQ4P,SAASjO,IAAT,EAAe,QAAf,CAAR;AAAA,SADF;AAEJ1B,iBAAS;AACLR,kBAAM;AAAA,+BACIgQ,gBAAgB9N,IAAhB,EAAsB,QAAtB,EAAgC,CAAhC,CADJ,YAC6C8N,gBAAgB9N,IAAhB,EAAsB,QAAtB,EAAgC,CAAhC,CAD7C;AAAA,aADD;AAGLE,wBAAY,QAHP;AAILtC,kBAAMpB,uBAAY2Q;AAJb;AAFL,KAVqB;;AAoB7B9E,SAAK;AACDhK,cAAM;AAAA,mBAAQ4P,SAASjO,IAAT,EAAe,KAAf,CAAR;AAAA,SADL;AAED1B,iBAAS;AACLR,kBAAM;AAAA,iCACMgQ,gBAAgB9N,IAAhB,EAAsB,KAAtB,EAA6B,CAA7B,CADN,YAC4C8N,gBAAgB9N,IAAhB,EAAsB,KAAtB,EAA6B,CAA7B,CAD5C;AAAA,aADD;AAGLE,wBAAY,KAHP;AAILtC,kBAAMpB,uBAAY2Q;AAJb;AAFR;AApBwB,CAA1B;;AA+BA,IAAMe,oDAAsB,SAAtBA,mBAAsB,CAAC7P,IAAD,EAAOI,SAAP;AAAA,WAAsB;AACrDJ,kBADqD;AAErDC,iBAAS;AACLR,kBAAMW,SADD;AAELV,kBAAM,EAFD;AAGLH,kBAAMnB,0BAAe0R;AAHhB;AAF4C,KAAtB;AAAA,CAA5B;;AASA,IAAMC,oEAA8B,SAA9BA,2BAA8B;AAAA,WAAO;AAC9C/P,cAAM;AAAA,mBACF2B,KAAK8F,WAAL,IACA9F,KAAKG,MADL,IAEAH,KAAKG,MAAL,CAAY6F,OAAZ,KAAwBxJ,uBAAYoK,yBAHlC;AAAA,SADwC;AAK9CtI,iBAAS;AACLR,kBAAM;AAAA,uBAAQ,YAAYkC,KAAKlC,IAAzB;AAAA,aADD;AAELF,kBAAMpB,uBAAY6P;AAFb;AALqC,KAAP;AAAA,CAApC;;AAWA,IAAMgC,oEAA8B,SAA9BA,2BAA8B;AAAA,WAAO;AAC9ChQ,cAAM;AAAA,mBAAQ2B,KAAKmI,cAAL,KAAwB3L,uBAAY6E,eAA5C;AAAA,SADwC;AAE9C/C,iBAAS;AACLwC,2BAAe,8BAAS;AACpBR,sBAAMK,OAAN,CAAc,gBAAQ;AAClB,wBAAM2N,aAAatO,KAAKG,MAAL,CAAYpC,IAA/B;AAAA,wBACIwQ,QAAQD,WAAW3K,OAAX,CAAmB3D,IAAnB,IAA2B,CADvC;;AAGA,yBAAK,IAAIU,IAAI6N,KAAb,EAAoB7N,IAAI4N,WAAW3Q,MAAnC,EAA2C+C,GAA3C,EAAgD;AAC5C,4BAAI8N,UAAUF,WAAW5N,CAAX,CAAd;;AAEA,4BAAI8N,WAAWA,QAAQ5Q,IAAR,KAAiBpB,uBAAY6E,eAA5C,EAA6D;AACzDrB,iCAAKG,MAAL,CAAYpC,IAAZ,GAAmBuQ,WAAW7N,MAAX,CAAkB;AAAA,uCAAKgO,MAAMzO,IAAX;AAAA,6BAAlB,CAAnB;AACAwO,oCAAQzQ,IAAR,gCAAoByQ,QAAQzQ,IAAR,IAAgB,EAApC,IAAyCiC,IAAzC;;AAEA;AACH;AACJ;AACJ,iBAdD;AAeH;AAjBI;AAFqC,KAAP;AAAA,CAApC;;AAuBA,IAAMzD,8CAAmB;AAC5BmS,uBAAmB,CAACpS,kBAAkBqE,OAAnB,EAA4BrE,kBAAkBmE,MAA9C,EAAsDnE,kBAAkB+L,GAAxE;AADS,CAAzB,C;;;;;;;;;;;;;;;;;;;ACxFP;;AAEA;;;;AAKA;;;;AACA;;;;AAEA,IAAMsG,+BAA+B,SAA/BA,4BAA+B,SAAU;AAC3C,QAAM5R,kBAAkB,gCAAxB;AACAA,oBAAgBoC,mBAAhB,CAAoCyP,MAApC;;AAEA,WAAO;AAAA,eAAW7R,gBAAgB2C,oBAAhB,CAAqCnC,OAArC,CAAX;AAAA,KAAP;AACH,CALD;;AAOO,IAAMsR,4DAA0BF,6BAA6BtS,oCAAmB8G,MAAhD,CAAhC;;AAEA,IAAM2L,wEAAgCH,6BAA6B,CACtEtS,oCAAmB8G,MADmD,EAEtE9G,oCAAmB0G,MAFmD,CAA7B,CAAtC;;AAKA,IAAMgM,0EAAiCJ,6BAA6B,CACvEtS,oCAAmB8G,MADoD,EAEvE9G,oCAAmB0G,MAFoD,EAGvE1G,oCAAmBwG,KAHoD,EAIvExG,oCAAmBkG,QAJoD,CAA7B,CAAvC;;AAOA,IAAMyM,kGAA6CL,6BAA6B,CACnFtS,oCAAmB8G,MADgE,EAEnF9G,oCAAmB0G,MAFgE,EAGnF1G,oCAAmBwG,KAHgE,EAInFxG,oCAAmBkG,QAJgE,EAKnFlG,oCAAmBuG,qBALgE,CAA7B,CAAnD;;AAQA,IAAMqM,8DAA2B,SAA3BA,wBAA2B,UAAW;AAC/C,QAAMlS,kBAAkB,gCAAxB;AACA,WAAOA,gBAAgB2C,oBAAhB,CAAqCnC,OAArC,CAAP;AACH,CAHM;;kBAKQ;AAAA,WAAS;AACpB2R,qBAAa,uBAAM;AACf,gBAAMhS,YAAY,0BAAlB;AAAA,gBACIK,UAAU,gCAAeZ,IAAf,CADd;;AAGA,gBAAMwS,SAAS,CACXN,wBAAwBtR,OAAxB,CADW,EAEXuR,8BAA8BvR,OAA9B,CAFW,EAGXwR,+BAA+BxR,OAA/B,CAHW,EAIXyR,2CAA2CzR,OAA3C,CAJW,EAKX0R,yBAAyB1R,OAAzB,CALW,CAAf;;AAQA,mBAAO4R,OACF1O,MADE,CACK;AAAA,uBAAS2O,MAAMrR,IAAN,CAAWJ,MAApB;AAAA,aADL,EAEF0K,GAFE,CAEEnL,UAAUE,eAFZ,EAGFiL,GAHE,CAGE;AAAA,uBAAclL,WAAWE,KAAX,EAAd;AAAA,aAHF,CAAP;AAIH;AAjBmB,KAAT;AAAA,C;;;;;;;;;;;;;;;;;;;AC5Cf;;AAEO,IAAMgS,4BAAU,SAAVA,OAAU,GAAM;AACzB,QAAMC,QAAQ;AACVC,gBAAQ,EADE;AAEVC,0BAAkB;AAFR,KAAd;;AAKA,WAAO;AACHC,iBADG,uBACS;AACR,mBAAOH,MAAMC,MAAb;AACH,SAHE;AAIHG,iBAJG,qBAIOH,MAJP,EAIe;AACdD,kBAAMC,MAAN,GAAeD,MAAMC,MAAN,CAAavO,MAAb,CAAoBuO,MAApB,CAAf;AACA,mBAAO,IAAP;AACH,SAPE;AAQHI,2BARG,+BAQiBH,gBARjB,EAQmC;AAClCF,kBAAME,gBAAN,GAAyBF,MAAME,gBAAN,CAAuBxO,MAAvB,CAA8BwO,gBAA9B,CAAzB;AACA,mBAAO,IAAP;AACH,SAXE;AAYHI,qBAZG,yBAYW9L,MAZX,EAYmB;AAClB,gBAAI+L,cAAJ;;AAEA,eAAG7O,MAAH,CAAUsO,MAAMC,MAAhB,EAAwBD,MAAME,gBAA9B,EAAgD7O,OAAhD,CAAwD,gBAAQ;AAC5DkP,6BAAa7P,KAAK3C,KAAL,CAAWyG,MAAX,CAAb;AACH,aAFD;;AAIA,mBAAO+L,SAAP;AACH,SApBE;AAqBHC,2BArBG,iCAqBmB;AAClB,gBAAMC,aAAa,yCACXT,MAAMC,MAAN,CAAalH,GAAb,CAAiB;AAAA,uBAAQnH,KAAK8O,aAAL,EAAR;AAAA,aAAjB,CADW,CAAnB;AAAA,gBAGIC,UAAU,EAHd;;AAKA,mBAAO;AACHC,mBAAGC,KAAKC,IAAL,CAAUL,WAAWM,GAAX,CAAeC,CAAzB,IAA8BL,OAD9B;AAEHM,mBAAGJ,KAAKC,IAAL,CAAUL,WAAWM,GAAX,CAAeG,CAAzB,IAA8BP;AAF9B,aAAP;AAIH,SA/BE;AAiCH5S,aAjCG,iBAiCGyG,MAjCH,EAiCW;AAAA,uCACO,KAAKgM,mBAAL,EADP;AAAA,gBACFI,CADE,wBACFA,CADE;AAAA,gBACCK,CADD,wBACCA,CADD;;AAGV,wPAEaL,CAFb,kBAE2BK,CAF3B,4DAGM,KAAKX,aAAL,CAAmB9L,MAAnB,CAHN;AAKH;AAzCE,KAAP;AA2CH,CAjDM,C;;;;;;;;;;;;;;;;;;;ACFP;;AAQA;;AACA;;AACA;;AACA;;AAEO,IAAM5H,8CAAmB,SAAnBA,gBAAmB,iBAAkB;AAC9C,QAAMuU,mBAAmB,SAAnBA,gBAAmB,CAACC,KAAD,EAAQC,WAAR,EAAqBC,qBAArB,EAA+C;AACpE,YAAID,WAAJ,EAAiB;AACbD,kBAAMG,WAAN,CAAkBF,WAAlB;AACH;;AAED,YAAIC,qBAAJ,EAA2B;AACvBF,kBAAMI,0BAAN,GAAmCD,WAAnC,CAA+CD,qBAA/C;AACAF,kBAAMK,wBAAN,IACIL,MAAMK,wBAAN,GAAiCF,WAAjC,CAA6CD,qBAA7C,CADJ;AAEH;AACJ,KAVD;;AAYA,WAAO;AACHI,iBADG,qBACOC,MADP,EAC+B;AAAA,gBAAhBC,UAAgB,uEAAH,CAAG;;AAC9B,mBAAOC,eACF1B,SADE,GAEFhP,MAFE,CAEK,UAACiQ,KAAD,EAAQnC,KAAR;AAAA,uBAAkBA,SAAS2C,UAAT,IAAuBD,OAAOP,KAAP,CAAzC;AAAA,aAFL,CAAP;AAGH,SALE;AAOHU,wBAPG,4BAOc7R,EAPd,EAOkBoR,WAPlB,EAO+BC,qBAP/B,EAOsD;AACrD,iBAAKI,SAAL,CAAezR,EAAf,EAAmBoB,OAAnB,CAA2B,iBAAS;AAChC8P,iCAAiBC,KAAjB,EAAwBC,WAAxB,EAAqCC,qBAArC;AACH,aAFD;AAGH,SAXE;AAaHS,YAbG,gBAaE9R,EAbF,EAaM;AACL,gBAAM+R,eAAe,yCAArB;;AAEA,iBAAKN,SAAL,CAAezR,EAAf,EAAmBoB,OAAnB,CAA2B,iBAAS;AAChC,oBAAM4Q,kBAAkBb,MAAMI,0BAAN,EAAxB;;AAEAL,iCACIC,KADJ,EAEIY,aAAaZ,MAAMc,YAAN,EAAb,CAFJ,EAGID,kBAAkBD,aAAaC,gBAAgBE,YAAhB,EAAb,CAAlB,GAAiE,IAHrE;AAKH,aARD;AASH,SAzBE;AA2BHC,aA3BG,iBA2BGnS,EA3BH,EA2BO;AACN,iBAAK8R,IAAL,CAAU;AAAA,uBAAS,CAAC9R,GAAGmR,KAAH,CAAV;AAAA,aAAV;AACH,SA7BE;AA+BHiB,uBA/BG,2BA+BapS,EA/Bb,EA+BiB;AAChB,gBAAM+R,eAAe,yCAArB;;AAEA,iBAAKN,SAAL,CAAezR,EAAf,EAAmBoB,OAAnB,CAA2B;AAAA,uBACvB,0BACIiR,WADJ,EAEI,iBAAS;AACL,wBAAML,kBAAkBb,MAAMI,0BAAN,EAAxB;;AAEAL,qCACIC,KADJ,EAEIY,aAAaZ,MAAMc,YAAN,EAAb,CAFJ,EAGID,kBAAkBD,aAAaC,gBAAgBE,YAAhB,EAAb,CAAlB,GAAiE,IAHrE;AAKH,iBAVL,EAWI;AAAA,2BAASf,MAAMpB,KAAN,CAAYvR,IAArB;AAAA,iBAXJ,CADuB;AAAA,aAA3B;AAeH,SAjDE;AAmDH8T,wBAnDG,4BAmDcC,GAnDd,EAmDmB;AAAA;;AAClB,gBAAMR,eAAe,yCAArB;;AAEA,eAAGtQ,MAAH,CAAU8Q,GAAV,EAAenR,OAAf,CAAuB,UAACpB,EAAD,EAAKgP,KAAL,EAAe;AAClC,sBAAKyC,SAAL,CAAezR,EAAf,EAAmBoB,OAAnB,CAA2B,uBAAe;AACtC,wBAAMoR,YAAY,uBAASH,WAAT,EAAsB;AAAA,+BAASlB,MAAMpB,KAAN,CAAYvR,IAArB;AAAA,qBAAtB,CAAlB;AACA,wBAAIiU,cAAcb,eAAe1B,SAAf,GAA2B9L,OAA3B,CAAmCiO,WAAnC,CAAlB;;AAEA,0BAAKZ,SAAL,CACI;AAAA,+BAAS,CAACe,UAAUlR,QAAV,CAAmB6P,KAAnB,CAAV;AAAA,qBADJ,EAEInC,QAAQ,CAAR,GAAYyD,WAAZ,GAA0B,CAF9B,EAGErR,OAHF,CAGU,iBAAS;AACf,4BAAM4Q,kBAAkBb,MAAMI,0BAAN,EAAxB;;AAEAL,yCACIC,KADJ,EAEIY,aAAaZ,MAAMc,YAAN,EAAb,CAFJ,EAGID,kBAAkBD,aAAaC,gBAAgBE,YAAhB,EAAb,CAAlB,GAAiE,IAHrE;AAKH,qBAXD;AAYH,iBAhBD;AAiBH,aAlBD;AAmBH,SAzEE;AA2EHpU,aA3EG,iBA2EGyG,MA3EH,EA2EW;AACV,mBAAOqN,kBAAkBA,eAAe9T,KAAf,CAAqByG,MAArB,CAAzB;AACH;AA7EE,KAAP;AA+EH,CA5FM;;kBA8FQ,YAA2B;AAAA,QAA1BmO,gBAA0B,uEAAP,EAAO;;AACtC,QAAIC,QAAQ,0CAAkB,yCAAlB,EAAqCD,gBAArC,CAAZ;;AAEA,WAAO;AACH7U,uBADG,2BACaH,QADb,EACuB;AACtB,gBAAIsS,SAAS,EAAb;;AAEA,gBAAI;AACAA,yBAAS,4CAAoBtS,QAApB,EAA8BiV,KAA9B,CAAT;AACH,aAFD,CAEE,OAAOvS,CAAP,EAAU;AACR,sCAAS,6BAA6BA,EAAEC,OAAxC,EAAiDD,EAAEE,KAAnD;AACA,sBAAMF,CAAN;AACH;;AAED,mBAAO4P,MAAP;AACH,SAZE;AAcH4C,kBAdG,sBAcQC,cAdR,EAcwB;AACvBF,oBAAQ,0CAAkBA,KAAlB,EAAyBE,cAAzB,CAAR;AACH,SAhBE;AAkBHC,yBAlBG,+BAkBiB;AAChB,iBAAKF,UAAL,CAAgB,yCAAhB;AACH,SApBE;AAqBHG,+BArBG,qCAqBuB;AACtB,iBAAKH,UAAL,CAAgB,+CAAhB;AACH,SAvBE;AAwBHI,yBAxBG,+BAwBiB;AAChB,iBAAKJ,UAAL,CAAgB,yCAAhB;AACH,SA1BE;AA2BHK,uBA3BG,6BA2Be;AACd,iBAAKL,UAAL,CAAgB,uCAAhB;AACH,SA7BE;AA+BHM,4BA/BG,gCA+BkBC,MA/BlB,EA+B0B;AACzB,iBAAKP,UAAL,CAAgB,8CAAsBO,MAAtB,CAAhB;AACH;AAjCE,KAAP;AAmCH,C;;;;;;;;;;;;;;;;;;;;;ACjJD;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAEA,IAAMC,gBAAgB;AAClBC,aAAS,SADS;AAElBC,qBAAiB,iBAFC;AAGlBC,aAAS,SAHS;AAIlBC,WAAO;AAJW,CAAtB;;AAOO,IAAMC,kEACRL,cAAcC,OADN,EACgBA,0BADhB,4BAERD,cAAcE,eAFN,EAEwBA,uBAFxB,4BAGRF,cAAcG,OAHN,EAGgBA,iBAHhB,4BAIRH,cAAcI,KAJN,EAIcA,eAJd,WAAN;;AAOA,IAAME,8BAAW,SAAXA,QAAW,YAAa;AACjC,QAAK,CAACD,OAAOE,SAAP,CAAD,KAAuBA,SAAxB,KAAuCP,cAAcC,OAAzD,EAAkE;AAC9D,eAAOI,OAAOJ,OAAd;AACH;;AAED,WAAOO,kBAAkBP,0BAAlB,EAA2BI,OAAOE,SAAP,CAA3B,CAAP;AACH,CANM;;AAQA,IAAME,4CAAkB,SAAlBA,eAAkB;AAAA,WAAMH,SAASN,cAAcC,OAAvB,CAAN;AAAA,CAAxB;;AAEA,IAAMS,wDAAwB,SAAxBA,qBAAwB;AAAA,WAAMJ,SAASN,cAAcE,eAAvB,CAAN;AAAA,CAA9B;;AAEA,IAAMS,4CAAkB,SAAlBA,eAAkB;AAAA,WAAML,SAASN,cAAcG,OAAvB,CAAN;AAAA,CAAxB;;AAEA,IAAMS,wCAAgB,SAAhBA,aAAgB;AAAA,WAAMN,SAASN,cAAcI,KAAvB,CAAN;AAAA,CAAtB;;AAEA,IAAMI,gDAAoB,SAApBA,iBAAoB,CAACjB,KAAD,EAAQsB,MAAR;AAAA,WAAmB,wCAAsBtB,KAAtB,EAA6BsB,MAA7B,CAAnB;AAAA,CAA1B;;AAEA,IAAMC,wDAAwB,SAAxBA,qBAAwB;AAAA,WAAU,kCAAWf,MAAX,CAAV;AAAA,CAA9B,C;;;;;;;;;;;;;;;;;;;ACvCP;;AAEO,IAAMgB,oDAAsB,EAA5B;;AAEA,IAAMC,sDAAuB,CAChC,IADgC,EAEhC,IAFgC,EAGhC,GAHgC,EAIhC,GAJgC,EAKhC,GALgC,EAMhC,KANgC,EAOhC,KAPgC,EAQhC,GARgC,EAShC,GATgC,EAUhC,KAVgC,EAWhC,IAXgC,EAYhC,GAZgC,EAahC,GAbgC,EAchC,GAdgC,CAA7B;;AAiBA,IAAMC,wEAAgC,SAAhCA,6BAAgC;AAAA,WAAM,oCAAcD,oBAAd,CAAN;AAAA,CAAtC,C;;;;;;;;;;;;;;;;;;;;;ACrBP;;AAEO,IAAME,uCACN,wCAAiBC,+BAAjB,EAAgC,SAAhC,CADM;;AAGTC,iBAAa,MAHJ;AAITC,sBAAkB,SAJT;AAKTC,eAAW,MALF;AAMTC,oBAAgB;AANP,EAAN;;kBASQ,kCAAWL,MAAX,C;;;;;;;;;;;;;;;;;;;ACXf;;AAEO,IAAMA,0BAAS;AAClBE,iBAAa,MADK;AAElBC,sBAAkB,MAFA;AAGlBC,eAAW,MAHO;AAIlBC,oBAAgB,MAJE;AAKlBC,wBAAoB,SALF;AAMlBC,2BAAuB,SANL;AAOlBC,uBAAmB,SAPD;AAQlBC,yBAAqB,SARH;AASlBC,mBAAe,SATG;AAUlBC,wBAAoB,SAVF;AAWlBC,6BAAyB,SAXP;AAYlBC,oBAAgB,SAZE;AAalBC,uBAAmB,SAbD;AAclBC,qBAAiB,SAdC;AAelBC,oBAAgB,SAfE;AAgBlBC,kBAAc,SAhBI;AAiBlBC,qBAAiB,SAjBC;AAkBlBC,mBAAe,SAlBG;AAmBlBC,wBAAoB;AAnBF,CAAf;;kBAsBQ,kCAAWpB,MAAX,C;;;;;;;;;;;;;;;;;;;;ACxBR,IAAMC,wCAAgB;AACzBC,iBAAa,MADY;AAEzBC,sBAAkB,MAFO;AAGzBC,eAAW,MAHc;AAIzBC,oBAAgB,MAJS;AAKzBC,wBAAoB,SALK;AAMzBC,2BAAuB,SANE;AAOzBC,uBAAmB,SAPM;AAQzBC,yBAAqB,SARI;AASzBC,mBAAe,SATU;AAUzBC,wBAAoB,SAVK;AAWzBC,6BAAyB,SAXA;AAYzBC,oBAAgB,SAZS;AAazBC,uBAAmB,SAbM;AAczBC,qBAAiB,SAdQ;AAezBC,oBAAgB,SAfS;AAgBzBC,kBAAc,SAhBW;AAiBzBC,qBAAiB,SAjBQ;AAkBzBC,mBAAe,SAlBU;AAmBzBC,wBAAoB;AAnBK,CAAtB;;AAsBA,IAAMC,kCAAa,SAAbA,UAAa,QAAS;AAC/B,QAAMC,YAAY;AACdpB,qBAAaqB,MAAMrB,WADL;AAEdsB,qBAAa,CAFC;AAGdC,mBAAWF,MAAMpB,gBAHH;AAIdC,mBAAWmB,MAAMnB,SAJH;AAKdsB,oBAAY,WALE;AAMdC,kBAAU,EANI;AAOdC,oBAAY,CAPE,EAOC;AACfC,sBAAc,EARA,EAQI;AAClBC,qBAAa,GATC,EASI;AAClBC,2BAAmB,EAVL;AAWdC,yBAAiB,EAXH;AAYdC,qBAAa,EAZC;AAadC,gBAAQ,EAbM;AAcdC,qBAAa,CAdC;AAedC,+BAAuB,EAfT;;AAiBdC,uBAAe,CAjBD;AAkBdC,wBAAgBf,MAAMH;AAlBR,KAAlB;;AAqBA,WAAO;AACHE,4BADG;AAEHiB,yBAAiB;AACbC,mBAAO;AACHC,sBAAM;AACFhG,uBAAG,CADD;AAEFE,uBAAG;AAFD,iBADH;AAKH8E,2BAAWF,MAAMlB;AALd,aADM;AAQbqC,kBAAM;AACFxC,6BAAaqB,MAAMrB,WADjB;AAEFsB,6BAAa,CAFX;AAGFmB,iCAAiB;AAHf,aARO;AAabC,4BAAgB;AAbH,SAFd;;AAkBHC,4BACOvB,SADP,CAlBG;;AAsBHwB,gCACOxB,SADP;AAEIG,uBAAWF,MAAMjB,kBAFrB;AAGIyC,8BACOzB,SADP;AAEI0B,wBAAQ,CAFZ;AAGIC,wBAAQ,CAHZ;AAIIxB,2BAAWF,MAAMhB;AAJrB,cAHJ;AASI4B,yBAAa;AATjB,UAtBG;;AAkCHe,6CACO5B,SADP;AAEIG,uBAAWF,MAAMf,iBAFrB;AAGI2C,wBAAY;AAHhB,UAlCG;;AAwCHC,iCACO9B,SADP;AAEI2B,oBAAQ,EAFZ;AAGI7G,qBAAS,CAHb;AAIIqF,uBAAWF,MAAMd;AAJrB,UAxCG;;AA+CH4C,kCACO/B,SADP;AAEIG,uBAAWF,MAAMb,aAFrB;AAGI4C,4BAAgB,EAHpB;AAIIC,yBAAa,EAJjB;AAKIpB,yBAAa,CALjB;AAMIqB,gCAAoB,CANxB;AAOIC,gCAAoB,CAPxB;AAQIxB,yBAAa,EARjB;AASIyB,8BAAkB;AATtB,UA/CG;;AA2DHC,uCACOrC,SADP;AAEIG,uBAAWF,MAAMZ,kBAFrB;AAGI2C,4BAAgB,EAHpB;AAIInB,yBAAa,CAJjB;AAKIF,yBAAa,EALjB;AAMI2B,mCAAuB,EAN3B;AAOIC,wBAAY;AACRpH,mBAAG,EADK;AAERE,mBAAG;AAFK,aAPhB;AAWIuF,oBAAQ;AAXZ,UA3DG;;AAyEH4B,wBAAgB;AACZC,oBAAQ;AACJtH,mBAAG,EADC;AAEJE,mBAAG;AAFC,aADI;AAKZsF,yBAAa;AACTxF,mBAAG,EADM;AAETE,mBAAG;AAFM;AALD,SAzEb;;AAoFHqH,sCACO1C,SADP;AAEIa,yBAAa,CAFjB;AAGIV,uBAAWF,MAAMjB,kBAHrB;AAIIkC,gCACOlB,SADP;AAEI2C,+BAAe,CAFnB;AAGIC,uBAAO,EAHX;AAIIC,uBAAO,EAJX;AAKI1C,2BAAWF,MAAMf;AALrB;AAJJ,UApFG;;AAiGH4D,qCACO9C,SADP;AAEIG,uBAAWF,MAAMX,uBAFrB;AAGIuB,yBAAa,CAHjB;AAIIkC,iCACO/C,SADP;AAEIa,6BAAa,CAFjB;AAGIV,2BAAWF,MAAMX,uBAHrB;AAII0D,uBAAO,CAJX;AAKIC,uBAAO;AALX;AAJJ,UAjGG;;AA8GHC,uCACOlD,SADP;AAEIG,uBAAWF,MAAMV,cAFrB;AAGIsC,wBAAY;AAHhB,UA9GG;;AAoHHsB,wCACOnD,SADP;AAEIG,uBAAWF,MAAMT,iBAFrB;AAGIqB,yBAAa;AAHjB,UApHG;;AA0HHuC,wCACOpD,SADP;AAEIa,yBAAa,CAFjB;AAGIV,uBAAWF,MAAMR,eAHrB;AAIIyB,gCACOlB,SADP;AAEI2C,+BAAe,CAFnB;AAGIC,uBAAO,EAHX;AAIIC,uBAAO,EAJX;AAKI1C,2BAAWF,MAAMpB;AALrB;AAJJ,UA1HG;;AAuIHwE,wCACOrD,SADP;AAEIG,uBAAWF,MAAMpB,gBAFrB;AAGIgD,wBAAY;AAHhB,UAvIG;;AA6IHyB,sCACOtD,SADP;AAEIG,uBAAWF,MAAMR;AAFrB,UA7IG;;AAkJH8D,qCACOvD,SADP;AAEIG,uBAAWF,MAAMP;AAFrB,UAlJG;;AAuJH8D,mCACOxD,SADP;AAEIG,uBAAWF,MAAMN;AAFrB,UAvJG;;AA4JH8D,kCACOzD,SADP;AAEIG,uBAAWF,MAAMP,cAFrB;AAGIwB,gCACOlB,SADP;AAEI2C,+BAAe,CAFnB;AAGIC,uBAAO,EAHX;AAIIC,uBAAO,EAJX;AAKI1C,2BAAWF,MAAMP;AALrB;AAHJ,UA5JG;;AAwKHgE,sCACO1D,SADP;AAEIG,uBAAWF,MAAMZ,kBAFrB;AAGI2C,4BAAgB,EAHpB;AAIInB,yBAAa,CAJjB;AAKIF,yBAAa,EALjB;AAMI2B,mCAAuB,EAN3B;AAOIC,wBAAY;AACRpH,mBAAG,EADK;AAERE,mBAAG;AAFK,aAPhB;AAWIuF,oBAAQ;AAXZ,UAxKG;;AAsLH+C,qCACO3D,SADP;AAEIG,uBAAWF,MAAMjB,kBAFrB;AAGIkC,gCACOlB,SADP;AAEI2C,+BAAe,CAFnB;AAGIC,uBAAO,EAHX;AAIIC,uBAAO,EAJX;AAKI1C,2BAAWF,MAAMZ;AALrB;AAHJ,UAtLG;;AAkMHuE,iCACO5D,SADP;AAEIG,uBAAWF,MAAMZ;AAFrB,UAlMG;;AAuMHwE,wCACO7D,SADP;AAEIG,uBAAWF,MAAMjB,kBAFrB;AAGIkC,gCACOlB,SADP;AAEI2C,+BAAe,CAFnB;AAGIC,uBAAO,EAHX;AAIIC,uBAAO,EAJX;AAKI1C,2BAAWF,MAAMb;AALrB;AAHJ,UAvMG;;AAmNH0E,qCACO9D,SADP;AAEIG,uBAAWF,MAAMjB;AAFrB,UAnNG;;AAwNH+E,qCACO/D,SADP;AAEIyB,8BACOzB,SADP;AAEI0B,wBAAQ,CAFZ;AAGIC,wBAAQ,CAHZ;AAIIxB,2BAAWF,MAAMhB;AAJrB,cAFJ;AAQIkB,uBAAWF,MAAMJ;AARrB;AAxNG,KAAP;AAmOH,CAzPM;;kBA2PQE,WAAWpB,aAAX,C;AAER,IAAMqF,8CAAmB,SAAnBA,gBAAmB,CAACjH,KAAD,EAAQkH,YAAR,EAAyB;AACrD,QAAMC,yBAAiBnH,KAAjB,CAAN;AACA3R,WAAOC,IAAP,CAAY6Y,SAAZ,EAAuB1Y,OAAvB,CAA+B,iBAAS;AACpC0Y,kBAAUjE,KAAV,IAAmBgE,YAAnB;AACH,KAFD;;AAIA,WAAOC,SAAP;AACH,CAPM,C;;;;;;;;;;;;;;;;;;;ACnRP;;AAEO,IAAMxF,0BAAS;AAClBE,iBAAa,MADK;AAElBC,sBAAkB,MAFA;AAGlBC,eAAW,MAHO;AAIlBC,oBAAgB,MAJE;AAKlBC,wBAAoB,SALF;AAMlBC,2BAAuB,SANL;AAOlBC,uBAAmB,SAPD;AAQlBC,yBAAqB,SARH;AASlBC,mBAAe,SATG;AAUlBC,wBAAoB,SAVF;AAWlBC,6BAAyB,SAXP;AAYlBC,oBAAgB,SAZE;AAalBC,uBAAmB,SAbD;AAclBC,qBAAiB,SAdC;AAelBC,oBAAgB,SAfE;AAgBlBC,kBAAc,SAhBI;AAiBlBC,qBAAiB,SAjBC;AAkBlBC,mBAAe,SAlBG;AAmBlBC,wBAAoB;AAnBF,CAAf;;kBAsBQ,kCAAWpB,MAAX,C;;;;;;;;;;;;;;;;;;;ACxBf;;AACA;;AACA;;AAEA;;AAEA,IAAMyF,oBAAoB,iBAA1B;;AAEO,IAAM7H,sCAAe,SAAfA,YAAe,GAAM;AAC9B,WAAO6H,iBAAP;AACH,CAFM;;AAIP,IAAMC,iBAAiB,SAAjBA,cAAiB;AAAA,WAAU;AAC7B9H;AAD6B,KAAV;AAAA,CAAvB;;AAIA,IAAM+H,uBAAuB,SAAvBA,oBAAuB;AAAA,WAAU;AACnC3I,mBADmC,uBACvB4I,QADuB,EACb;AAClBnK,kBAAM4C,KAAN,GAAc,wCAAsB5C,MAAM4C,KAA5B,EAAmCuH,QAAnC,CAAd;AACH;AAHkC,KAAV;AAAA,CAA7B;;AAMA,IAAMC,sBAAsB,SAAtBA,mBAAsB;AAAA,WAAU;AAClCC,iBADkC,qBACxBC,MADwB,EAChB;AACd,mBAAO,kCAAcA,MAAd,EAAsBtK,MAAM4C,KAAN,CAAYqE,IAAlC,CAAP;AACH,SAHiC;AAKlCsD,kBALkC,sBAKvBC,KALuB,EAKhBC,WALgB,EAKH;AAC3B,mBAAO,kCAAc,iCAAkBA,WAAlB,EAA+BD,KAA/B,CAAd,EAAqDxK,MAAM4C,KAAN,CAAYmE,KAAjE,CAAP;AACH,SAPiC;AASlC2D,wBATkC,4BASjBpc,IATiB,QASD;AAAA,gBAAR0S,CAAQ,QAARA,CAAQ;AAAA,gBAALE,CAAK,QAALA,CAAK;;AAC7B,gBAAMyJ,YAAY3K,MAAM4C,KAAN,CAAYmE,KAAZ,CAAkBC,IAApC;AACA,gBAAIwD,cAAJ;;AAEA;AACA,oBAAQlc,IAAR;AACI,qBAAKsc,sBAAWC,KAAhB;AACIL,4BAAQ,EAAExJ,GAAGA,IAAI2J,UAAU3J,CAAnB,EAAsBE,GAAGA,IAAIyJ,UAAUzJ,CAAV,GAAc,CAA3C,EAAR;;AAEA,2BAAO,KAAKqJ,UAAL,CAAgBC,KAAhB,EAAuB,CAC1B,EAAExJ,GAAG,CAAL,EAAQE,GAAG,CAAX,EAD0B,EAE1B,EAAEF,GAAG2J,UAAU3J,CAAf,EAAkBE,GAAGyJ,UAAUzJ,CAAV,GAAc,CAAnC,EAF0B,EAG1B,EAAEF,GAAG,CAAL,EAAQE,GAAGyJ,UAAUzJ,CAArB,EAH0B,CAAvB,CAAP;;AAMJ,qBAAK0J,sBAAWE,IAAhB;AACIN,4BAAQ,EAAExJ,GAAGA,CAAL,EAAQE,GAAGA,IAAIyJ,UAAUzJ,CAAV,GAAc,CAA7B,EAAR;;AAEA,2BAAO,KAAKqJ,UAAL,CAAgBC,KAAhB,EAAuB,CAC1B,EAAExJ,GAAG,CAAL,EAAQE,GAAGyJ,UAAUzJ,CAAV,GAAc,CAAzB,EAD0B,EAE1B,EAAEF,GAAG2J,UAAU3J,CAAf,EAAkBE,GAAG,CAArB,EAF0B,EAG1B,EAAEF,GAAG2J,UAAU3J,CAAf,EAAkBE,GAAGyJ,UAAUzJ,CAA/B,EAH0B,CAAvB,CAAP;;AAMJ,qBAAK0J,sBAAWG,IAAhB;AACIP,4BAAQ,EAAExJ,GAAGA,IAAI2J,UAAUzJ,CAAV,GAAc,CAAvB,EAA0BA,GAAGA,IAAIyJ,UAAU3J,CAA3C,EAAR;;AAEA,2BAAO,KAAKuJ,UAAL,CAAgBC,KAAhB,EAAuB,CAC1B,EAAExJ,GAAG,CAAL,EAAQE,GAAG,CAAX,EAD0B,EAE1B,EAAEF,GAAG2J,UAAUzJ,CAAV,GAAc,CAAnB,EAAsBA,GAAGyJ,UAAU3J,CAAnC,EAF0B,EAG1B,EAAEA,GAAG2J,UAAUzJ,CAAf,EAAkBA,GAAG,CAArB,EAH0B,CAAvB,CAAP;;AAMJ;AACI,2BAAO,EAAP;AA7BR;AA+BH,SA7CiC;AA+ClCnT,aA/CkC,mBA+C1B;AAAA,gCACmDiS,MAAMxL,MADzD;AAAA,gBACIwW,UADJ,iBACIA,UADJ;AAAA,gBACgBC,UADhB,iBACgBA,UADhB;AAAA,gBAC4BC,SAD5B,iBAC4BA,SAD5B;AAAA,gBACuCC,OADvC,iBACuCA,OADvC;;;AAGJ,gBAAIA,OAAJ,EAAa;AACTH,2BAAWA,WAAW3c,MAAX,GAAoB,CAA/B,EAAkC2S,CAAlC,IAAuChB,MAAM4C,KAAN,CAAYmE,KAAZ,CAAkBC,IAAlB,CAAuBhG,CAA9D;AACH;;AAED,0DAES,KAAKqJ,SAAL,CAAeW,UAAf,CAFT,0BAGS,CAACG,OAAD,IAAY,KAAKT,gBAAL,CAAsBQ,SAAtB,EAAiCD,UAAjC,CAHrB;AAKH;AA3DiC,KAAV;AAAA,CAA5B;;AA8DO,IAAMnE,4CAAkB,SAAlBA,eAAkB;AAAA,WAC3B,8BAAY9G,KAAZ,EAAmB,CAACkK,oBAAD,EAAuBE,mBAAvB,EAA4CH,cAA5C,CAAnB,CAD2B;AAAA,CAAxB;;kBAGQ,UAACzV,MAAD,EAASoO,KAAT;AAAA,WAAmBkE,gBAAgB,EAAEtS,cAAF,EAAUoO,YAAV,EAAiBwI,eAAexI,KAAhC,EAAhB,CAAnB;AAAA,C;;;;;;;;;;;;;;;;;;;;;ACvFf;;;;AACA;;AACA;;AAMA;;AACA;;AACA;;;;AAKO,IAAMyI,sCAAe,SAAfA,YAAe,CAACjK,KAAD,EAAQkK,cAAR,EAA2B;AACnD,aAAS3Y,IAAT,CAAcjC,IAAd,EAAoB6a,QAApB,EAA8B3I,KAA9B,EAAqC;AACjC,eAAOxB,MAAMoK,gBAAgB9a,IAAhB,EAAsB6a,QAAtB,EAAgC3I,KAAhC,EAAuC0I,cAAvC,CAAN,CAAP;AACH;;AAED3Y,SAAK8Y,iBAAL,GAAyB,YAAM;AAC3B,eAAOH,cAAP;AACH,KAFD;;AAIA,WAAO3Y,IAAP;AACH,CAVM;;AAYA,IAAM6Y,4CAAkB,SAAlBA,eAAkB,CAAC9a,IAAD,QAAiBkS,KAAjB,EAAwBtU,IAAxB,EAAiC;AAAA,QAAxB0S,CAAwB,QAAxBA,CAAwB;AAAA,QAArBE,CAAqB,QAArBA,CAAqB;;AAC5D,QAAMwK,YAAY,6BACVhb,KAAKlC,IADK,EAEV4V,4CAFU,EAGV,6DAHU,CAAlB;AAAA,QAKIuH,uBAAuBD,UAAUrd,MALrC;AAAA,QAMIud,oBAAoB,wCAA2BF,SAA3B,CANxB;;AAQA,WAAO;AACHnU,YAAI,yBADD;AAEHsU,oBAAY,uBAAUnb,IAAV,CAFT;AAGHpC,kBAHG;AAIHG,cAAM,EAJH;AAKHmU,oBALG;AAMHwI,uBAAexI,KANZ;AAOHlS,kBAPG;AAQHlC,cAAMkC,KAAKlC,IARR;AASHoC,oBAAYF,KAAKE,UATd;AAUH8a,4BAVG;AAWHC,kDAXG;AAYHC,4CAZG;AAaHE,yBAAiB,EAAE9K,IAAF,EAAKE,IAAL;AAbd,KAAP;AAeH,CAxBM;;AA0BA,IAAM6K,0DAAyB,SAAzBA,sBAAyB;AAAA,WAAU;AAC5CC,mBAAWC,mBAAmBjM,KAAnB,CADiC;AAE5CkM,iBAASC,iBAAiBnM,KAAjB,CAFmC;AAG5CoM,mBAAWC,mBAAmBrM,KAAnB,CAHiC;AAI5CsM,0BAAkBC,0BAA0BvM,KAA1B,CAJ0B;AAK5CS,oBAAY+L,oBAAoBxM,KAApB;AALgC,KAAV;AAAA,CAA/B;;AAQA,IAAMyM,gDAAoB,SAApBA,iBAAoB;AAAA,wBAC1BzM,KAD0B;AAE7BuL,kBAAUmB,kBAAkB1M,KAAlB,CAFmB;AAG7B2M,oBAAYnM,oBAAoBR,KAApB;AAHiB;AAAA,CAA1B;;AAMA,IAAM4M,wDAAwB,SAAxBA,qBAAwB;AAAA,WAAU;AAC3CC,eAD2C,qBACjC;AACN,mBAAO7M,MAAMvR,IAAb;AACH,SAH0C;AAK3CiS,qBAL2C,2BAK3B;AACZ,mBAAOV,MAAMS,UAAb;AACH,SAP0C;AAS3CqM,oBAT2C,0BAS5B;AACX,mBAAO9M,MAAMoM,SAAb;AACH,SAX0C;AAa3C5K,kCAb2C,wCAad;AACzB,mBAAOxB,MAAMiC,eAAb;AACH,SAf0C;AAiB3C8K,2BAjB2C,iCAiBrB;AAClB,mBAAO/M,MAAMsM,gBAAb;AACH,SAnB0C;AAqB3CU,qBArB2C,2BAqB3B;AACZ,mBAAOhN,MAAM2M,UAAb;AACH,SAvB0C;AAyB3CM,aAzB2C,mBAyBnC;AACJ,mBAAOjN,MAAMzI,EAAb;AACH,SA3B0C;AA6B3C2V,oBA7B2C,0BA6B5B;AACX,mBAAOlN,MAAMgM,SAAb;AACH,SA/B0C;AAiC3CmB,iBAjC2C,uBAiC/B;AACR,mBAAOnN,MAAM4C,KAAN,CAAY6D,MAAnB;AACH,SAnC0C;AAqC3CrU,eArC2C,qBAqCjC;AACN,mBAAO4N,MAAMxR,IAAb;AACH,SAvC0C;AAyC3C4e,eAzC2C,qBAyCjC;AACN,mBAAOpN,MAAMtP,IAAb;AACH,SA3C0C;AA6C3C2c,mBA7C2C,yBA6C7B;AACV,mBAAOrN,MAAMtP,IAAN,CAAWpC,IAAlB;AACH,SA/C0C;AAiD3Cgf,qBAjD2C,2BAiD3B;AACZ,mBAAOtN,MAAM6L,UAAb;AACH,SAnD0C;AAqD3C0B,kBArD2C,wBAqD9B;AACT,mBAAOvN,MAAMtP,IAAN,CAAW0C,GAAlB;AACH,SAvD0C;AAyD3Coa,iBAzD2C,uBAyD/B;AACR,mBAAOxN,MAAMnP,MAAb;AACH,SA3D0C;AA6D3C4c,mBA7D2C,yBA6D7B;AACV,mBAAOzN,MAAMuL,QAAb;AACH,SA/D0C;AAiE3CmC,kBAjE2C,wBAiE9B;AACT,mBAAO1N,MAAMkM,OAAb;AACH,SAnE0C;AAqE3ChK,oBArE2C,0BAqE5B;AACX,mBAAOlC,MAAM1R,IAAb;AACH;AAvE0C,KAAV;AAAA,CAA9B;;AA0EA,IAAMqf,8CAAmB,SAAnBA,gBAAmB;AAAA,WAAU;AACtC;AACAC,iBAFsC,qBAE5BC,WAF4B,EAEf;AAAA,gBACXtC,QADW,GACoBvL,KADpB,CACXuL,QADW;AAAA,gBACD3I,KADC,GACoB5C,KADpB,CACD4C,KADC;AAAA,gBACM8I,SADN,GACoB1L,KADpB,CACM0L,SADN;;AAAA,wBAEFmC,cAAcA,WAAd,GAA4BtC,QAF1B;AAAA,gBAEXvK,CAFW,SAEXA,CAFW;AAAA,gBAERE,CAFQ,SAERA,CAFQ;;AAGnB,gBAAM1S,OAAOkd,UACR3S,GADQ,CAEL,UAAC+U,IAAD,EAAO1c,CAAP;AAAA,uCACiB4P,IAAI4B,MAAM0D,iBAD3B,eACoDpF,IAC5C,IAAI0B,MAAM2D,eAAV,IAA6BnV,IAAI,CAAjC,CAFR,WAEgD,yBAAO0c,IAAP,CAFhD;AAAA,aAFK,EAMR7U,IANQ,CAMH,EANG,CAAb;;AAQA;AACA;AACA,oBACIyS,UAAU,CAAV,EAAard,MAAb,IAAuB2R,MAAMxR,IAAN,CAAWH,MAAX,GAAoB,CAA3C,eACgB,yBAAO2R,MAAMxR,IAAb,CADhB,gBAEM,EAHV,iCAKewS,IAAI4B,MAAM0D,iBALzB,eAKkDpF,IAAI,IAAI0B,MAAM2D,eALhE,yCAMuB3D,MAAMqD,UAN7B,qBAMuDrD,MAAMsD,QAN7D,gBAOItD,MAAM+B,SAPV,4BASUnW,IATV;AAWH,SA1BqC;AA4BtCuf,sBA5BsC,4BA4BP;AAAA,4FAAJ,EAAI;AAAA,gBAAdC,KAAc,SAAdA,KAAc;;AAC3B,gBAAI,CAACA,KAAL,EAAY,OAAO,EAAP;;AADe,gBAGnBzC,QAHmB,GAGyBvL,KAHzB,CAGnBuL,QAHmB;AAAA,gBAGToB,UAHS,GAGyB3M,KAHzB,CAGT2M,UAHS;AAAA,gBAGG/J,KAHH,GAGyB5C,KAHzB,CAGG4C,KAHH;AAAA,gBAGUiJ,UAHV,GAGyB7L,KAHzB,CAGU6L,UAHV;;;AAK3B,kCAAmBN,SAASvK,CAAT,GAAa,IAAI4B,MAAM0D,iBAA1C,eAAmEiF,SAASrK,CAAT,GAC/DyL,WAAW1L,CADoD,GAE/D2B,MAAM2D,eAFV,yCAGuB3D,MAAMqD,UAH7B,qBAGuDrD,MAAMgE,aAH7D,gBAIIhE,MAAMiE,cAJV,4BAMUgF,UANV;AAQH;AAzCqC,KAAV;AAAA,CAAzB;;AA4CA,IAAMoC,4DAA0B,SAA1BA,uBAA0B;AAAA,WAAU;AAC7CC,0BAD6C,8BAC1BC,QAD0B,EAChB;AAAA,gBACjB1f,IADiB,GACIuR,KADJ,CACjBvR,IADiB;AAAA,gBACXgS,UADW,GACIT,KADJ,CACXS,UADW;;;AAGzB,gBAAI,CAAChS,KAAKJ,MAAV,EAAkB;AACd,uBAAOoS,UAAP;AACH;;AAED,gBAAM2N,cAAc,uBAChB;AACIvB,yBAAS;AAAA,2BAAOsB,WAAW1f,KAAK0C,MAAL,CAAYgd,QAAZ,CAAX,GAAmC1f,IAA1C;AAAA,iBADb;AAEIiS,+BAAe;AAAA,2BAAMD,UAAN;AAAA;AAFnB,aADgB,EAKhB;AAAA,uBAAQ/P,KAAKmc,OAAL,EAAR;AAAA,aALgB,CAApB;;AAQA,mBAAO,yCAA0BuB,YAAYrV,GAAZ,CAAgB;AAAA,uBAAQnH,KAAK8O,aAAL,EAAR;AAAA,aAAhB,CAA1B,CAAP;AACH;AAjB4C,KAAV;AAAA,CAAhC;;AAoBA,IAAM2N,oDAAsB,SAAtBA,mBAAsB;AAAA,WAAU;AACzCC,gBADyC,oBAChCC,KADgC,EACzB;AACZvO,kBAAMvR,IAAN,CAAWkD,IAAX,CAAgB4c,KAAhB;AACH,SAHwC;AAKzCC,iBALyC,qBAK/B3d,MAL+B,EAKvB;AACdmP,kBAAMnP,MAAN,GAAeA,MAAf;AACH,SAPwC;AASzC4d,oBATyC,wBAS5BF,KAT4B,EASrB;AAChB,iBAAKD,QAAL,CAAcC,KAAd;AACAA,kBAAMC,SAAN,CAAgB,IAAhB;AACH,SAZwC;AAczCjN,mBAdyC,uBAc7B4I,QAd6B,EAcnB;AAClBnK,kBAAM4C,KAAN,GAAc,wCAAsB5C,MAAM4C,KAA5B,EAAmCuH,QAAnC,CAAd;AACH,SAhBwC;AAiBzCuE,6BAjByC,iCAiBnBzM,eAjBmB,EAiBF;AACnCjC,kBAAMiC,eAAN,GAAwBA,eAAxB;AACH;AAnBwC,KAAV;AAAA,CAA5B;;AAsBA,IAAM0M,oDAAsB,SAAtBA,mBAAsB;AAAA,WAC/B1d,OAAO2d,MAAP,CACI,EADJ,EAEIjB,iBAAiB3N,KAAjB,CAFJ,EAGIiO,wBAAwBjO,KAAxB,CAHJ,EAIIqO,oBAAoBrO,KAApB,CAJJ,CAD+B;AAAA,CAA5B;;AAQA,IAAM6O,kDAAqB,SAArBA,kBAAqB,eAAgB;AAC9C,QAAI7O,QAAQyM,kBAAkBqC,YAAlB,CAAZ;AACA,wBAAY9O,KAAZ,EAAsB+L,uBAAuB/L,KAAvB,CAAtB;AACH,CAHM;;AAKA,IAAM+O,4DAA0B,SAA1BA,uBAA0B;AAAA,QAAGnD,iBAAH,SAAGA,iBAAH;AAAA,QAAsBhJ,KAAtB,SAAsBA,KAAtB;AAAA,WACnCgJ,oBAAoBhJ,MAAMyD,WADS;AAAA,CAAhC;;AAGA,IAAM2I,8DAA2B,SAA3BA,wBAA2B;AAAA,QAAGrD,oBAAH,SAAGA,oBAAH;AAAA,QAAyB/I,KAAzB,SAAyBA,KAAzB;AAAA,WACpC+I,uBAAuB/I,MAAMwD,YAA7B,GAA4C,CAACuF,uBAAuB,CAAxB,IAA6B/I,MAAMuD,UAD3C;AAAA,CAAjC;;AAGA,IAAM8I,0CAAiB,SAAjBA,cAAiB;AAAA,WAC1B,IAAIjP,MAAM4C,KAAN,CAAY0D,iBAAhB,GAAoCyI,wBAAwB/O,KAAxB,CADV;AAAA,CAAvB;;AAGA,IAAMkP,4CAAkB,SAAlBA,eAAkB;AAAA,WAC3B,IAAIlP,MAAM4C,KAAN,CAAY2D,eAAhB,GAAkCyI,yBAAyBhP,KAAzB,CADP;AAAA,CAAxB;;AAGA,IAAMQ,oDAAsB,SAAtBA,mBAAsB;AAAA,WAAU;AACzCI,WAAGqO,eAAejP,KAAf,CADsC;AAEzCiB,WAAGiO,gBAAgBlP,KAAhB;AAFsC,KAAV;AAAA,CAA5B;;AAKA,IAAM0M,gDAAoB,SAApBA,iBAAoB;AAAA,wBAAe1M,MAAM8L,eAArB;AAAA,CAA1B;;AAEA,IAAMG,kDAAqB,SAArBA,kBAAqB;AAAA,QAAGV,QAAH,SAAGA,QAAH;AAAA,QAAaoB,UAAb,SAAaA,UAAb;AAAA,QAAyB/J,KAAzB,SAAyBA,KAAzB;AAAA,WAAsC;AACpE5B,WAAGuK,SAASvK,CAAT,GAAa4B,MAAM4D,WAAN,GAAoB,CADgC;AAEpEtF,WAAGqK,SAASrK,CAAT,GAAayL,WAAW1L;AAFyC,KAAtC;AAAA,CAA3B;;AAKA,IAAMkL,8CAAmB,SAAnBA,gBAAmB;AAAA,QAAGZ,QAAH,SAAGA,QAAH;AAAA,QAAaoB,UAAb,SAAaA,UAAb;AAAA,WAA+B;AAC3D3L,WAAGuK,SAASvK,CAD+C;AAE3DE,WAAGqK,SAASrK,CAAT,GAAayL,WAAW1L,CAAX,GAAe;AAF4B,KAA/B;AAAA,CAAzB;;AAKA,IAAMoL,kDAAqB,SAArBA,kBAAqB;AAAA,QAAGd,QAAH,SAAGA,QAAH;AAAA,QAAaoB,UAAb,SAAaA,UAAb;AAAA,WAA+B;AAC7D3L,WAAGuK,SAASvK,CAAT,GAAa2L,WAAW/L,CADkC;AAE7DM,WAAGqK,SAASrK,CAAT,GAAayL,WAAW1L,CAAX,GAAe;AAF8B,KAA/B;AAAA,CAA3B;;AAKA,IAAMsL,gEAA4B,SAA5BA,yBAA4B;AAAA,QAAG3J,KAAH,SAAGA,KAAH;AAAA,QAAU+J,UAAV,SAAUA,UAAV;AAAA,WAA4B;AACjE3L,WAAG4B,MAAM4D,WADwD;AAEjEtF,WAAGyL,WAAW1L,CAAX,GAAe2B,MAAM4D,WAAN,GAAoB;AAF2B,KAA5B;AAAA,CAAlC;;AAKA,IAAMgG,oDAAsB,SAAtBA,mBAAsB;AAAA,QAAGjB,QAAH,UAAGA,QAAH;AAAA,QAAaoB,UAAb,UAAaA,UAAb;AAAA,WAA+B;AAC9DwC,aAAK,EAAEnO,GAAGuK,SAASvK,CAAd,EAAiBE,GAAGqK,SAASrK,CAA7B,EADyD;AAE9DH,aAAK,EAAEC,GAAGuK,SAASvK,CAAT,GAAa2L,WAAW/L,CAA7B,EAAgCM,GAAGqK,SAASrK,CAAT,GAAayL,WAAW1L,CAA3D;AAFyD,KAA/B;AAAA,CAA5B,C;;;;;;;;;;;;;;;;;;ACvRP;;AACA;;AAEA,IAAM+I,oBAAoB,gBAA1B;;kBAEe,6BAAazB,gCAAb,EAA8ByB,iBAA9B,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,gBAA1B;;kBAEe,6BAAa3C,oBAAb,EAAwB2C,iBAAxB,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,aAA1B;;kBAEe,6BAAazB,gCAAb,EAA8ByB,iBAA9B,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,kBAA1B;;kBAEe,6BAAavC,8CAAb,EAAqCuC,iBAArC,C;;;;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AACA;;AAEA;;AASA;;AAEA,IAAMA,oBAAoB,kBAA1B;;AAEA,IAAMoF,8BAA8B,SAA9BA,2BAA8B;AAAA,QAAG7D,QAAH,QAAGA,QAAH;AAAA,QAAaoB,UAAb,QAAaA,UAAb;AAAA,WAA+B;AAC/D3L,WAAGuK,SAASvK,CAAT,GAAa2L,WAAW/L,CADoC;AAE/DM,WAAGqK,SAASrK,CAAT,GAAayL,WAAW1L,CAAX,GAAe;AAFgC,KAA/B;AAAA,CAApC;;AAKA,IAAMkL,mBAAmB,SAAnBA,gBAAmB;AAAA,QAAGZ,QAAH,SAAGA,QAAH;AAAA,QAAaoB,UAAb,SAAaA,UAAb;AAAA,WAA+B;AACpD3L,WAAGuK,SAASvK,CADwC;AAEpDE,WAAGqK,SAASrK,CAAT,GAAayL,WAAW1L,CAAX,GAAe;AAFqB,KAA/B;AAAA,CAAzB;;AAKA,IAAM8K,yBAAyB,SAAzBA,sBAAyB;AAAA,WAAU;AACrCC,mBAAW,iCAAmBhM,KAAnB,CAD0B;AAErCsM,0BAAkB,wCAA0BtM,KAA1B,CAFmB;AAGrCkM,iBAASC,iBAAiBnM,KAAjB,CAH4B;AAIrCoM,mBAAW,mCAAmBpM,KAAnB,CAJ0B;AAKrCS,oBAAY,oCAAoBT,KAApB,CALyB;;AAOrCqP,4BAAoBD,4BAA4BpP,KAA5B;AAPiB,KAAV;AAAA,CAA/B;;AAUA,IAAMsP,2BAA2B,SAA3BA,wBAA2B;AAAA,WAAU;AACvCC,6BADuC,mCACf;AACpB,mBAAOvP,MAAMqP,kBAAb;AACH;AAHsC,KAAV;AAAA,CAAjC;;AAMO,IAAMG,wEAAgC,SAAhCA,6BAAgC;AAAA,WAAU;AACnDC,wCADmD,8CAChB;AAC/B,mBAAO,KAAKvB,kBAAL,CAAwB;AAAA,uBAASK,MAAMvO,KAAN,CAAYtP,IAAZ,CAAiB0C,GAAjB,KAAyBgD,sBAAWqG,UAA7C;AAAA,aAAxB,CAAP;AACH,SAHkD;AAKnDiT,4CALmD,kDAKZ;AACnC,gBAAM9M,QAAQ5C,MAAM4C,KAApB;AAAA,gBACI2I,WAAW,EADf;;AAGAA,qBAASrK,CAAT,GAAalB,MAAMuL,QAAN,CAAerK,CAAf,GAAmBlB,MAAMsM,gBAAN,CAAuBpL,CAAvD;;AAEAqK,qBAASvK,CAAT,GAAa,KAAKyO,gCAAL,GAAwC1O,GAAxC,CAA4CC,CAAzD;AACAuK,qBAASvK,CAAT,IAAc4B,MAAMuF,qBAApB;;AAEA,gBAAMwH,aAAa3P,MAAMuL,QAAN,CAAevK,CAAf,GAAmBhB,MAAM2M,UAAN,CAAiB/L,CAApC,GAAwCgC,MAAM4D,WAAjE;AACA,gBAAI+E,SAASvK,CAAT,IAAc2O,UAAlB,EAA8B;AAC1BpE,yBAASvK,CAAT,GAAa2O,UAAb;AACH;;AAED,mBAAOpE,QAAP;AACH,SApBkD;AAsBnDqE,yBAtBmD,6BAsBjCxc,GAtBiC,EAsB5B;AACnB,mBAAO4M,MAAMvR,IAAN,CAAW0C,MAAX,CAAkB;AAAA,uBAASiQ,MAAMmM,UAAN,OAAuBna,GAAhC;AAAA,aAAlB,EAAuD/E,MAA9D;AACH,SAxBkD;AA0BnDwhB,2BA1BmD,iCA0B7B;AAClB,gBAAMjN,QAAQ5C,MAAM4C,KAApB;AADkB,kCAED5C,MAAMuL,QAFL;AAAA,gBAEVvK,CAFU,mBAEVA,CAFU;AAAA,gBAEPE,CAFO,mBAEPA,CAFO;AAAA,gBAGd4O,CAHc,GAGV9P,MAAM2M,UAAN,CAAiB1L,CAHP;AAAA,gBAIdL,CAJc,GAIVZ,MAAM2M,UAAN,CAAiB/L,CAJP;AAAA,gBAKdlQ,IALc,GAKPsP,MAAMtP,IALC;;;AAOlB,gBAAMqf,OAAOrf,KAAKgG,OAAL,KAAiBxJ,uBAAYkM,sBAA7B,GAAsD,GAAtD,GAA4D,IAAzE;AAAA,gBACI4W,WAAW,GADf;AAAA,gBAEIC,cAAc,GAFlB;;AAIA,mBAAU,4BACNjP,IAAI8O,IAAI,CAAR,GAAYC,KAAK1hB,MAAL,GAAcuU,MAAMyD,WAApB,GAAkC,CADxC,EAENnF,IAAI4O,IAAI,CAAR,GAAYlN,MAAMwD,YAAN,GAAqB,CAF3B,EAGNxD,KAHM,EAINmN,IAJM,CAAV,SAKK,4BACD/O,IAAI8O,IAAI,CAAR,GAAYlN,MAAMyD,WADjB,EAEDnF,IAAI4O,CAAJ,GAAQlN,MAAMyD,WAAN,GAAoB,CAF3B,EAGDzD,KAHC,EAIDoN,QAJC,CALL,UAWI,KAAKJ,iBAAL,CAAuBxZ,sBAAWsG,SAAlC,IACM,4BACIsE,IAAIJ,CAAJ,GAAQgC,MAAMyD,WAAN,GAAoB,CADhC,EAEInF,IAAI4O,IAAI,CAAR,GAAYlN,MAAMyD,WAAN,GAAoB,CAFpC,EAGIzD,KAHJ,EAIIqN,WAJJ,CADN,GAOM,EAlBV;AAoBH,SAzDkD;AA2DnDliB,aA3DmD,iBA2D7CyG,MA3D6C,EA2DrC;AACJ,wBAAQwL,MAAM4C,KAAd;AAAA,mCACS5C,MAAMuL,QADf;AAAA,gBACAvK,CADA,oBACAA,CADA;AAAA,gBACGE,CADH,oBACGA,CADH;AAAA,oCAESlB,MAAM2M,UAFf;AAAA,gBAEA/L,CAFA,qBAEAA,CAFA;AAAA,gBAEGK,CAFH,qBAEGA,CAFH;;;AAIN,gBAAM6O,IAAI7O,CAAV;AAAA,gBACIiP,KAAKjP,IAAI,IAAI2B,MAAMiF,cADvB;;AAGA,gBAAMsI,eAAe;AACjBnP,mBAAGA,IAAI8O,CADU;AAEjB5O,mBAAGA,IAAIgP,KAAK;AAFK,aAArB;;AAKA,yCACM,wCAAoBlP,IAAIC,IAAI,CAA5B,EAA+BC,IAAID,IAAI,CAAvC,EAA0CL,IAAIkP,IAAI,CAAlD,EAAqDI,EAArD,EAAyDtN,KAAzD,CADN,sCAEM,+BAAW5B,CAAX,EAAcE,CAAd,EAAiB4O,CAAjB,EAAoBA,CAApB,EAAuBlN,KAAvB,CAFN,sBAGM,KAAKgL,SAAL,CAAeuC,YAAf,CAHN,sBAIM,KAAKpC,cAAL,CAAoBvZ,MAApB,CAJN,sBAKM,KAAKqb,mBAAL,EALN;AAOH;AA/EkD,KAAV;AAAA,CAAtC;;AAkFP,IAAMpD,oBAAoB,SAApBA,iBAAoB;AAAA,wBACnBzM,KADmB;AAEtBuL,kBAAU,kCAAkBvL,KAAlB,CAFY;AAGtB2M,oBAAY,kCAAoB3M,KAApB;AAHU;AAAA,CAA1B;;AAMO,IAAMkI,8CAAmB,SAAnBA,gBAAmB,eAAgB;AAC5C,QAAIlI,QAAQyM,kBAAkBqC,YAAlB,CAAZ;;AAEA9O,yBAAaA,KAAb,EAAuB+L,uBAAuB/L,KAAvB,CAAvB;;AAEA,WAAO,8BAAYA,KAAZ,EAAmB,CACtB4M,gCADsB,EAEtB0C,wBAFsB,EAGtBX,8BAHsB,EAItBa,6BAJsB,CAAnB,CAAP;AAMH,CAXM;;kBAaQ,6BAAatH,gBAAb,EAA+B8B,iBAA/B,C;;;;;;;;;;;;;;;;;;AChJf;;AACA;;AAEA,IAAMA,oBAAoB,mBAA1B;;kBAEe,6BAAazB,gCAAb,EAA8ByB,iBAA9B,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,mBAA1B;;kBAEe,6BAAa3C,oBAAb,EAAwB2C,iBAAxB,C;;;;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AACA;;AAEA;;AAUA,IAAMA,oBAAoB,gBAA1B;;AAEA,IAAMoG,+BAA+B,SAA/BA,4BAA+B;AAAA,WAAU;AAC3CriB,aAD2C,iBACrCyG,MADqC,EAC7B;AACV,gBAAMoO,QAAQ5C,MAAM4C,KAApB;AAAA,gBACIyN,cAAczN,MAAMgG,MADxB;;AADU,kCAIO5I,MAAMuL,QAJb;AAAA,gBAIFvK,CAJE,mBAIFA,CAJE;AAAA,gBAICE,CAJD,mBAICA,CAJD;AAAA,gBAKND,CALM,GAKFjB,MAAM2M,UAAN,CAAiB1L,CALf;AAAA,gBAMNL,CANM,GAMFZ,MAAM2M,UAAN,CAAiB/L,CAAjB,GAAqB,KAAKyP,YAAYxH,KAAZ,GAAoBwH,YAAYvH,KAArC,CANnB;AAAA,gBAONqH,YAPM,GAOS,EAAEnP,IAAF,EAAKE,IAAL,EAPT;;;AASV,gBAAMoP,UAAU,wCACZtP,IAAIJ,CAAJ,GAAQyP,YAAYvH,KADR,EAEZ5H,CAFY,EAGZmP,YAAYxH,KAHA,EAIZ5H,CAJY,EAKZoP,WALY,CAAhB;AAOA,gBAAME,UAAU,wCACZvP,IAAIJ,CAAJ,GAAQ,IAAIyP,YAAYvH,KAAxB,GAAgCuH,YAAYxH,KADhC,EAEZ3H,CAFY,EAGZmP,YAAYxH,KAHA,EAIZ5H,CAJY,EAKZoP,WALY,CAAhB;;AAQA,2DAEU,wCAAoBrP,CAApB,EAAuBE,CAAvB,EAA0BN,CAA1B,EAA6BK,CAA7B,EAAgC2B,KAAhC,CAFV,4CAIU0N,OAJV,0BAKUC,OALV,yDAOU,KAAK3C,SAAL,CAAeuC,YAAf,CAPV,0BAQU,KAAKpC,cAAL,CAAoBvZ,MAApB,CARV;AAUH;AAnC0C,KAAV;AAAA,CAArC;;AAsCA,IAAMya,iBAAiB,SAAjBA,cAAiB,QAAS;AAC5B,QAAMrM,QAAQ5C,MAAM4C,KAApB;AAAA,QACIgG,SAAShG,MAAMgG,MADnB;;AAGA,WACI,IAAIhG,MAAM0D,iBAAV,GACA,KAAKsC,OAAOC,KAAP,GAAe,CAACD,OAAOE,KAA5B,CADA,GAEA,wCAAwB9I,KAAxB,CAHJ;AAKH,CATD;;AAWA,IAAMQ,sBAAsB,SAAtBA,mBAAsB;AAAA,WAAU;AAClCI,WAAGqO,eAAejP,KAAf,CAD+B;AAElCiB,WAAG,gCAAgBjB,KAAhB;AAF+B,KAAV;AAAA,CAA5B;;AAKA,IAAMyM,oBAAoB,SAApBA,iBAAoB;AAAA,wBACnBzM,KADmB;AAEtBuL,kBAAU,kCAAkBvL,KAAlB,CAFY;AAGtB2M,oBAAYnM,oBAAoBR,KAApB;AAHU;AAAA,CAA1B;;AAMO,IAAM2I,0CAAiB,SAAjBA,cAAiB,eAAgB;AAC1C,QAAI3I,QAAQyM,kBAAkBqC,YAAlB,CAAZ;;AAEA9O,yBAAaA,KAAb,EAAuB,uCAAuBA,KAAvB,CAAvB;;AAEA,WAAO,8BAAYA,KAAZ,EAAmB,CACtB4M,gCADsB,EAEtB+B,8BAFsB,EAGtByB,4BAHsB,CAAnB,CAAP;AAKH,CAVM;;kBAYQ,6BAAazH,cAAb,EAA6BqB,iBAA7B,C;;;;;;;;;;;;;;;;;;ACxFf;;AACA;;AAEA,IAAMA,oBAAoB,mBAA1B;;kBAEe,6BAAazB,gCAAb,EAA8ByB,iBAA9B,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,mBAA1B;;kBAEe,6BAAavC,8CAAb,EAAqCuC,iBAArC,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,iBAA1B;;kBAEe,6BAAa3C,oBAAb,EAAwB2C,iBAAxB,C;;;;;;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AACA;;AAEA;;AASA;;;;AAEA,IAAMA,oBAAoB,aAA1B;;AAEA,IAAMwG,mEACDtjB,uBAAYuM,gBADX,EAC8B,KAD9B,kCAEDvM,uBAAYujB,gBAFX,EAE8B,KAF9B,kCAGDvjB,uBAAYwjB,aAHX,EAG2B,KAH3B,kCAIDxjB,uBAAYyjB,eAJX,EAI6B,OAJ7B,kCAKDzjB,uBAAY0jB,kBALX,EAKgC,OALhC,iBAAN;;AAQA,IAAMC,oBAAoB,SAApBA,iBAAoB;AAAA,QAAGtF,QAAH,QAAGA,QAAH;AAAA,QAAaoB,UAAb,QAAaA,UAAb;AAAA,WAA+B;AACrD3L,WAAGuK,SAASvK,CAAT,GAAa2L,WAAW1L,CAAX,GAAe,CADsB;AAErDC,WAAGqK,SAASrK;AAFyC,KAA/B;AAAA,CAA1B;;AAKA,IAAM6K,yBAAyB,SAAzBA,sBAAyB;AAAA,WAAU;AACrCC,mBAAW,iCAAmBhM,KAAnB,CAD0B;AAErCsM,0BAAkB,wCAA0BtM,KAA1B,CAFmB;AAGrCkM,iBAAS,iCAAiBlM,KAAjB,CAH4B;AAIrCoM,mBAAW,mCAAmBpM,KAAnB,CAJ0B;AAKrCS,oBAAY,oCAAoBT,KAApB,CALyB;;AAOrC8Q,kBAAUD,kBAAkB7Q,KAAlB;AAP2B,KAAV;AAAA,CAA/B;;AAUA,IAAMsP,2BAA2B,SAA3BA,wBAA2B;AAAA,WAAU;AACvCyB,mBADuC,yBACzB;AACV,mBAAO/Q,MAAM8Q,QAAb;AACH,SAHsC;AAKvCrP,gCALuC,sCAKZ;AACvB,mBAAOzB,MAAMgR,qBAAb;AACH;AAPsC,KAAV;AAAA,CAAjC;;AAUA,IAAMC,2BAA2B,SAA3BA,wBAA2B;AAAA,WAAU;AACvCC,mCADuC,uCACXF,qBADW,EACY;AAC/ChR,kBAAMgR,qBAAN,GAA8BA,qBAA9B;AACH,SAHsC;AAKvCnB,2BALuC,iCAKjB;AAClB,gBAAMjN,QAAQ5C,MAAM4C,KAApB;AADkB,kCAED5C,MAAMuL,QAFL;AAAA,gBAEVvK,CAFU,mBAEVA,CAFU;AAAA,gBAEPE,CAFO,mBAEPA,CAFO;AAAA,gBAGd4O,CAHc,GAGV9P,MAAM2M,UAAN,CAAiB1L,CAHP;AAAA,gBAId8O,IAJc,GAIP/P,MAAMpP,UAAN,IAAoB4f,aAAaxQ,MAAMtP,IAAN,CAAWgG,OAAxB,CAApB,IAAwD,KAJjD;;;AAMlB,mBAAO,4BACHsK,IAAI8O,IAAI,CAAR,GAAYC,KAAK1hB,MAAL,GAAcuU,MAAMyD,WAApB,GAAkC,CAD3C,EAEHnF,IAAI4O,IAAI,CAAR,GAAYlN,MAAMwD,YAAN,GAAqB,CAF9B,EAGHxD,KAHG,EAIHmN,IAJG,CAAP;AAMH,SAjBsC;AAmBvChiB,aAnBuC,iBAmBjCyG,MAnBiC,EAmBzB;AACV,gBAAMoO,QAAQ5C,MAAM4C,KAApB;AADU,mCAEO5C,MAAMuL,QAFb;AAAA,gBAEFvK,CAFE,oBAEFA,CAFE;AAAA,gBAECE,CAFD,oBAECA,CAFD;AAAA,oCAGKlB,MAAM2M,UAHX;AAAA,gBAGJ/L,CAHI,qBAGJA,CAHI;AAAA,gBAGDK,CAHC,qBAGDA,CAHC;;;AAKV,gBAAM6O,IAAI7O,CAAV;AAAA,gBACIiP,KAAKjP,IAAI,IAAI2B,MAAMiF,cADvB;;AAGA,gBAAMsI,eAAe;AACjBnP,mBAAGA,IAAI8O,CADU;AAEjB5O,mBAAGA,IAAIgP,KAAK;AAFK,aAArB;;AAKA,2CAEM,wCAAoBlP,IAAIC,IAAI,CAA5B,EAA+BC,IAAID,IAAI,CAAvC,EAA0CL,IAAIkP,IAAI,CAAlD,EAAqDI,EAArD,EAAyDtN,KAAzD,CAFN,sBAGM,+BAAW5B,CAAX,EAAcE,CAAd,EAAiB4O,CAAjB,EAAoBA,CAApB,EAAuBlN,KAAvB,CAHN,wCAKM,KAAKgL,SAAL,CAAeuC,YAAf,CALN,sBAMM,KAAKpC,cAAL,CAAoBvZ,MAApB,CANN,sBAOM,KAAKqb,mBAAL,EAPN;AASH;AAzCsC,KAAV;AAAA,CAAjC;;AA4CA,IAAMnD,oBAAoB,SAApBA,iBAAoB;AAAA,QAAGZ,eAAH,SAAGA,eAAH;AAAA,QAAoBlJ,KAApB,SAAoBA,KAApB;AAAA,WAAiC;AACvD5B,WAAG8K,gBAAgB9K,CADoC;AAEvDE,WAAG4K,gBAAgB5K,CAAhB,GAAoB0B,MAAMqF;AAF0B,KAAjC;AAAA,CAA1B;;AAKA,IAAMwE,oBAAoB,SAApBA,iBAAoB;AAAA,wBACnBzM,KADmB;AAEtBuL,kBAAUmB,kBAAkB1M,KAAlB,CAFY;AAGtB2M,oBAAY,kCAAoB3M,KAApB;AAHU;AAAA,CAA1B;;AAMO,IAAM4H,oCAAc,SAAdA,WAAc,eAAgB;AACvC,QAAI5H,QAAQyM,kBAAkBqC,YAAlB,CAAZ;;AAEA9O,yBAAaA,KAAb,EAAuB+L,uBAAuB/L,KAAvB,CAAvB;;AAEA,WAAO,8BAAYA,KAAZ,EAAmB,CACtB4M,gCADsB,EAEtB0C,wBAFsB,EAGtBX,8BAHsB,EAItBsC,wBAJsB,CAAnB,CAAP;AAMH,CAXM;;kBAaQ,6BAAarJ,WAAb,EAA0BoC,iBAA1B,C;;;;;;;;;;;;;;;;;;ACtHf;;AACA;;AAEA,IAAMA,oBAAoB,gBAA1B;;kBAEe,6BAAa3C,oBAAb,EAAwB2C,iBAAxB,C;;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA;;AAOA,IAAMA,oBAAoB,WAA1B;;AAEA,IAAMmH,yBAAyB,SAAzBA,sBAAyB;AAAA,WAAU;AACrCpjB,aADqC,mBAClB;AAAA,gBAAbyG,MAAa,uEAAJ,EAAI;;AACf,gBAAMoO,QAAQ5C,MAAM4C,KAApB;AAAA,gBACIwO,WAAWxO,MAAM0E,GADrB;AADe,kCAGEtH,MAAMuL,QAHR;AAAA,gBAGPvK,CAHO,mBAGPA,CAHO;AAAA,gBAGJE,CAHI,mBAGJA,CAHI;AAAA,oCAIAlB,MAAM2M,UAJN;AAAA,gBAIT/L,CAJS,qBAITA,CAJS;AAAA,gBAINK,CAJM,qBAINA,CAJM;AAAA,gBAKXvQ,IALW,GAKJsP,MAAMtP,IALF;;;AAOf,kEAEa,wCAAoBsQ,CAApB,EAAuBE,CAAvB,EAA0BN,CAA1B,EAA6BK,CAA7B,EAAgC2B,KAAhC,CAFb,6BAGa,KAAKgL,SAAL,EAHb,8BAKeld,KAAKsL,KAAL,GACM,8BACIgF,IAAIoQ,SAAS7J,MADjB,EAEIrG,IAAID,CAAJ,GAAQmQ,SAAS7J,MAFrB,EAGI6J,SAAS5J,MAHb,EAII4J,QAJJ,CADN,GAOM,EAZrB,8BAca,KAAKrD,cAAL,CAAoBvZ,MAApB,CAdb;AAgBH;AAxBoC,KAAV;AAAA,CAA/B;;AA2BO,IAAM6S,gCAAY,SAAZA,SAAY,eAAgB;AACrC,QAAMrH,QAAQ,mCAAmB8O,YAAnB,CAAd;;AAEA,WAAO,8BAAY9O,KAAZ,EAAmB,CAAC4M,gCAAD,EAAwB+B,8BAAxB,EAA6CwC,sBAA7C,CAAnB,CAAP;AACH,CAJM;;kBAMQ,6BAAa9J,SAAb,EAAwB2C,iBAAxB,C;;;;;;;;;;;;;;;;;;;;;AC7Cf;;AACA;;AACA;;AAEA;;AAUA,IAAMA,oBAAoB,iBAA1B;;AAEA,IAAMqH,gCAAgC,SAAhCA,6BAAgC;AAAA,WAAU;AAC5CtjB,aAD4C,iBACtCyG,MADsC,EAC9B;AACV,gBAAMoO,QAAQ5C,MAAM4C,KAApB;AAAA,gBACI0O,aAAa1O,MAAMmE,KADvB;;AADU,kCAIO/G,MAAMuL,QAJb;AAAA,gBAIFvK,CAJE,mBAIFA,CAJE;AAAA,gBAICE,CAJD,mBAICA,CAJD;AAAA,gBAKND,CALM,GAKFjB,MAAM2M,UAAN,CAAiB1L,CALf;AAAA,gBAMNL,CANM,GAMFZ,MAAM2M,UAAN,CAAiB/L,CAAjB,GAAqB0Q,WAAW9I,aAAhC,GAAgD8I,WAAW7I,KANzD;AAAA,gBAON0H,YAPM,GAOS,EAAEnP,GAAGA,CAAL,EAAQE,IAAR,EAPT;;AASV;;AACA,gBAAMyJ,YAAY,EAAE3J,GAAGsQ,WAAW7I,KAAhB,EAAuBvH,GAAGoQ,WAAW5I,KAArC,EAAlB;;AAEA,gBAAM3B,QAAQ,kCACV,iCACI,CAAC,EAAE/F,GAAG,CAAL,EAAQE,GAAG,CAAX,EAAD,EAAiB,EAAEF,GAAG2J,UAAU3J,CAAf,EAAkBE,GAAGyJ,UAAUzJ,CAAV,GAAc,CAAnC,EAAjB,EAAyD,EAAEF,GAAG,CAAL,EAAQE,GAAGyJ,UAAUzJ,CAArB,EAAzD,CADJ,EAEI;AACIF,mBAAGA,IAAIJ,CAAJ,GAAQ0Q,WAAW9I,aAD1B;AAEItH,mBAAGA,IAAID,IAAI,CAAR,GAAY0J,UAAUzJ,CAAV,GAAc;AAFjC,aAFJ,CADU,EAQVoQ,UARU,CAAd;;AAWA,2DAEU,wCAAoBtQ,CAApB,EAAuBE,CAAvB,EAA0BN,CAA1B,EAA6BK,CAA7B,EAAgC2B,KAAhC,CAFV,4CAIU,4BACE5B,IAAIJ,CADN,EAEEM,IAAID,IAAI,CAAR,GAAYqQ,WAAW9I,aAFzB,EAGExH,IAAIJ,CAAJ,GAAQ0Q,WAAW9I,aAHrB,EAIEtH,IAAID,IAAI,CAAR,GAAYqQ,WAAW9I,aAJzB,EAKE8I,UALF,CAJV,4CAYU,4BACEtQ,IAAIJ,CADN,EAEEM,IAAID,IAAI,CAAR,GAAYqQ,WAAW9I,aAFzB,EAGExH,IAAIJ,CAAJ,GAAQ0Q,WAAW9I,aAHrB,EAIEtH,IAAID,IAAI,CAAR,GAAYqQ,WAAW9I,aAJzB,EAKE8I,UALF,CAZV,4BAoBUvK,KApBV,yDAsBU,KAAK6G,SAAL,CAAeuC,YAAf,CAtBV,0BAuBU,KAAKpC,cAAL,CAAoBvZ,MAApB,CAvBV;AAyBH;AAjD2C,KAAV;AAAA,CAAtC;;AAoDA,IAAMya,iBAAiB,SAAjBA,cAAiB,QAAS;AAC5B,QAAMrM,QAAQ5C,MAAM4C,KAApB;AAAA,QACI0O,aAAa1O,MAAMmE,KADvB;;AAGA,WACI,IAAInE,MAAM0D,iBAAV,GACAgL,WAAW9I,aADX,GAEA8I,WAAW7I,KAFX,GAGA,wCAAwBzI,KAAxB,CAJJ;AAMH,CAVD;;AAYA,IAAMQ,sBAAsB,SAAtBA,mBAAsB;AAAA,WAAU;AAClCI,WAAGqO,eAAejP,KAAf,CAD+B;AAElCiB,WAAG,gCAAgBjB,KAAhB;AAF+B,KAAV;AAAA,CAA5B;;AAKA,IAAMyM,oBAAoB,SAApBA,iBAAoB;AAAA,wBACnBzM,KADmB;AAEtBuL,kBAAU,kCAAkBvL,KAAlB,CAFY;AAGtB2M,oBAAYnM,oBAAoBR,KAApB;AAHU;AAAA,CAA1B;;AAMO,IAAMuI,4CAAkB,SAAlBA,eAAkB,eAAgB;AAC3C,QAAIvI,QAAQyM,kBAAkBqC,YAAlB,CAAZ;;AAEA9O,yBAAaA,KAAb,EAAuB,uCAAuBA,KAAvB,CAAvB;;AAEA,WAAO,8BAAYA,KAAZ,EAAmB,CACtB4M,gCADsB,EAEtB+B,8BAFsB,EAGtB0C,6BAHsB,CAAnB,CAAP;AAKH,CAVM;;kBAYQ,6BAAa9I,eAAb,EAA8ByB,iBAA9B,C;;;;;;;;;;;;;;;;;;;ACvGf;;AAKO,IAAMxJ,oDAAsB,SAAtBA,mBAAsB;AAAA,WAAU;AACzCI,WAAGqO,eAAejP,KAAf,CADsC;AAEzCiB,WAAGiO,gBAAgBlP,KAAhB;AAFsC,KAAV;AAAA,CAA5B;;AAKA,IAAMiP,0CAAiB,SAAjBA,cAAiB;AAAA,WAASC,gBAAgBlP,KAAhB,IAAyB,+BAAwBA,KAAxB,CAAlC;AAAA,CAAvB;AACA,IAAMkP,4CAAkB,SAAlBA,eAAkB;AAAA,WAC3B,IAAIlP,MAAM4C,KAAN,CAAYiF,cAAhB,GAAiC,gCAA0B7H,KAA1B,CADN;AAAA,CAAxB;;AAGA,IAAMiM,kDAAqB,SAArBA,kBAAqB;AAAA,QAAGV,QAAH,QAAGA,QAAH;AAAA,QAAaoB,UAAb,QAAaA,UAAb;AAAA,WAA+B;AAC7D3L,WAAGuK,SAASvK,CAAT,GAAa2L,WAAW1L,CAAX,GAAe,CAD8B;AAE7DC,WAAGqK,SAASrK,CAAT,GAAayL,WAAW1L;AAFkC,KAA/B;AAAA,CAA3B;;AAKA,IAAMsL,gEAA4B,SAA5BA,yBAA4B;AAAA,QAAGI,UAAH,SAAGA,UAAH;AAAA,QAAe/J,KAAf,SAAeA,KAAf;AAAA,WAA4B;AACjE5B,WAAG2L,WAAW1L,CAAX,GAAe,CAAf,GAAmB2B,MAAM4D,WADqC;AAEjEtF,WAAGyL,WAAW1L,CAAX,GAAe2B,MAAM4D,WAAN,GAAoB;AAF2B,KAA5B;AAAA,CAAlC,C;;;;;;;;;;;;;;;;;;;;;ACnBP;;AACA;;AAEA;;AAQA,IAAMwD,oBAAoB,YAA1B;;AAEA,IAAMiC,qBAAqB,SAArBA,kBAAqB,OAAyB;AAAA,QAAtBV,QAAsB,QAAtBA,QAAsB;AAAA,QAAZ3I,KAAY,QAAZA,KAAY;;AAChD,QAAM2O,IAAI3O,MAAM4E,MAAhB;AACA,WAAO,EAAExG,GAAGuK,SAASvK,CAAd,EAAiBE,GAAGqK,SAASrK,CAAT,GAAaqQ,CAAjC,EAAP;AACH,CAHD;;AAKA,IAAMxF,yBAAyB,SAAzBA,sBAAyB;AAAA,WAAU;AACrCC,mBAAWC,mBAAmBjM,KAAnB,CAD0B;AAErCS,oBAAY,oCAAoBT,KAApB;AAFyB,KAAV;AAAA,CAA/B;;AAKA,IAAMwR,sBAAsB,SAAtBA,mBAAsB;AAAA,WAAU;AAClCzjB,aADkC,mBAC1B;AACJ,gBAAM6U,QAAQ5C,MAAM4C,KAApB;AADI,kCAEa5C,MAAMuL,QAFnB;AAAA,gBAEIvK,CAFJ,mBAEIA,CAFJ;AAAA,gBAEOE,CAFP,mBAEOA,CAFP;AAAA,oCAGWlB,MAAM2M,UAHjB;AAAA,gBAGE/L,CAHF,qBAGEA,CAHF;AAAA,gBAGKK,CAHL,qBAGKA,CAHL;AAAA,gBAIAsQ,CAJA,GAII3O,MAAM4E,MAJV;;;AAMJ,gBAAM2I,eAAe,EAAEnP,GAAGA,IAAIuQ,CAAT,EAAYrQ,GAAGA,IAAIqQ,CAAnB,EAArB;;AAEA,0DAES,iCAAavQ,CAAb,EAAgBE,IAAIqQ,CAAJ,GAAQA,IAAI,CAA5B,EAA+B3Q,IAAI2Q,CAAnC,EAAsCtQ,IAAI2B,MAAMjC,OAAN,GAAgB,CAA1D,EAA6DiC,KAA7D,CAFT,yBAGS,8BAAU5B,CAAV,EAAaE,CAAb,EAAgBqQ,CAAhB,EAAmB3O,KAAnB,CAHT,yBAIS,KAAKgL,SAAL,CAAeuC,YAAf,CAJT;AAMH,SAfiC;AAiBlCsB,2BAjBkC,+BAiBdjH,KAjBc,EAiBP;AACvBxK,kBAAMsM,gBAAN,GAAyB9B,KAAzB;AACH;AAnBiC,KAAV;AAAA,CAA5B;;AAsBO,IAAM7C,kCAAa,SAAbA,UAAa,eAAgB;AACtC,QAAI3H,QAAQ,kCAAkB8O,YAAlB,CAAZ;;AAEA9O,yBAAaA,KAAb,EAAuB+L,uBAAuB/L,KAAvB,CAAvB;;AAEA,WAAO,8BAAYA,KAAZ,EAAmB,CAAC4M,gCAAD,EAAwB+B,8BAAxB,EAA6C6C,mBAA7C,CAAnB,CAAP;AACH,CANM;;kBAQQ,6BAAa7J,UAAb,EAAyBqC,iBAAzB,C;;;;;;;;;;;;;;;;;;ACrDf;;AACA;;AAEA,IAAMA,oBAAoB,YAA1B;;kBAEe,6BAAa3C,oBAAb,EAAwB2C,iBAAxB,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,iBAA1B;;kBAEe,6BAAa9B,kCAAb,EAA+B8B,iBAA/B,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,gBAA1B;;kBAEe,6BAAa3C,oBAAb,EAAwB2C,iBAAxB,C;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA,IAAMA,oBAAoB,cAA1B;;kBAEe,6BAAa3C,oBAAb,EAAwB2C,iBAAxB,C;;;;;;;;;;;;;;;;;;;;;;ACLf;;AACA;;AAEA;;AAUA,IAAMA,oBAAoB,wBAA1B;;AAEA,IAAM0H,sCAAsC,SAAtCA,mCAAsC;AAAA,WAAU;AAClD3jB,aADkD,iBAC5CyG,MAD4C,EACpC;AACV,gBAAMoO,QAAQ5C,MAAM4C,KAApB;AADU,kCAEO5C,MAAMuL,QAFb;AAAA,gBAEFvK,CAFE,mBAEFA,CAFE;AAAA,gBAECE,CAFD,mBAECA,CAFD;AAAA,oCAGKlB,MAAM2M,UAHX;AAAA,gBAGJ/L,CAHI,qBAGJA,CAHI;AAAA,gBAGDK,CAHC,qBAGDA,CAHC;AAAA,gBAINkP,YAJM,GAIS,EAAEnP,GAAGA,IAAI4B,MAAM8E,UAAf,EAA2BxG,IAA3B,EAJT;;;AAMV,2DAEU,iCAAaF,CAAb,EAAgBE,CAAhB,EAAmBN,CAAnB,EAAsBK,CAAtB,EAAyB2B,KAAzB,CAFV,gDAIU,4BAAQ5B,IAAI4B,MAAM8E,UAAlB,EAA8BxG,CAA9B,EAAiCF,IAAI4B,MAAM8E,UAA3C,EAAuDxG,IAAID,CAA3D,EAA8D2B,KAA9D,CAJV,0BAKU,4BAAQ5B,IAAIJ,CAAJ,GAAQgC,MAAM8E,UAAtB,EAAkCxG,CAAlC,EAAqCF,IAAIJ,CAAJ,GAAQgC,MAAM8E,UAAnD,EAA+DxG,IAAID,CAAnE,EAAsE2B,KAAtE,CALV,yCAOU,KAAKgL,SAAL,CAAeuC,YAAf,CAPV,0BAQU,KAAKpC,cAAL,CAAoBvZ,MAApB,CARV;AAUH;AAjBiD,KAAV;AAAA,CAA5C;;AAoBA,IAAMya,iBAAiB,SAAjBA,cAAiB;AAAA,WACnB,KAAKjP,MAAM4C,KAAN,CAAY0D,iBAAZ,GAAgCtG,MAAM4C,KAAN,CAAY8E,UAAjD,IAA+D,wCAAwB1H,KAAxB,CAD5C;AAAA,CAAvB;;AAGA,IAAMQ,sBAAsB,SAAtBA,mBAAsB;AAAA,WAAU;AAClCI,WAAGqO,eAAejP,KAAf,CAD+B;AAElCiB,WAAG,gCAAgBjB,KAAhB;AAF+B,KAAV;AAAA,CAA5B;;AAKA,IAAMyM,oBAAoB,SAApBA,iBAAoB;AAAA,wBACnBzM,KADmB;AAEtBuL,kBAAU,kCAAkBvL,KAAlB,CAFY;AAGtB2M,oBAAYnM,oBAAoBR,KAApB;AAHU;AAAA,CAA1B;;AAMO,IAAMyH,0DAAyB,SAAzBA,sBAAyB,eAAgB;AAClD,QAAIzH,QAAQyM,kBAAkBqC,YAAlB,CAAZ;;AAEA9O,yBAAaA,KAAb,EAAuB,uCAAuBA,KAAvB,CAAvB;;AAEA,WAAO,8BAAYA,KAAZ,EAAmB,CACtB4M,gCADsB,EAEtB+B,8BAFsB,EAGtB+C,mCAHsB,CAAnB,CAAP;AAKH,CAVM;;kBAYQ,6BAAajK,sBAAb,EAAqCuC,iBAArC,C;;;;;;;;;;;;;;;;;;;AC7Df;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEO,IAAM2H,4CAAkB,SAAlBA,eAAkB,OAAQ;AACnC,YAAQjhB,KAAKpC,IAAb;AACI,aAAKpB,uBAAY+F,QAAjB;AACI,mBAAOwU,gCAAP;;AAEJ,aAAKva,uBAAY2Q,IAAjB;AACI,mBAAO+J,qBAAP;;AAEJ,aAAK1a,uBAAY6Q,WAAjB;AACI,mBAAOmK,0BAAP;;AAEJ,aAAKhb,uBAAY6P,MAAjB;AACI,mBAAOwL,yBAAP;;AAEJ,aAAKpb,0BAAe0R,UAApB;AACI,mBAAO8J,wBAAP;;AAEJ,aAAKzb,uBAAYsG,iBAAjB;AACI,mBAAOuV,0BAAP;;AAEJ,aAAK7b,uBAAYkR,kBAAjB;AACI,mBAAO4K,2BAAP;;AAEJ,aAAK9b,uBAAY6G,0BAAjB;AACA,aAAK7G,uBAAY4G,wBAAjB;AACI,mBAAOmV,2BAAP;;AAEJ,aAAK/b,uBAAYwG,kBAAjB;AACI,mBAAOwV,2BAAP;;AAEJ,aAAKhc,uBAAY0G,wBAAjB;AACA,aAAK1G,uBAAYyG,gBAAjB;AACI,mBAAOwV,yBAAP;;AAEJ,aAAKjc,uBAAY0Q,eAAjB;AACI,mBAAOwL,wBAAP;;AAEJ,aAAKlc,uBAAYqB,OAAjB;AACI,mBAAOoZ,oBAAP;;AAEJ,aAAKza,uBAAY+Q,aAAjB;AACI,mBAAOoL,sBAAP;;AAEJ,aAAKnc,uBAAYgR,YAAjB;AACI,mBAAOoL,qBAAP;;AAEJ,aAAKpc,uBAAYsQ,gBAAjB;AACI,mBAAO+L,yBAAP;;AAEJ,aAAKrc,uBAAY8Q,KAAjB;AACI,mBAAOwL,wBAAP;;AAEJ,aAAKtc,uBAAYuQ,WAAjB;AACI,mBAAOgM,oBAAP;;AAEJ,aAAKvc,uBAAY4Q,QAAjB;AACI,mBAAO4L,2BAAP;;AAEJ,aAAKxc,uBAAYiG,eAAjB;AACI,mBAAOwW,wBAAP;;AAEJ,aAAKzc,uBAAY6E,eAAjB;AACI,mBAAO6X,wBAAP;;AAEJ;AACI,mBAAOvC,mBAAP;AAhER;AAkEH,CAnEM,C;;;;;;;;;;;;;;;;;;;;;ACxBP;;AACA;;AACA;;;;;;AAIO,IAAMuK,kDAAqB,SAArBA,kBAAqB,CAAClhB,IAAD,EAAO6a,QAAP,EAAiBsG,UAAjB,EAAgC;AAC9D,QAAMzQ,QAAQ,2CAAgB1Q,IAAhB,CAAd;AAAA,QACIohB,aAAaD,WAAWzQ,MAAMqK,iBAAN,EAAX,CADjB;;AAGA,WAAOrK,MAAM1Q,IAAN,EAAY6a,QAAZ,EAAsBuG,UAAtB,CAAP;AACH,CALM;;AAOA,IAAMC,8CAAmB,SAAnBA,gBAAmB,CAACrhB,IAAD,EAAOmhB,UAAP,EAAsB;AAClD,QAAMzQ,QAAQ,2CAAgB1Q,IAAhB,CAAd;AAAA,QACIohB,aAAaD,WAAWzQ,MAAMqK,iBAAN,EAAX,CADjB;;AADkD,6CAIboG,WAAWxJ,cAJE;AAAA,QAI1CC,MAJ0C,yBAI1CA,MAJ0C;AAAA,QAIlC9B,WAJkC,yBAIlCA,WAJkC;;AAKlD,QAAMpY,OAAOgT,MAAM1Q,IAAN,EAAY4X,MAAZ,EAAoBwJ,UAApB,CAAb;;AAEA1jB,SAAKqjB,mBAAL,CAAyBjL,WAAzB;;AAEA,WAAOpY,IAAP;AACH,CAVM;;AAYA,IAAM4jB,wDAAwB,SAAxBA,qBAAwB,CAACxd,MAAD,EAASqd,UAAT,EAAwB;AACzD,QAAMI,uBAAuBJ,WAAW,oCAAX,CAA7B;AAAA,QACIK,cAAcC,oBAAoB3d,MAApB,EAA4Byd,oBAA5B,CADlB;;AAGA,WAAO,4CAAqBzd,MAArB,EAAgC0d,WAAhC,GAA+CD,oBAA/C,CAAP;AACH,CALM;;AAOA,IAAME,oDAAsB,SAAtBA,mBAAsB,OAAqDvP,KAArD,EAA+D;AAAA,QAA5DwP,UAA4D,QAA5DA,UAA4D;AAAA,QAAhDC,QAAgD,QAAhDA,QAAgD;AAAA,QAAtCC,aAAsC,QAAtCA,aAAsC;AAAA,QAAvBpH,SAAuB,QAAvBA,SAAuB;;AAC9F,QAAM1W,SAAS;AACXwW,oBAAY,EADD;AAEXC,oBAAY,EAAEjK,GAAGqR,SAASrR,CAAd,EAAiBE,GAAGmR,SAASnR,CAA7B;AAFD,KAAf;;AAKA,YAAQgK,SAAR;AACI,aAAKN,sBAAWC,KAAhB;AACIrW,mBAAOwW,UAAP,GAAoB,CAAC,EAAEhK,GAAGoR,WAAWpR,CAAhB,EAAmBE,GAAGkR,WAAWlR,CAAjC,EAAD,CAApB;;AAEA,gBAAIoR,aAAJ,EAAmB;AACf9d,uBAAOwW,UAAP,GAAoBxW,OAAOwW,UAAP,CAAkBtZ,MAAlB,CAAyB,CACzC,EAAEsP,GAAGsR,cAActR,CAAnB,EAAsBE,GAAGkR,WAAWlR,CAApC,EADyC,EAEzC,EAAEF,GAAGsR,cAActR,CAAnB,EAAsBE,GAAGmR,SAASnR,CAAlC,EAFyC,EAGzC,EAAEF,GAAGqR,SAASrR,CAAd,EAAiBE,GAAGmR,SAASnR,CAA7B,EAHyC,CAAzB,CAApB;AAKH,aAND,MAMO;AACH1M,uBAAOwW,UAAP,GAAoBxW,OAAOwW,UAAP,CAAkBtZ,MAAlB,CAAyB,CACzC,EAAEsP,GAAGoR,WAAWpR,CAAhB,EAAmBE,GAAGmR,SAASnR,CAA/B,EADyC,EAEzC,EAAEF,GAAGqR,SAASrR,CAAd,EAAiBE,GAAGmR,SAASnR,CAA7B,EAFyC,CAAzB,CAApB;AAIH;AACD;;AAEJ,aAAK0J,sBAAWE,IAAhB;AACItW,mBAAOwW,UAAP,GAAoB,CAChB,EAAEhK,GAAGoR,WAAWpR,CAAhB,EAAmBE,GAAGkR,WAAWlR,CAAjC,EADgB,EAEhB,EAAEF,GAAGsR,cAActR,CAAd,GAAkB4B,MAAMuE,cAA7B,EAA6CjG,GAAGkR,WAAWlR,CAA3D,EAFgB,EAGhB,EAAEF,GAAGsR,cAActR,CAAd,GAAkB4B,MAAMuE,cAA7B,EAA6CjG,GAAGmR,SAASnR,CAAzD,EAHgB,EAIhB,EAAEF,GAAGqR,SAASrR,CAAT,GAAa4B,MAAMuE,cAAxB,EAAwCjG,GAAGmR,SAASnR,CAApD,EAJgB,CAApB;AAMA;;AAEJ,aAAK0J,sBAAWG,IAAhB;AACIvW,mBAAOwW,UAAP,GAAoB,CAChB,EAAEhK,GAAGoR,WAAWpR,CAAhB,EAAmBE,GAAGkR,WAAWlR,CAAjC,EADgB,EAEhB,EAAEF,GAAGsR,cAActR,CAAd,GAAkB4B,MAAMuE,cAA7B,EAA6CjG,GAAGkR,WAAWlR,CAA3D,EAFgB,EAGhB;AACIF,mBAAGsR,cAActR,CAAd,GAAkB4B,MAAMuE,cAD/B;AAEIjG,mBAAGmR,SAASnR,CAAT,GAAa0B,MAAMuE;AAF1B,aAHgB,EAOhB,EAAEnG,GAAGqR,SAASrR,CAAd,EAAiBE,GAAGmR,SAASnR,CAAT,GAAa0B,MAAMuE,cAAvC,EAPgB,EAQhB,EAAEnG,GAAGqR,SAASrR,CAAd,EAAiBE,GAAGmR,SAASnR,CAA7B,EARgB,CAApB;AAUA;AAtCR;;AAyCA,WAAO1M,MAAP;AACH,CAhDM,C;;;;;;;;;;;;;;;;;;;;;AChCP;;AACA;;AACA;;AACA;;AAEO,IAAM+d,oDAAsB,SAAtBA,mBAAsB,CAAC5kB,QAAD,EAAWkkB,UAAX,EAA0B;AACzD,QAAMW,MAAM,uBAAZ;;AAEA,QAAMC,kBAAkBC,qBAAqB/kB,QAArB,EAA+BkkB,UAA/B,CAAxB;AACA,QAAMc,cAAcC,iBAAiBH,gBAAgBrkB,IAAjC,EAAuCyjB,UAAvC,CAApB;;AAEAW,QAAIpS,SAAJ,CAAcqS,gBAAgBI,IAA9B,EAAoCzS,SAApC,CAA8CqS,gBAAgBrkB,IAA9D;AACAokB,QAAInS,mBAAJ,CAAwBsS,WAAxB;;AAEA,WAAOH,GAAP;AACH,CAVM;;AAYA,IAAME,sDAAuB,SAAvBA,oBAAuB,CAAC/kB,QAAD,EAAWkkB,UAAX,EAA0B;AAC1D,QAAMzjB,OAAO,qCAAiBT,QAAjB,EAA2BkkB,UAA3B,CAAb;AAAA,QACItG,wBAAgBnd,KAAK2e,mBAAL,EAAhB,CADJ;AAAA,QAEI+F,aAAa,EAFjB;;AAIA,QAAIC,mBAAJ;;AAEA,0DACIplB,QADJ,EAEIS,IAFJ,EAGI,UAAC4kB,UAAD,EAAaC,WAAb,EAA6B;AACzB1H,iBAASvK,CAAT,IAAciS,YAAYlG,mBAAZ,GAAkC/L,CAAhD;AACH,KALL,EAMI,UAACtQ,IAAD,EAAOuiB,WAAP,EAAuB;AACnB1H,iBAASrK,CAAT,IAAcgS,2BAA2BrB,UAA3B,EAAuCnhB,IAAvC,EAA6CqiB,UAA7C,CAAd;;AAEA;AACA,YACIE,YAAY5F,WAAZ,OAA8BngB,uBAAY6Q,WAA1C,IACArN,KAAK0C,GAAL,KAAagD,sBAAWsG,SADxB,IAEA,CAACuW,YAAYrD,iBAAZ,CAA8BxZ,sBAAWsG,SAAzC,CAHL,EAIE;AACE,gBAAMyW,iBAAiBF,YAAYvD,oCAAZ,EAAvB;AACAnE,qBAASvK,CAAT,GAAamS,eAAenS,CAAf,GAAmBiS,YAAY9F,SAAZ,EAAhC;AACA5B,qBAASrK,CAAT,GAAaiS,eAAejS,CAA5B;AACH;;AAED,YAAME,QAAQ,uCAAmB1Q,IAAnB,EAAyB,EAAEsQ,GAAGuK,SAASvK,CAAd,EAAiBE,GAAGqK,SAASrK,CAA7B,EAAzB,EAA2D2Q,UAA3D,CAAd;;AAEAtG,iBAASvK,CAAT,GAAaI,MAAMqM,WAAN,GAAoBzM,CAAjC;AACAuK,iBAASrK,CAAT,GAAaE,MAAMqM,WAAN,GAAoBvM,CAAjC;;AAEA4R,mBAAWnhB,IAAX,CAAgByP,KAAhB;AACA6R,oBAAYxE,YAAZ,CAAyBrN,KAAzB;AACAmK,iBAASrK,CAAT,IAAcE,MAAM2L,mBAAN,GAA4B7L,CAA1C;;AAEA6R,qBAAariB,IAAb;AACA,eAAO0Q,KAAP;AACH,KA/BL,EAgCI,UAAC4R,UAAD,EAAaC,WAAb,EAA6B;AACzB,YAAID,WAAW1kB,IAAX,KAAoBpB,uBAAY6Q,WAApC,EAAiD;AAC7CwN,qBAASrK,CAAT,GAAa+R,YAAY/E,kBAAZ,GAAiCnN,GAAjC,CAAqCG,CAArC,GAAyC+R,YAAY9F,SAAZ,EAAtD;AACH;;AAED5B,iBAASvK,CAAT,GAAaiS,YAAYxF,WAAZ,GAA0BzM,CAAvC;AACH,KAtCL;;AAyCA,WAAO;AACH6R,cAAMC,UADH;AAEH1kB,cAAMA;AAFH,KAAP;AAIH,CApDM;;AAsDP,IAAM8kB,6BAA6B,SAA7BA,0BAA6B,CAACtQ,KAAD,EAAQlS,IAAR,EAAkC;AAAA,QAApBqiB,UAAoB,uEAAP,EAAO;;AACjE,QAAMK,mBAAmB,CACrBlmB,uBAAY+F,QADS,EAErB/F,uBAAYmK,oBAFS,EAGrBnK,uBAAYmP,mBAHS,EAIrBnP,uBAAYoK,yBAJS,EAKrBpK,uBAAYsG,iBALS,EAMrBtG,uBAAYwG,kBANS,EAOrBxG,uBAAY4G,wBAPS,EAQrB5G,uBAAY6G,0BARS,CAAzB;;AAWA,QACIqf,iBAAiB7hB,QAAjB,CAA0Bb,KAAKpC,IAA/B,KACA,CAAC8kB,iBAAiB7hB,QAAjB,CAA0BwhB,WAAWzkB,IAArC,CADD,IAEAoC,KAAKmI,cAAL,KAAwB3L,uBAAY6E,eAHxC,EAIE;AACE,eAAO6Q,MAAMiD,SAAN,CAAgBc,qBAAvB;AACH;;AAED,WAAO,CAAP;AACH,CArBD;;AAuBO,IAAMiM,8CAAmB,SAAnBA,gBAAmB,CAAC/kB,UAAD,EAAagkB,UAAb,EAA4B;AACxD,QAAMc,cAAc,EAApB;AAAA,QACIU,YAAY,SAAZA,SAAY,SAAU;AAClB,YAAMC,aAAa,0CAAsB9e,MAAtB,EAA8Bqd,UAA9B,CAAnB;AACAc,oBAAYhhB,IAAZ,CAAiB2hB,UAAjB;;AAEA,eAAOA,UAAP;AACH,KANL;;AAQA,QAAIC,cAAc,IAAlB;AAAA,QACIC,oBAAoB,IADxB;;AAGA,0DACI3lB,UADJ,EAEIA,UAFJ,EAGI,uBAAe,CAAE,CAHrB,EAII,UAACuT,KAAD,EAAQ6R,WAAR,EAAwB;AACpBM,sBAAcnS,KAAd;;AAEA,YAAM5M,SAASif,sBAAsBrS,KAAtB,EAA6B6R,WAA7B,CAAf;AAAA,YACIlM,QAAQsM,UAAU7e,MAAV,CADZ;;AAGA4M,cAAMsN,qBAAN,CAA4B3H,KAA5B;;AAEA,eAAO3F,KAAP;AACH,KAbL,EAcI,uBAAe;AACXoS,4BAAoBP,WAApB;AACA,YAAIA,YAAY5F,WAAZ,OAA8BngB,uBAAY2Q,IAA9C,EAAoD;;AAFzC,oCAIKoV,YAAY/E,kBAAZ,EAJL;AAAA,YAIHnN,GAJG,yBAIHA,GAJG;;AAMXkS,oBAAY/B,2BAAZ,CACImC,UAAU;AACNjB,wBAAYmB,YAAYzG,YAAZ,EADN;AAENuF,sBAAUY,YAAYlC,WAAZ,EAFJ;AAGNuB,2BAAe,EAAEtR,GAAGD,IAAIC,CAAT,EAHT;AAINkK,uBAAWN,sBAAWG;AAJhB,SAAV,CADJ;AAQH,KA5BL,EA6BI;AACI8B,iBAAS;AAAA,mBAAQnc,KAAKmc,OAAL,EAAR;AAAA;AADb,KA7BJ;;AAkCA,WAAO8F,WAAP;AACH,CA/CM;;AAiDP,IAAMe,YAAY,SAAZA,SAAY,CAACC,OAAD,EAAUC,SAAV,EAAwB;AACtC,QACI,CACI1mB,uBAAYyG,gBADhB,EAEIzG,uBAAY0G,wBAFhB,EAGI1G,uBAAYiG,eAHhB,EAIE5B,QAJF,CAIWoiB,QAAQtG,WAAR,EAJX,CADJ,EAME;AACE,eAAO,IAAP;AACH;;AAED,QACI,CACIngB,uBAAYmK,oBADhB,EAEInK,uBAAYmP,mBAFhB,EAGInP,uBAAY+F,QAHhB,EAII/F,uBAAYoK,yBAJhB,EAKE/F,QALF,CAKWoiB,QAAQtG,WAAR,EALX,KAMA,CACIngB,uBAAY6E,eADhB,EAEI7E,uBAAYwF,mBAFhB,EAGIxF,uBAAYiF,qBAHhB,EAIIjF,uBAAYkO,cAJhB,EAKE7J,QALF,CAKWqiB,UAAUvG,WAAV,EALX,CAPJ,EAaE;AACE,eAAO,IAAP;AACH;AACJ,CA3BD;;AA6BA,IAAMoG,wBAAwB,SAAxBA,qBAAwB,CAACE,OAAD,EAAUC,SAAV,EAAwB;AAClD,QAAMpf,SAAS;AACX6d,kBAAUsB,QAAQjG,UAAR,EADC;AAEXxC,mBAAWN,sBAAWC,KAFX;AAGXM,iBAASuI,UAAUC,OAAV,EAAmBC,SAAnB;AAHE,KAAf;;AAMA,QACID,QAAQpG,UAAR,OAAyBnX,sBAAWsG,SAApC,IACAkX,UAAUlE,oCAFd,EAGE;AACE,YAAM4C,gBAAgBsB,UAAUlE,oCAAV,EAAtB;;AAEAlb,eAAO4d,UAAP,GAAoBwB,UAAUrE,qBAAV,EAApB;AACA/a,eAAO8d,aAAP,GAAuB,EAAEtR,GAAGsR,cAActR,CAAnB,EAAvB;AACH,KARD,MAQO;AACHxM,eAAO4d,UAAP,GAAoBwB,UAAU1G,YAAV,EAApB;AACH;;AAED,WAAO1Y,MAAP;AACH,CApBD,C;;;;;;;;;;;;;;;;;AC5KO,IAAMtH,oCAAc;AACvB+F,cAAU,UADa;AAEvBoJ,yBAAqB,oBAFE;AAGvBhF,0BAAsB,qBAHC;AAIvB3E,yBAAqB,oBAJE;AAKvBP,2BAAuB,sBALA;AAMvB2J,uBAAmB,kBANI;AAOvBtE,0BAAsB,qBAPC;AAQvByF,uBAAmB,kBARI;AASvBlL,qBAAiB,gBATM;AAUvBqJ,oBAAgB,eAVO;AAWvByC,UAAM,MAXiB;AAYvB4S,sBAAkB,gBAZK;AAavBC,mBAAe,cAbQ;AAcvBC,qBAAiB,gBAdM;AAevBC,wBAAoB,kBAfG;AAgBvB9S,cAAU,mBAhBa;AAiBvBC,iBAAa,aAjBU;AAkBvBN,iBAAa,YAlBU;AAmBvBD,sBAAkB,iBAnBK;AAoBvBjP,aAAS,SApBc;AAqBvBwO,YAAQ,iBArBe;AAsBvBiB,WAAO,gBAtBgB;AAuBvBC,mBAAe,cAvBQ;AAwBvBC,kBAAc,aAxBS;AAyBvBC,oBAAgB,eAzBO;AA0BvBP,qBAAiB,gBA1BM;AA2BvBQ,wBAAoB,mBA3BG;AA4BvB1G,gBAAY,YA5BW;AA6BvB4F,sBAAkB,iBA7BK;AA8BvBjE,uBAAmB,kBA9BI;AA+BvBlG,qBAAiB,gBA/BM;AAgCvBsF,mBAAe,cAhCQ;AAiCvBuE,uBAAmB,kBAjCI;AAkCvB6W,0BAAsB,qBAlCC;AAmCvBtW,sBAAkB,iBAnCK;AAoCvBnE,4BAAwB,uBApCD;AAqCvB8C,oBAAgB,eArCO;AAsCvBmC,qBAAiB,gBAtCM;AAuCvByV,qBAAiB,gBAvCM;AAwCvB5W,wBAAoB,mBAxCG;;AA0CvB;AACA5F,+BAA2B,yBA3CJ;AA4CvB5D,wBAAoB,mBA5CG;AA6CvBE,8BAA0B,wBA7CH;AA8CvBD,sBAAkB,iBA9CK;AA+CvBG,8BAA0B,wBA/CH;AAgDvBC,gCAA4B,0BAhDL;AAiDvBP,uBAAmB,kBAjDI;AAkDvBgF,kBAAc,aAlDS;AAmDvBiB,sBAAkB,gBAnDK;AAoDvB4D,oBAAgB,eApDO;AAqDvBnF,qBAAiB,gBArDM;AAsDvBkF,mBAAe,cAtDQ;AAuDvBlC,oBAAgB,eAvDO;AAwDvBC,mBAAe,cAxDQ;AAyDvBgC,wBAAoB;AAzDG,CAApB;;AA4DA,IAAM/G,kCAAa;AACtBK,UAAM,MADgB;AAEtBlI,aAAS,SAFa;AAGtBkO,gBAAY,YAHU;AAItBC,eAAW,WAJW;AAKtBiB,UAAM;AALgB,CAAnB;;AAQA,IAAMiN,kCAAa;AACtBC,WAAO,OADe;AAEtBC,UAAM,MAFgB;AAGtBiJ,QAAI,IAHkB;AAItBhJ,UAAM;AAJgB,CAAnB;;AAOA,IAAMpS,sDAAuB;AAChCC,iBAAa,aADmB;AAEhCob,YAAQ;AAFwB,CAA7B;;AAKA,IAAM7mB,0CAAiB;AAC1B0R,gBAAY,YADc;AAE1BoV,YAAQ;AAFkB,CAAvB,C;;;;;;;;;;;;;;;;;;;AChFP;;;;;;;;AAEO,IAAMC,oCAAc,SAAdA,WAAc,CAAClU,KAAD,EAAQmU,cAAR,EAA2B;AAClD,WAAOljB,OAAO2d,MAAP,CAAcne,KAAd,CAAoB,IAApB,GAA2B,EAAEuP,YAAF,EAA3B,4BAAyCmU,eAAepb,GAAf,CAAmB;AAAA,eAAM9I,GAAG+P,KAAH,CAAN;AAAA,KAAnB,CAAzC,GAAP;AACH,CAFM;;AAIA,IAAMoU,wDAAwB,SAAxBA,qBAAwB,CAACC,WAAD,EAAcvd,MAAd;AAAA,WAAyB,yBAAMud,WAAN,EAAmBvd,MAAnB,CAAzB;AAAA,CAA9B,C;;;;;;;;;;;;;;;;;ACNA,IAAMwd,8BAAW,SAAXA,QAAW,CAACvjB,IAAD,EAAuC;AAAA,QAAhC8b,OAAgC,uEAAtB;AAAA,eAAQnc,KAAKjC,IAAb;AAAA,KAAsB;;AAC3D,QAAI8lB,WAAW,EAAf;;AAEA,OAAG7iB,MAAH,CAAUX,IAAV,EAAgBM,OAAhB,CAAwB,gBAAQ;AAC5B,YAAM5C,OAAOoe,QAAQnc,IAAR,CAAb;;AAEA,YAAIjC,QAAQA,KAAKJ,MAAjB,EAAyB;AACrBkmB,uBAAWA,SAAS7iB,MAAT,CAAgBhB,IAAhB,EAAsB4jB,SAAS7lB,IAAT,EAAeoe,OAAf,CAAtB,CAAX;AACH,SAFD,MAEO;AACH0H,qBAAS5iB,IAAT,CAAcjB,IAAd;AACH;AACJ,KARD;;AAUA,WAAO6jB,QAAP;AACH,CAdM,C;;;;;;;;;;;;;;;;;ACAA,IAAMC,gEAA4B,SAA5BA,yBAA4B,OAAQ;AAC7C,QAAI,CAAC3B,IAAD,IAAS,CAACA,KAAKxkB,MAAnB,EAA2B;AACvB,cAAM,IAAIomB,KAAJ,CAAU,wBAAV,CAAN;AACH;;AAED,QAAMC,QAAQ7B,KAAK,CAAL,CAAd;AACA,QAAI8B,OAAOD,MAAMvF,GAAN,CAAUnO,CAArB;AAAA,QACI4T,OAAOF,MAAM3T,GAAN,CAAUC,CADrB;AAAA,QAEI6T,OAAOH,MAAMvF,GAAN,CAAUjO,CAFrB;AAAA,QAGI4T,OAAOJ,MAAM3T,GAAN,CAAUG,CAHrB;;AAKA2R,SAAKxhB,OAAL,CAAa,gBAAkB;AAAA,YAAf8d,GAAe,QAAfA,GAAe;AAAA,YAAVpO,GAAU,QAAVA,GAAU;;AAC3B,YAAIoO,IAAInO,CAAJ,GAAQ2T,IAAZ,EAAkB;AACdA,mBAAOxF,IAAInO,CAAX;AACH;;AAED,YAAImO,IAAIjO,CAAJ,GAAQ2T,IAAZ,EAAkB;AACdA,mBAAO1F,IAAIjO,CAAX;AACH;;AAED,YAAIH,IAAIC,CAAJ,GAAQ4T,IAAZ,EAAkB;AACdA,mBAAO7T,IAAIC,CAAX;AACH;;AAED,YAAID,IAAIG,CAAJ,GAAQ4T,IAAZ,EAAkB;AACdA,mBAAO/T,IAAIG,CAAX;AACH;AACJ,KAhBD;;AAkBA,WAAO;AACHiO,aAAK,EAAEnO,GAAG2T,IAAL,EAAWzT,GAAG2T,IAAd,EADF;AAEH9T,aAAK,EAAEC,GAAG4T,IAAL,EAAW1T,GAAG4T,IAAd;AAFF,KAAP;AAIH,CAjCM;;AAmCA,IAAMC,gDAAoB,SAApBA,iBAAoB,CAACzK,MAAD,EAAS0K,WAAT;AAAA,WAC7B,GAAGtjB,MAAH,CAAU4Y,MAAV,EAAkBvR,GAAlB,CAAsB;AAAA,eAAU;AAC5BiI,eAAGwJ,MAAMxJ,CAAN,GAAUgU,YAAYhU,CADG;AAE5BE,eAAGsJ,MAAMtJ,CAAN,GAAU8T,YAAY9T;AAFG,SAAV;AAAA,KAAtB,CAD6B;AAAA,CAA1B,C;;;;;;;;;;;;;;;;;ACnCA,IAAM+T,wCAAgB,SAAhBA,aAAgB;AAAA,WAAS;AAClChW,eAAO,CAD2B;AAElCiW,eAFkC,qBAExB;AACN,mBAAOrC,KAAK,KAAK5T,KAAL,EAAL,CAAP;AACH,SAJiC;AAKlCkW,aALkC,mBAK1B;AACJ,iBAAKlW,KAAL,GAAa,CAAb;AACH;AAPiC,KAAT;AAAA,CAAtB,C;;;;;;;;;;;;;;;;;ACAA,IAAMmW,8BAAW,SAAXA,QAAW,UAAW;AAC/BC,YAAQC,KAAR,CAAchlB,OAAd;AACH,CAFM,C;;;;;;;;;;;;;;;;;;;ACAP;;;;;;AAEO,IAAMilB,kCAAa,SAAbA,UAAa,GAAM;AAC5B,WAAO,uCAAuCC,OAAvC,CAA+C,OAA/C,EAAwD,aAAK;AAChE,YAAMjE,IAAK1Q,KAAK4U,MAAL,KAAgB,EAAjB,GAAuB,CAAjC;AAAA,YACI3a,IAAI4a,MAAM,GAAN,GAAYnE,CAAZ,GAAiBA,IAAI,GAAL,GAAY,GADpC;AAEA,eAAOzW,EAAE6a,QAAF,CAAW,EAAX,CAAP;AACH,KAJM,CAAP;AAKH,CANM;;AAQA,IAAMC,gCAAY,SAAZA,SAAY,OAAQ;AAC7B,QAAMC,QAAQ,CAACnlB,IAAD,CAAd;AACA,QAAI6G,mBAAiB7G,KAAKlC,IAAtB,MAAJ;;AAEA,WAAOqnB,MAAMxnB,MAAb,EAAqB;AACjB,YAAIuD,OAAOikB,MAAMC,KAAN,EAAX;;AAEA,YAAIlkB,IAAJ,EAAU;AACN2F,kBAAM3F,KAAKpD,IAAL,GAAYoD,KAAKpD,IAAL,CAAU,CAAV,CAAZ,GAA2B,GAAjC;;AAEA,gBAAIoD,KAAKf,MAAT,EAAiB;AACbglB,sBAAMlkB,IAAN,CAAWC,KAAKf,MAAhB;AACH;AACJ;AACJ;;AAED,WAAO0G,GAAGie,OAAH,CAAW,KAAX,EAAkB,EAAlB,EAAsBO,WAAtB,EAAP;AACH,CAjBM;;AAmBA,IAAMC,4CAAkB,SAAlBA,eAAkB,CAACC,GAAD,EAAMC,aAAN,EAAqBC,0BAArB,EAAoD;AAC/E,QAAMC,YAAYH,IAAI5nB,MAAtB;;AAEA,QAAI+nB,aAAaF,aAAjB,EAAgC,OAAO,CAACD,GAAD,CAAP;;AAEhC,WAAO,CAACA,IAAII,KAAJ,CAAU,CAAV,EAAaH,aAAb,IAA8B,KAA/B,CAAP;AACA;;AAEA,QAAII,QAAQ,EAAZ;AAAA,QACIC,uBAAuB,CAD3B;AAAA,QAEIC,WAAWL,2BAA2BjB,OAA3B,EAFf;;AAIA,WAAOqB,uBAAuBH,SAA9B,EAAyC;AACrC,YAAMK,gBAAgBR,IAAI5hB,OAAJ,CAAYmiB,QAAZ,EAAsBD,oBAAtB,CAAtB;;AAEA,YAAIE,kBAAkB,CAAC,CAAvB,EAA0B;AACtBH,kBAAM3kB,IAAN,CAAWskB,IAAII,KAAJ,CAAUE,oBAAV,EAAgCE,gBAAgBD,SAASnoB,MAAzD,CAAX;AACAkoB,oCAAwBE,gBAAgBD,SAASnoB,MAAjD;AACH,SAHD,MAGO;AACH;AACA;AACAioB,kBAAM3kB,IAAN,CAAWskB,IAAII,KAAJ,CAAUE,oBAAV,EAAgCN,IAAI5nB,MAApC,CAAX;AACAkoB,mCAAuBN,IAAI5nB,MAA3B;AACH;AACJ;;AAED,WAAOioB,KAAP;AACH,CA3BM;;AA6BA,IAAMI,kEAA6B,SAA7BA,0BAA6B;AAAA,WACtC7D,KAAK5d,MAAL,CAAY,UAAC8L,GAAD,EAAM4V,OAAN,EAAkB;AAC1B,YAAMC,gBAAgB,2BAAYD,OAAZ,CAAtB;AACA,eAAOC,iBAAiB7V,GAAjB,GAAuB6V,aAAvB,GAAuC7V,GAA9C;AACH,KAHD,EAGG,CAHH,CADsC;AAAA,CAAnC,C;;;;;;;;;;;;;;;;;AC1DP,IAAM8V,oBAAoB,CACtB;AACIC,UAAM,WADV;AAEIC,QAAI;AAFR,CADsB,EAKtB;AACID,UAAM,aADV;AAEIC,QAAI;AAFR,CALsB,EAStB;AACID,UAAM,aADV;AAEIC,QAAI;AAFR,CATsB,EAatB;AACID,UAAM,aADV;AAEIC,QAAI;AAFR,CAbsB,EAiBtB;AACID,UAAM,eADV;AAEIC,QAAI;AAFR,CAjBsB,CAA1B;;AAuBO,IAAMC,kEAA6B,SAA7BA,0BAA6B,QAAS;AAC/C,WAAOH,kBAAkB9d,GAAlB,CACH;AAAA,eAAS6J,MAAMhR,KAAKklB,IAAX,IAAsBllB,KAAKmlB,EAA3B,SAAiCnU,MAAMhR,KAAKklB,IAAX,CAAjC,GAAsD,IAA/D;AAAA,KADG,EAGF3lB,MAHE,CAGK;AAAA,eAAKC,CAAL;AAAA,KAHL,EAIF6H,IAJE,CAIG,IAJH,CAAP;AAKH,CANM;;AAQA,IAAMge,kEAA6B,SAA7BA,0BAA6B,QAAS;AAC/C,WAAOJ,kBAAkB9d,GAAlB,CACH;AAAA,eAAS6J,MAAMhR,KAAKklB,IAAX,IAAsBllB,KAAKmlB,EAA3B,UAAkCnU,MAAMhR,KAAKklB,IAAX,CAAlC,SAAwD,IAAjE;AAAA,KADG,EAGF3lB,MAHE,CAGK;AAAA,eAAKC,CAAL;AAAA,KAHL,EAIF6H,IAJE,CAIG,GAJH,CAAP;AAKH,CANM;;AAQA,IAAMie,kCAAa,SAAbA,UAAa,CAAClW,CAAD,EAAIE,CAAJ,EAAON,CAAP,EAAUK,CAAV,EAAa2B,KAAb,EAAuB;AAC7C,iCAA2B5B,CAA3B,UAAgCE,IAAID,IAAI,CAAxC,WAA6CD,IAAIJ,IAAI,CAArD,UAA0DM,CAA1D,UAA+DF,IAAIJ,CAAnE,WAAwEM,IAAID,IAAI,CAAhF,WAAqFD,IACjFJ,IAAI,CADR,WACaM,IAAID,CADjB,+BAEiB+V,2BAA2BpU,KAA3B,CAFjB;AAGH,CAJM;;AAMA,IAAMuU,oDAAsB,SAAtBA,mBAAsB,CAACnW,CAAD,EAAIE,CAAJ,EAAON,CAAP,EAAUK,CAAV,EAAa2B,KAAb,EAAuB;AACtD,yBAAmB5B,CAAnB,aAA4BE,CAA5B,8BACiBN,CADjB,kBAC+BK,CAD/B,2BAEc2B,MAAM8D,WAFpB,cAEwC9D,MAAM8D,WAF9C,8BAGiBsQ,2BAA2BpU,KAA3B,CAHjB;AAIH,CALM;;AAOA,IAAMwU,sCAAe,SAAfA,YAAe,CAACpW,CAAD,EAAIE,CAAJ,EAAON,CAAP,EAAUK,CAAV,EAAa2B,KAAb,EAAuB;AAC/C,yBAAmB5B,CAAnB,aAA4BE,CAA5B,8BACiBN,CADjB,kBAC+BK,CAD/B,8BAEiB+V,2BAA2BpU,KAA3B,CAFjB;AAGH,CAJM;;AAMA,IAAMyU,4BAAU,SAAVA,OAAU,CAACC,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,EAAiB7U,KAAjB,EAA2B;AAC9C,0BAAoB0U,EAApB,cAA+BC,EAA/B,cAA0CC,EAA1C,cAAqDC,EAArD,kCACqBT,2BAA2BpU,KAA3B,CADrB;AAEH,CAHM;;AAKA,IAAM8U,gCAAY,SAAZA,SAAY,CAAC1W,CAAD,EAAIE,CAAJ,EAAOqQ,CAAP,EAAU3O,KAAV,EAAoB;AACzC,4BAAsB5B,CAAtB,cAAgCE,CAAhC,aAAyCqQ,CAAzC,0BACayF,2BAA2BpU,KAA3B,CADb;AAEH,CAHM;;AAKA,IAAM+U,4BAAU,SAAVA,OAAU,CAAC3W,CAAD,EAAIE,CAAJ,EAAO0B,KAAP,EAAcmN,IAAd,EAAuB;AAC1C,yBAAmB/O,CAAnB,aAA4BE,CAA5B,gCACmB0B,MAAMqD,UADzB,qBACmDrD,MAAMsD,QADzD,gBAEItD,MAAM+B,SAFV,UAGKoL,IAHL;AAIH,CALM;;AAOA,IAAM6H,wCAAgB,SAAhBA,aAAgB,CAACtN,MAAD,EAAS1H,KAAT,EAAmB;AAC5C,QAAMiV,WAAWvN,OACZvR,GADY,CACR,UAACyR,KAAD,EAAQpZ,CAAR,EAAc;AACf,YAAI,CAACA,CAAL,EAAQ,aAAWoZ,MAAMxJ,CAAjB,UAAuBwJ,MAAMtJ,CAA7B;;AAER,qBAAWsJ,MAAMxJ,CAAjB,UAAuBwJ,MAAMtJ,CAA7B;AACH,KALY,EAMZjI,IANY,CAMP,GANO,CAAjB;;AAQA,yBAAmB4e,QAAnB,sBACMZ,2BAA2BrU,KAA3B,CADN;AAEH,CAXM;;AAaA,IAAMkV,wCAAgB,SAAhBA,aAAgB,CAACxN,MAAD,EAAS1H,KAAT,EAAmB;AAC5C,QAAMiV,WAAWvN,OACZvR,GADY,CACR,UAACyR,KAAD,EAAQpZ,CAAR,EAAc;AACf,YAAI,CAACA,CAAL,EAAQ,aAAWoZ,MAAMxJ,CAAjB,UAAuBwJ,MAAMtJ,CAA7B;;AAER,YAAI6W,gBAAgBzN,OAAOlZ,IAAI,CAAX,CAApB;;AAEA,YAAIA,KAAK,CAAT,EAAY;AACR,mBAAO4mB,gBAAgBxN,KAAhB,EAAuBuN,aAAvB,EAAsCnV,MAAMsE,eAA5C,CAAP;AACH;;AAED,qBAAW6Q,cAAc/W,CAAzB,SAA8B+W,cAAc7W,CAA5C,0BACM+W,kBAAkBzN,KAAlB,EAAyBuN,aAAzB,EAAwCnV,MAAMsE,eAA9C,CADN,0BAEM8Q,gBAAgBxN,KAAhB,EAAuBuN,aAAvB,EAAsC,IAAInV,MAAMsE,eAAhD,CAFN;AAGH,KAbY,EAcZjO,IAdY,CAcP,GAdO,CAAjB;;AAgBA,yBAAmB4e,QAAnB,qCACwBb,2BAA2BpU,KAA3B,CADxB;AAEH,CAnBM;;AAqBP,IAAMoV,kBAAkB,SAAlBA,eAAkB,CAACxN,KAAD,EAAQuN,aAAR,EAAuBvQ,MAAvB,EAAkC;AACtD,QAAIgD,MAAMxJ,CAAN,KAAY+W,cAAc/W,CAA9B,EAAiC;AAC7B,qBAAWwJ,MAAMxJ,CAAjB,SAAsBkX,8BAA8B1N,MAAMtJ,CAApC,EAAuC6W,cAAc7W,CAArD,EAAwDsG,MAAxD,CAAtB;AACH;;AAED,QAAIgD,MAAMtJ,CAAN,KAAY6W,cAAc7W,CAA9B,EAAiC;AAC7B,qBAAWgX,8BAA8B1N,MAAMxJ,CAApC,EAAuC+W,cAAc/W,CAArD,EAAwDwG,MAAxD,CAAX,SAA8EgD,MAAMtJ,CAApF;AACH;AACJ,CARD;;AAUA,IAAMgX,gCAAgC,SAAhCA,6BAAgC,CAACC,UAAD,EAAaC,kBAAb,EAAiC5Q,MAAjC;AAAA,WAClC2Q,aAAaC,kBAAb,GAAkCD,aAAa3Q,MAA/C,GAAwD2Q,aAAa3Q,MADnC;AAAA,CAAtC;;AAGA,IAAMyQ,oBAAoB,SAApBA,iBAAoB,CAACzN,KAAD,EAAQuN,aAAR,EAAuBvQ,MAAvB,EAAkC;AACxD,QAAIgD,MAAMxJ,CAAN,KAAY+W,cAAc/W,CAA9B,EAAiC;AAC7B,eAAU+W,cAAc/W,CAAxB,SAA6BqX,oBAAoB7N,MAAMtJ,CAA1B,EAA6B6W,cAAc7W,CAA3C,EAA8CsG,MAA9C,CAA7B;AACH;;AAED,QAAIgD,MAAMtJ,CAAN,KAAY6W,cAAc7W,CAA9B,EAAiC;AAC7B,eAAUmX,oBAAoB7N,MAAMxJ,CAA1B,EAA6B+W,cAAc/W,CAA3C,EAA8CwG,MAA9C,CAAV,SAAmEuQ,cAAc7W,CAAjF;AACH;AACJ,CARD;;AAUA,IAAMmX,sBAAsB,SAAtBA,mBAAsB,CAACF,UAAD,EAAaC,kBAAb,EAAiC5Q,MAAjC;AAAA,WACxB2Q,aAAaC,kBAAb,GAAkCA,qBAAqB5Q,MAAvD,GAAgE4Q,qBAAqB5Q,MAD7D;AAAA,CAA5B,C;;;;;;;;;;;;;;;;;;;;ACpIO,IAAM8Q,4CAAkB,SAAlBA,eAAkB,CAACvnB,IAAD,EAAO8E,MAAP,EAAe0iB,MAAf,EAAuBjiB,OAAvB,EAAiD;AAAA,QAAjBkiB,OAAiB,uEAAP,EAAO;;AAC5E,QAAM3L,UAAU2L,QAAQ3L,OAAR,IAAoB;AAAA,eAAQnc,KAAKjC,IAAb;AAAA,KAApC;AACAoH,WAAO9E,IAAP;;AAEA8b,YAAQ9b,IAAR,EAAcM,OAAd,CAAsB,gBAAQ;AAC1BknB,eAAO7nB,IAAP;;AAEA,YAAImc,QAAQnc,IAAR,CAAJ,EAAmB;AACf4nB,4BAAgB5nB,IAAhB,EAAsBmF,MAAtB,EAA8B0iB,MAA9B,EAAsCjiB,OAAtC,EAA+CkiB,OAA/C;AACH;AACJ,KAND;;AAQAliB,YAAQvF,IAAR;AACH,CAbM;;AAeA,IAAM0nB,gCAAY,SAAZA,SAAY,CAAC1nB,IAAD,EAAOd,EAAP,EAA2C;AAAA,QAAhC4c,OAAgC,uEAAtB;AAAA,eAAQnc,KAAKjC,IAAb;AAAA,KAAsB;;AAChE,QAAIonB,QAAQ,GAAGnkB,MAAH,CAAUX,IAAV,CAAZ;;AAEA,WAAO8kB,MAAMxnB,MAAb,EAAqB;AACjB,YAAIqC,OAAOmlB,MAAMC,KAAN,EAAX;;AAEA7lB,WAAGS,IAAH;;AAEA,YAAMgoB,WAAW7L,QAAQnc,IAAR,CAAjB;AACA,YAAIgoB,QAAJ,EAAc;AACV7C,iDAAYA,KAAZ,sBAAsB6C,QAAtB;AACH;AACJ;AACJ,CAbM;;AAeA,IAAMC,4CAAkB,SAAlBA,eAAkB,CAAC5nB,IAAD,EAAOd,EAAP,EAAc;AACzC,QAAM2oB,SAAS,EAAf;;AAEAH,cAAU1nB,IAAV,EAAgB,gBAAQ;AACpB,YAAId,GAAGS,IAAH,CAAJ,EAAc;AACVkoB,mBAAOjnB,IAAP,CAAYjB,IAAZ;AACH;AACJ,KAJD;;AAMA,WAAOkoB,MAAP;AACH,CAVM,C;;;;;;;;;;;;;;;;;;;AC9BP;;AACA;;AAEO,IAAMC,8CAAmB,SAAnBA,gBAAmB,CAAC9nB,IAAD,EAAO3C,IAAP,EAAa0qB,QAAb,EAAuBP,MAAvB,EAA+BQ,SAA/B,EAA0CP,OAA1C,EAAsD;AAClF,QAAMQ,gBAAgB,sCAAtB;AACA,QAAIzF,cAAcnlB,IAAlB;;AAEA,oCACI2C,IADJ,EAEI,sBAAc;AACVioB,sBAAcnjB,MAAd,CAAqB0d,WAArB;AACAuF,iBAAS9F,UAAT,EAAqBgG,cAAcjjB,UAAd,EAArB;AACH,KALL,EAMI,gBAAQ;AACJwd,sBAAcgF,OAAO7nB,IAAP,EAAasoB,cAAcjjB,UAAd,EAAb,CAAd;AACH,KARL,EASI,sBAAc;AACVijB,sBAAcjjB,UAAd,MAA8BgjB,UAAU/F,UAAV,EAAsBgG,cAAcjjB,UAAd,EAAtB,CAA9B;AACAijB,sBAAc1iB,OAAd;AACH,KAZL,EAaIkiB,OAbJ;AAeH,CAnBM,C;;;;;;;;;;;;;;;;;ACHA,IAAMS,sCAAe,SAAfA,YAAe;AAAA,WAAU;AAClCpG,cAAMqG,QAAQ,CAACA,KAAD,CAAR,GAAkB,EADU;;AAGlCnjB,kBAHkC,wBAGrB;AACT,gBAAI,CAAC,KAAK8c,IAAL,CAAUxkB,MAAf,EAAuB;AACvB,mBAAO,KAAKwkB,IAAL,CAAU,KAAKA,IAAL,CAAUxkB,MAAV,GAAmB,CAA7B,CAAP;AACH,SANiC;AAQlCwH,cARkC,kBAQ3BsjB,IAR2B,EAQrB;AACT,iBAAKtG,IAAL,CAAUlhB,IAAV,CAAewnB,IAAf;AACH,SAViC;AAYlC7iB,eAZkC,qBAYxB;AACN,iBAAKuc,IAAL,CAAUuG,GAAV;AACH;AAdiC,KAAV;AAAA,CAArB,C","file":"js2flowchart.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"js2flowchart\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"js2flowchart\"] = factory();\n\telse\n\t\troot[\"js2flowchart\"] = factory();\n})((typeof window !== 'undefined' ? window : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","import FlowTreeBuilder, {\n    createFlowTreeModifier as createFlowTreeModifierFromBuilder,\n\n    ABSTRACTION_LEVELS,\n    MODIFIER_PRESETS,\n    DEFINED_MODIFIERS\n} from 'builder/FlowTreeBuilder';\nimport SVGRender, { ShapesTreeEditor } from 'render/svg/SVGRender';\nimport PresentationGenerator from 'presentation-generator/PresentationGenerator';\nimport { TOKEN_TYPES, MODIFIED_TYPES } from 'shared/constants';\n\nexport const createFlowTreeBuilder = FlowTreeBuilder;\nexport const createFlowTreeModifier = createFlowTreeModifierFromBuilder;\n\nexport const createSVGRender = SVGRender;\nexport const createShapesTreeEditor = ShapesTreeEditor;\n\nexport const createPresentationGenerator = PresentationGenerator;\n\nexport { ABSTRACTION_LEVELS, DEFINED_MODIFIERS, MODIFIER_PRESETS, TOKEN_TYPES, MODIFIED_TYPES };\n\nexport const convertCodeToSvg = (code, printConfig) => convertFlowTreeToSvg(convertCodeToFlowTree(code), printConfig);\n\nexport const convertCodeToFlowTree = (code) => {\n    const flowTreeBuilder = createFlowTreeBuilder();\n\n    return flowTreeBuilder.build(code);\n};\n\nexport const convertFlowTreeToSvg = (flowTree, printConfig) => {\n    const svgRender = createSVGRender();\n\n    const shapesTree = svgRender.buildShapesTree(flowTree);\n\n    return shapesTree.print(printConfig);\n};\n","'use strict';\nmodule.exports = function () {\n\treturn /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;\n};\n","'use strict';\n\nfunction assembleStyles () {\n\tvar styles = {\n\t\tmodifiers: {\n\t\t\treset: [0, 0],\n\t\t\tbold: [1, 22], // 21 isn't widely supported and 22 does the same thing\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolors: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\t\t\tgray: [90, 39]\n\t\t},\n\t\tbgColors: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49]\n\t\t}\n\t};\n\n\t// fix humans\n\tstyles.colors.grey = styles.colors.gray;\n\n\tObject.keys(styles).forEach(function (groupName) {\n\t\tvar group = styles[groupName];\n\n\t\tObject.keys(group).forEach(function (styleName) {\n\t\t\tvar style = group[styleName];\n\n\t\t\tstyles[styleName] = group[styleName] = {\n\t\t\t\topen: '\\u001b[' + style[0] + 'm',\n\t\t\t\tclose: '\\u001b[' + style[1] + 'm'\n\t\t\t};\n\t\t});\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t});\n\n\treturn styles;\n}\n\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (rawLines, lineNumber, colNumber) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  colNumber = Math.max(colNumber, 0);\n\n  var highlighted = opts.highlightCode && _chalk2.default.supportsColor || opts.forceColor;\n  var chalk = _chalk2.default;\n  if (opts.forceColor) {\n    chalk = new _chalk2.default.constructor({ enabled: true });\n  }\n  var maybeHighlight = function maybeHighlight(chalkFn, string) {\n    return highlighted ? chalkFn(string) : string;\n  };\n  var defs = getDefs(chalk);\n  if (highlighted) rawLines = highlight(defs, rawLines);\n\n  var linesAbove = opts.linesAbove || 2;\n  var linesBelow = opts.linesBelow || 3;\n\n  var lines = rawLines.split(NEWLINE);\n  var start = Math.max(lineNumber - (linesAbove + 1), 0);\n  var end = Math.min(lines.length, lineNumber + linesBelow);\n\n  if (!lineNumber && !colNumber) {\n    start = 0;\n    end = lines.length;\n  }\n\n  var numberMaxWidth = String(end).length;\n\n  var frame = lines.slice(start, end).map(function (line, index) {\n    var number = start + 1 + index;\n    var paddedNumber = (\" \" + number).slice(-numberMaxWidth);\n    var gutter = \" \" + paddedNumber + \" | \";\n    if (number === lineNumber) {\n      var markerLine = \"\";\n      if (colNumber) {\n        var markerSpacing = line.slice(0, colNumber - 1).replace(/[^\\t]/g, \" \");\n        markerLine = [\"\\n \", maybeHighlight(defs.gutter, gutter.replace(/\\d/g, \" \")), markerSpacing, maybeHighlight(defs.marker, \"^\")].join(\"\");\n      }\n      return [maybeHighlight(defs.marker, \">\"), maybeHighlight(defs.gutter, gutter), line, markerLine].join(\"\");\n    } else {\n      return \" \" + maybeHighlight(defs.gutter, gutter) + line;\n    }\n  }).join(\"\\n\");\n\n  if (highlighted) {\n    return chalk.reset(frame);\n  } else {\n    return frame;\n  }\n};\n\nvar _jsTokens = require(\"js-tokens\");\n\nvar _jsTokens2 = _interopRequireDefault(_jsTokens);\n\nvar _esutils = require(\"esutils\");\n\nvar _esutils2 = _interopRequireDefault(_esutils);\n\nvar _chalk = require(\"chalk\");\n\nvar _chalk2 = _interopRequireDefault(_chalk);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getDefs(chalk) {\n  return {\n    keyword: chalk.cyan,\n    capitalized: chalk.yellow,\n    jsx_tag: chalk.yellow,\n    punctuator: chalk.yellow,\n\n    number: chalk.magenta,\n    string: chalk.green,\n    regex: chalk.magenta,\n    comment: chalk.grey,\n    invalid: chalk.white.bgRed.bold,\n    gutter: chalk.grey,\n    marker: chalk.red.bold\n  };\n}\n\nvar NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\nvar JSX_TAG = /^[a-z][\\w-]*$/i;\n\nvar BRACKET = /^[()\\[\\]{}]$/;\n\nfunction getTokenType(match) {\n  var _match$slice = match.slice(-2),\n      offset = _match$slice[0],\n      text = _match$slice[1];\n\n  var token = (0, _jsTokens.matchToToken)(match);\n\n  if (token.type === \"name\") {\n    if (_esutils2.default.keyword.isReservedWordES6(token.value)) {\n      return \"keyword\";\n    }\n\n    if (JSX_TAG.test(token.value) && (text[offset - 1] === \"<\" || text.substr(offset - 2, 2) == \"</\")) {\n      return \"jsx_tag\";\n    }\n\n    if (token.value[0] !== token.value[0].toLowerCase()) {\n      return \"capitalized\";\n    }\n  }\n\n  if (token.type === \"punctuator\" && BRACKET.test(token.value)) {\n    return \"bracket\";\n  }\n\n  return token.type;\n}\n\nfunction highlight(defs, text) {\n  return text.replace(_jsTokens2.default, function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var type = getTokenType(args);\n    var colorize = defs[type];\n    if (colorize) {\n      return args[0].split(NEWLINE).map(function (str) {\n        return colorize(str);\n      }).join(\"\\n\");\n    } else {\n      return args[0];\n    }\n  });\n}\n\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _trimRight = _interopRequireDefault(require(\"trim-right\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SPACES_RE = /^[ \\t]+$/;\n\nvar Buffer = function () {\n  function Buffer(map) {\n    Object.defineProperty(this, \"_map\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"_buf\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_last\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: \"\"\n    });\n    Object.defineProperty(this, \"_queue\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_position\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: {\n        line: 1,\n        column: 0\n      }\n    });\n    Object.defineProperty(this, \"_sourcePosition\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: {\n        identifierName: null,\n        line: null,\n        column: null,\n        filename: null\n      }\n    });\n    this._map = map;\n  }\n\n  var _proto = Buffer.prototype;\n\n  _proto.get = function get() {\n    this._flush();\n\n    var map = this._map;\n    var result = {\n      code: (0, _trimRight.default)(this._buf.join(\"\")),\n      map: null,\n      rawMappings: map && map.getRawMappings()\n    };\n\n    if (map) {\n      Object.defineProperty(result, \"map\", {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          return this.map = map.get();\n        },\n        set: function set(value) {\n          Object.defineProperty(this, \"map\", {\n            value: value,\n            writable: true\n          });\n        }\n      });\n    }\n\n    return result;\n  };\n\n  _proto.append = function append(str) {\n    this._flush();\n\n    var _sourcePosition = this._sourcePosition,\n        line = _sourcePosition.line,\n        column = _sourcePosition.column,\n        filename = _sourcePosition.filename,\n        identifierName = _sourcePosition.identifierName;\n\n    this._append(str, line, column, identifierName, filename);\n  };\n\n  _proto.queue = function queue(str) {\n    if (str === \"\\n\") {\n      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {\n        this._queue.shift();\n      }\n    }\n\n    var _sourcePosition2 = this._sourcePosition,\n        line = _sourcePosition2.line,\n        column = _sourcePosition2.column,\n        filename = _sourcePosition2.filename,\n        identifierName = _sourcePosition2.identifierName;\n\n    this._queue.unshift([str, line, column, identifierName, filename]);\n  };\n\n  _proto._flush = function _flush() {\n    var item;\n\n    while (item = this._queue.pop()) {\n      this._append.apply(this, item);\n    }\n  };\n\n  _proto._append = function _append(str, line, column, identifierName, filename) {\n    if (this._map && str[0] !== \"\\n\") {\n      this._map.mark(this._position.line, this._position.column, line, column, identifierName, filename);\n    }\n\n    this._buf.push(str);\n\n    this._last = str[str.length - 1];\n\n    for (var i = 0; i < str.length; i++) {\n      if (str[i] === \"\\n\") {\n        this._position.line++;\n        this._position.column = 0;\n      } else {\n        this._position.column++;\n      }\n    }\n  };\n\n  _proto.removeTrailingNewline = function removeTrailingNewline() {\n    if (this._queue.length > 0 && this._queue[0][0] === \"\\n\") {\n      this._queue.shift();\n    }\n  };\n\n  _proto.removeLastSemicolon = function removeLastSemicolon() {\n    if (this._queue.length > 0 && this._queue[0][0] === \";\") {\n      this._queue.shift();\n    }\n  };\n\n  _proto.endsWith = function endsWith(suffix) {\n    if (suffix.length === 1) {\n      var last;\n\n      if (this._queue.length > 0) {\n        var str = this._queue[0][0];\n        last = str[str.length - 1];\n      } else {\n        last = this._last;\n      }\n\n      return last === suffix;\n    }\n\n    var end = this._last + this._queue.reduce(function (acc, item) {\n      return item[0] + acc;\n    }, \"\");\n\n    if (suffix.length <= end.length) {\n      return end.slice(-suffix.length) === suffix;\n    }\n\n    return false;\n  };\n\n  _proto.hasContent = function hasContent() {\n    return this._queue.length > 0 || !!this._last;\n  };\n\n  _proto.source = function source(prop, loc) {\n    if (prop && !loc) return;\n    var pos = loc ? loc[prop] : null;\n    this._sourcePosition.identifierName = loc && loc.identifierName || null;\n    this._sourcePosition.line = pos ? pos.line : null;\n    this._sourcePosition.column = pos ? pos.column : null;\n    this._sourcePosition.filename = loc && loc.filename || null;\n  };\n\n  _proto.withSource = function withSource(prop, loc, cb) {\n    if (!this._map) return cb();\n    var originalLine = this._sourcePosition.line;\n    var originalColumn = this._sourcePosition.column;\n    var originalFilename = this._sourcePosition.filename;\n    var originalIdentifierName = this._sourcePosition.identifierName;\n    this.source(prop, loc);\n    cb();\n    this._sourcePosition.line = originalLine;\n    this._sourcePosition.column = originalColumn;\n    this._sourcePosition.filename = originalFilename;\n    this._sourcePosition.identifierName = originalIdentifierName;\n  };\n\n  _proto.getCurrentColumn = function getCurrentColumn() {\n    var extra = this._queue.reduce(function (acc, item) {\n      return item[0] + acc;\n    }, \"\");\n\n    var lastIndex = extra.lastIndexOf(\"\\n\");\n    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;\n  };\n\n  _proto.getCurrentLine = function getCurrentLine() {\n    var extra = this._queue.reduce(function (acc, item) {\n      return item[0] + acc;\n    }, \"\");\n\n    var count = 0;\n\n    for (var i = 0; i < extra.length; i++) {\n      if (extra[i] === \"\\n\") count++;\n    }\n\n    return this._position.line + count;\n  };\n\n  return Buffer;\n}();\n\nexports.default = Buffer;","\"use strict\";\n\nexports.__esModule = true;\nexports.File = File;\nexports.Program = Program;\nexports.BlockStatement = BlockStatement;\nexports.Noop = Noop;\nexports.Directive = Directive;\nObject.defineProperty(exports, \"DirectiveLiteral\", {\n  enumerable: true,\n  get: function get() {\n    return _types.StringLiteral;\n  }\n});\n\nvar _types = require(\"./types\");\n\nfunction File(node) {\n  this.print(node.program, node);\n}\n\nfunction Program(node) {\n  this.printInnerComments(node, false);\n  this.printSequence(node.directives, node);\n  if (node.directives && node.directives.length) this.newline();\n  this.printSequence(node.body, node);\n}\n\nfunction BlockStatement(node) {\n  this.token(\"{\");\n  this.printInnerComments(node);\n  var hasDirectives = node.directives && node.directives.length;\n\n  if (node.body.length || hasDirectives) {\n    this.newline();\n    this.printSequence(node.directives, node, {\n      indent: true\n    });\n    if (hasDirectives) this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.removeTrailingNewline();\n    this.source(\"end\", node.loc);\n    if (!this.endsWith(\"\\n\")) this.newline();\n    this.rightBrace();\n  } else {\n    this.source(\"end\", node.loc);\n    this.token(\"}\");\n  }\n}\n\nfunction Noop() {}\n\nfunction Directive(node) {\n  this.print(node.value, node);\n  this.semicolon();\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;\nexports.ClassBody = ClassBody;\nexports.ClassProperty = ClassProperty;\nexports.ClassMethod = ClassMethod;\nexports._classMethodHead = _classMethodHead;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction ClassDeclaration(node, parent) {\n  if (!t.isExportDefaultDeclaration(parent) && !t.isExportNamedDeclaration(parent)) {\n    this.printJoin(node.decorators, node);\n  }\n\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"class\");\n\n  if (node.id) {\n    this.space();\n    this.print(node.id, node);\n  }\n\n  this.print(node.typeParameters, node);\n\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass, node);\n    this.print(node.superTypeParameters, node);\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ClassBody(node) {\n  this.token(\"{\");\n  this.printInnerComments(node);\n\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.indent();\n    this.printSequence(node.body, node);\n    this.dedent();\n    if (!this.endsWith(\"\\n\")) this.newline();\n    this.rightBrace();\n  }\n}\n\nfunction ClassProperty(node) {\n  this.printJoin(node.decorators, node);\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key, node);\n    this.token(\"]\");\n  } else {\n    this._variance(node);\n\n    this.print(node.key, node);\n  }\n\n  if (node.optional) {\n    this.token(\"?\");\n  }\n\n  this.print(node.typeAnnotation, node);\n\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ClassMethod(node) {\n  this._classMethodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _classMethodHead(node) {\n  this.printJoin(node.decorators, node);\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this._methodHead(node);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.UnaryExpression = UnaryExpression;\nexports.DoExpression = DoExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ThisExpression = ThisExpression;\nexports.Super = Super;\nexports.Decorator = Decorator;\nexports.CallExpression = CallExpression;\nexports.Import = Import;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.AssignmentPattern = AssignmentPattern;\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.BindExpression = BindExpression;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.AwaitExpression = exports.YieldExpression = void 0;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar n = _interopRequireWildcard(require(\"../node\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction UnaryExpression(node) {\n  if (node.operator === \"void\" || node.operator === \"delete\" || node.operator === \"typeof\") {\n    this.word(node.operator);\n    this.space();\n  } else {\n    this.token(node.operator);\n  }\n\n  this.print(node.argument, node);\n}\n\nfunction DoExpression(node) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ParenthesizedExpression(node) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.startTerminatorless(true);\n    this.print(node.argument, node);\n    this.endTerminatorless();\n    this.token(node.operator);\n  }\n}\n\nfunction ConditionalExpression(node) {\n  this.print(node.test, node);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate, node);\n}\n\nfunction NewExpression(node, parent) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !t.isCallExpression(parent, {\n    callee: node\n  }) && !t.isMemberExpression(parent) && !t.isNewExpression(parent)) {\n    return;\n  }\n\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nfunction SequenceExpression(node) {\n  this.printList(node.expressions, node);\n}\n\nfunction ThisExpression() {\n  this.word(\"this\");\n}\n\nfunction Super() {\n  this.word(\"super\");\n}\n\nfunction Decorator(node) {\n  this.token(\"@\");\n  this.print(node.expression, node);\n  this.newline();\n}\n\nfunction CallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nfunction Import() {\n  this.word(\"import\");\n}\n\nfunction buildYieldAwait(keyword) {\n  return function (node) {\n    this.word(keyword);\n\n    if (node.delegate) {\n      this.token(\"*\");\n    }\n\n    if (node.argument) {\n      this.space();\n      var terminatorState = this.startTerminatorless();\n      this.print(node.argument, node);\n      this.endTerminatorless(terminatorState);\n    }\n  };\n}\n\nvar YieldExpression = buildYieldAwait(\"yield\");\nexports.YieldExpression = YieldExpression;\nvar AwaitExpression = buildYieldAwait(\"await\");\nexports.AwaitExpression = AwaitExpression;\n\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\n\nfunction ExpressionStatement(node) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\n\nfunction AssignmentPattern(node) {\n  this.print(node.left, node);\n  if (node.left.optional) this.token(\"?\");\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n}\n\nfunction AssignmentExpression(node, parent) {\n  var parens = this.inForStatementInitCounter && node.operator === \"in\" && !n.needsParens(node, parent);\n\n  if (parens) {\n    this.token(\"(\");\n  }\n\n  this.print(node.left, node);\n  this.space();\n\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n\n  this.space();\n  this.print(node.right, node);\n\n  if (parens) {\n    this.token(\")\");\n  }\n}\n\nfunction BindExpression(node) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\n\nfunction MemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && t.isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  var computed = node.computed;\n\n  if (t.isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    if (!node.optional) {\n      this.token(\".\");\n    }\n\n    this.print(node.property, node);\n  }\n}\n\nfunction MetaProperty(node) {\n  this.print(node.meta, node);\n  this.token(\".\");\n  this.print(node.property, node);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareFunction = DeclareFunction;\nexports.InferredPredicate = InferredPredicate;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeParameter = TypeParameter;\nexports.OpaqueType = OpaqueType;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _types.NumericLiteral;\n  }\n});\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _types.StringLiteral;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar _modules = require(\"./modules\");\n\nvar _types = require(\"./types\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\n\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\n\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\n\nfunction DeclareClass(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"class\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction DeclareFunction(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n\n  this.semicolon();\n}\n\nfunction InferredPredicate() {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nfunction DeclaredPredicate(node) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value, node);\n  this.token(\")\");\n}\n\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nfunction DeclareOpaqueType(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.OpaqueType(node);\n}\n\nfunction DeclareVariable(node, parent) {\n  if (!t.isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.apply(this, arguments);\n}\n\nfunction DeclareExportAllDeclaration() {\n  this.word(\"declare\");\n  this.space();\n\n  _modules.ExportAllDeclaration.apply(this, arguments);\n}\n\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    var declar = node.declaration;\n    this.print(declar, node);\n    if (!t.isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ExistsTypeAnnotation() {\n  this.token(\"*\");\n}\n\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n\n  this.token(\")\");\n\n  if (parent.type === \"ObjectTypeCallProperty\" || parent.type === \"DeclareFunction\") {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction _interfaceish(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction _variance(node) {\n  if (node.variance) {\n    if (node.variance.kind === \"plus\") {\n      this.token(\"+\");\n    } else if (node.variance.kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n\n  this._interfaceish(node);\n}\n\nfunction andSeparator() {\n  this.space();\n  this.token(\"&\");\n  this.space();\n}\n\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\n\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\n\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\n\nfunction NullableTypeAnnotation(node) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\n\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\n\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\n\nfunction TupleTypeAnnotation(node) {\n  this.token(\"[\");\n  this.printList(node.types, node);\n  this.token(\"]\");\n}\n\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\n\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\n\nfunction TypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TypeParameterInstantiation(node) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nfunction TypeParameter(node) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype, node);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype, node);\n  }\n\n  this.semicolon();\n}\n\nfunction ObjectTypeAnnotation(node) {\n  var _this = this;\n\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  var props = node.properties.concat(node.callProperties || [], node.indexers || []);\n\n  if (props.length) {\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines: function addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      indent: true,\n      statement: true,\n      iterator: function iterator() {\n        if (props.length !== 1) {\n          _this.token(\",\");\n\n          _this.space();\n        }\n      }\n    });\n    this.space();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.token(\"[\");\n  this.print(node.id, node);\n  this.token(\":\");\n  this.space();\n  this.print(node.key, node);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  this._variance(node);\n\n  this.print(node.key, node);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.token(\".\");\n  this.print(node.id, node);\n}\n\nfunction orSeparator() {\n  this.space();\n  this.token(\"|\");\n  this.space();\n}\n\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\n\nfunction TypeCastExpression(node) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}","\"use strict\";\n\nexports.__esModule = true;\n\nvar _templateLiterals = require(\"./template-literals\");\n\nObject.keys(_templateLiterals).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _templateLiterals[key];\n    }\n  });\n});\n\nvar _expressions = require(\"./expressions\");\n\nObject.keys(_expressions).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _expressions[key];\n    }\n  });\n});\n\nvar _statements = require(\"./statements\");\n\nObject.keys(_statements).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _statements[key];\n    }\n  });\n});\n\nvar _classes = require(\"./classes\");\n\nObject.keys(_classes).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _classes[key];\n    }\n  });\n});\n\nvar _methods = require(\"./methods\");\n\nObject.keys(_methods).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _methods[key];\n    }\n  });\n});\n\nvar _modules = require(\"./modules\");\n\nObject.keys(_modules).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _modules[key];\n    }\n  });\n});\n\nvar _types = require(\"./types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _flow = require(\"./flow\");\n\nObject.keys(_flow).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _flow[key];\n    }\n  });\n});\n\nvar _base = require(\"./base\");\n\nObject.keys(_base).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _base[key];\n    }\n  });\n});\n\nvar _jsx = require(\"./jsx\");\n\nObject.keys(_jsx).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _jsx[key];\n    }\n  });\n});\n\nvar _typescript = require(\"./typescript\");\n\nObject.keys(_typescript).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _typescript[key];\n    }\n  });\n});","\"use strict\";\n\nexports.__esModule = true;\nexports.JSXAttribute = JSXAttribute;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXSpreadChild = JSXSpreadChild;\nexports.JSXText = JSXText;\nexports.JSXElement = JSXElement;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\n\nfunction JSXAttribute(node) {\n  this.print(node.name, node);\n\n  if (node.value) {\n    this.token(\"=\");\n    this.print(node.value, node);\n  }\n}\n\nfunction JSXIdentifier(node) {\n  this.word(node.name);\n}\n\nfunction JSXNamespacedName(node) {\n  this.print(node.namespace, node);\n  this.token(\":\");\n  this.print(node.name, node);\n}\n\nfunction JSXMemberExpression(node) {\n  this.print(node.object, node);\n  this.token(\".\");\n  this.print(node.property, node);\n}\n\nfunction JSXSpreadAttribute(node) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.argument, node);\n  this.token(\"}\");\n}\n\nfunction JSXExpressionContainer(node) {\n  this.token(\"{\");\n  this.print(node.expression, node);\n  this.token(\"}\");\n}\n\nfunction JSXSpreadChild(node) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.expression, node);\n  this.token(\"}\");\n}\n\nfunction JSXText(node) {\n  var raw = this.getPossibleRaw(node);\n\n  if (raw != null) {\n    this.token(raw);\n  } else {\n    this.token(node.value);\n  }\n}\n\nfunction JSXElement(node) {\n  var open = node.openingElement;\n  this.print(open, node);\n  if (open.selfClosing) return;\n  this.indent();\n  var _arr = node.children;\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var child = _arr[_i];\n    this.print(child, node);\n  }\n\n  this.dedent();\n  this.print(node.closingElement, node);\n}\n\nfunction spaceSeparator() {\n  this.space();\n}\n\nfunction JSXOpeningElement(node) {\n  this.token(\"<\");\n  this.print(node.name, node);\n\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, node, {\n      separator: spaceSeparator\n    });\n  }\n\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/>\");\n  } else {\n    this.token(\">\");\n  }\n}\n\nfunction JSXClosingElement(node) {\n  this.token(\"</\");\n  this.print(node.name, node);\n  this.token(\">\");\n}\n\nfunction JSXEmptyExpression() {}","\"use strict\";\n\nexports.__esModule = true;\nexports._params = _params;\nexports._parameters = _parameters;\nexports._param = _param;\nexports._methodHead = _methodHead;\nexports._predicate = _predicate;\nexports._functionHead = _functionHead;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _params(node) {\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(node.params, node);\n\n  this.token(\")\");\n  this.print(node.returnType, node);\n}\n\nfunction _parameters(parameters, parent) {\n  for (var i = 0; i < parameters.length; i++) {\n    this._param(parameters[i], parent);\n\n    if (i < parameters.length - 1) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n}\n\nfunction _param(parameter, parent) {\n  this.printJoin(parameter.decorators, parameter);\n  this.print(parameter, parent);\n  if (parameter.optional) this.token(\"?\");\n  this.print(parameter.typeAnnotation, parameter);\n}\n\nfunction _methodHead(node) {\n  var kind = node.kind;\n  var key = node.key;\n\n  if (kind === \"method\" || kind === \"init\") {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key, node);\n    this.token(\"]\");\n  } else {\n    this.print(key, node);\n  }\n\n  if (node.optional) {\n    this.token(\"?\");\n  }\n\n  this._params(node);\n}\n\nfunction _predicate(node) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n\n    this.space();\n    this.print(node.predicate, node);\n  }\n}\n\nfunction _functionHead(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n\n  this.word(\"function\");\n  if (node.generator) this.token(\"*\");\n  this.space();\n\n  if (node.id) {\n    this.print(node.id, node);\n  }\n\n  this._params(node);\n\n  this._predicate(node);\n}\n\nfunction FunctionExpression(node) {\n  this._functionHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ArrowFunctionExpression(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n\n  var firstParam = node.params[0];\n\n  if (node.params.length === 1 && t.isIdentifier(firstParam) && !hasTypes(node, firstParam)) {\n    this.print(firstParam, node);\n  } else {\n    this._params(node);\n  }\n\n  this._predicate(node);\n\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction hasTypes(node, param) {\n  return node.typeParameters || node.returnType || param.typeAnnotation || param.optional || param.trailingComments;\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.ImportSpecifier = ImportSpecifier;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction ImportSpecifier(node) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported, node);\n\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local, node);\n  }\n}\n\nfunction ImportDefaultSpecifier(node) {\n  this.print(node.local, node);\n}\n\nfunction ExportDefaultSpecifier(node) {\n  this.print(node.exported, node);\n}\n\nfunction ExportSpecifier(node) {\n  this.print(node.local, node);\n\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported, node);\n  }\n}\n\nfunction ExportNamespaceSpecifier(node) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported, node);\n}\n\nfunction ExportAllDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.token(\"*\");\n  this.space();\n  this.word(\"from\");\n  this.space();\n  this.print(node.source, node);\n  this.semicolon();\n}\n\nfunction ExportNamedDeclaration(node) {\n  if (t.isClassDeclaration(node.declaration)) {\n    this.printJoin(node.declaration.decorators, node);\n  }\n\n  this.word(\"export\");\n  this.space();\n  ExportDeclaration.apply(this, arguments);\n}\n\nfunction ExportDefaultDeclaration(node) {\n  if (t.isClassDeclaration(node.declaration)) {\n    this.printJoin(node.declaration.decorators, node);\n  }\n\n  this.word(\"export\");\n  this.space();\n  this.word(\"default\");\n  this.space();\n  ExportDeclaration.apply(this, arguments);\n}\n\nfunction ExportDeclaration(node) {\n  if (node.declaration) {\n    var declar = node.declaration;\n    this.print(declar, node);\n    if (!t.isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    var specifiers = node.specifiers.slice(0);\n    var hasSpecial = false;\n\n    while (true) {\n      var first = specifiers[0];\n\n      if (t.isExportDefaultSpecifier(first) || t.isExportNamespaceSpecifier(first)) {\n        hasSpecial = true;\n        this.print(specifiers.shift(), node);\n\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      this.token(\"{\");\n\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n      }\n\n      this.token(\"}\");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nfunction ImportDeclaration(node) {\n  this.word(\"import\");\n  this.space();\n\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  var specifiers = node.specifiers.slice(0);\n\n  if (specifiers && specifiers.length) {\n    while (true) {\n      var first = specifiers[0];\n\n      if (t.isImportDefaultSpecifier(first) || t.isImportNamespaceSpecifier(first)) {\n        this.print(specifiers.shift(), node);\n\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (specifiers.length) {\n      this.token(\"{\");\n      this.space();\n      this.printList(specifiers, node);\n      this.space();\n      this.token(\"}\");\n    }\n\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  this.print(node.source, node);\n  this.semicolon();\n}\n\nfunction ImportNamespaceSpecifier(node) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local, node);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.WithStatement = WithStatement;\nexports.IfStatement = IfStatement;\nexports.ForStatement = ForStatement;\nexports.WhileStatement = WhileStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.TryStatement = TryStatement;\nexports.CatchClause = CatchClause;\nexports.SwitchStatement = SwitchStatement;\nexports.SwitchCase = SwitchCase;\nexports.DebuggerStatement = DebuggerStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\nexports.ThrowStatement = exports.BreakStatement = exports.ReturnStatement = exports.ContinueStatement = exports.ForOfStatement = exports.ForInStatement = void 0;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction WithStatement(node) {\n  this.word(\"with\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.object, node);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nfunction IfStatement(node) {\n  this.word(\"if\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test, node);\n  this.token(\")\");\n  this.space();\n  var needsBlock = node.alternate && t.isIfStatement(getLastStatement(node.consequent));\n\n  if (needsBlock) {\n    this.token(\"{\");\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent, node);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.token(\"}\");\n  }\n\n  if (node.alternate) {\n    if (this.endsWith(\"}\")) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate, node);\n  }\n}\n\nfunction getLastStatement(statement) {\n  if (!t.isStatement(statement.body)) return statement;\n  return getLastStatement(statement.body);\n}\n\nfunction ForStatement(node) {\n  this.word(\"for\");\n  this.space();\n  this.token(\"(\");\n  this.inForStatementInitCounter++;\n  this.print(node.init, node);\n  this.inForStatementInitCounter--;\n  this.token(\";\");\n\n  if (node.test) {\n    this.space();\n    this.print(node.test, node);\n  }\n\n  this.token(\";\");\n\n  if (node.update) {\n    this.space();\n    this.print(node.update, node);\n  }\n\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nfunction WhileStatement(node) {\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test, node);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nvar buildForXStatement = function buildForXStatement(op) {\n  return function (node) {\n    this.word(\"for\");\n    this.space();\n\n    if (op === \"of\" && node.await) {\n      this.word(\"await\");\n      this.space();\n    }\n\n    this.token(\"(\");\n    this.print(node.left, node);\n    this.space();\n    this.word(op);\n    this.space();\n    this.print(node.right, node);\n    this.token(\")\");\n    this.printBlock(node);\n  };\n};\n\nvar ForInStatement = buildForXStatement(\"in\");\nexports.ForInStatement = ForInStatement;\nvar ForOfStatement = buildForXStatement(\"of\");\nexports.ForOfStatement = ForOfStatement;\n\nfunction DoWhileStatement(node) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test, node);\n  this.token(\")\");\n  this.semicolon();\n}\n\nfunction buildLabelStatement(prefix, key) {\n  if (key === void 0) {\n    key = \"label\";\n  }\n\n  return function (node) {\n    this.word(prefix);\n    var label = node[key];\n\n    if (label) {\n      this.space();\n      var isLabel = key == \"label\";\n      var terminatorState = this.startTerminatorless(isLabel);\n      this.print(label, node);\n      this.endTerminatorless(terminatorState);\n    }\n\n    this.semicolon();\n  };\n}\n\nvar ContinueStatement = buildLabelStatement(\"continue\");\nexports.ContinueStatement = ContinueStatement;\nvar ReturnStatement = buildLabelStatement(\"return\", \"argument\");\nexports.ReturnStatement = ReturnStatement;\nvar BreakStatement = buildLabelStatement(\"break\");\nexports.BreakStatement = BreakStatement;\nvar ThrowStatement = buildLabelStatement(\"throw\", \"argument\");\nexports.ThrowStatement = ThrowStatement;\n\nfunction LabeledStatement(node) {\n  this.print(node.label, node);\n  this.token(\":\");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction TryStatement(node) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block, node);\n  this.space();\n\n  if (node.handlers) {\n    this.print(node.handlers[0], node);\n  } else {\n    this.print(node.handler, node);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer, node);\n  }\n}\n\nfunction CatchClause(node) {\n  this.word(\"catch\");\n  this.space();\n\n  if (node.param) {\n    this.token(\"(\");\n    this.print(node.param, node);\n    this.token(\")\");\n    this.space();\n  }\n\n  this.print(node.body, node);\n}\n\nfunction SwitchStatement(node) {\n  this.word(\"switch\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.discriminant, node);\n  this.token(\")\");\n  this.space();\n  this.token(\"{\");\n  this.printSequence(node.cases, node, {\n    indent: true,\n    addNewlines: function addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    }\n  });\n  this.token(\"}\");\n}\n\nfunction SwitchCase(node) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test, node);\n    this.token(\":\");\n  } else {\n    this.word(\"default\");\n    this.token(\":\");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, node, {\n      indent: true\n    });\n  }\n}\n\nfunction DebuggerStatement() {\n  this.word(\"debugger\");\n  this.semicolon();\n}\n\nfunction variableDeclarationIndent() {\n  this.token(\",\");\n  this.newline();\n  if (this.endsWith(\"\\n\")) for (var i = 0; i < 4; i++) {\n    this.space(true);\n  }\n}\n\nfunction constDeclarationIndent() {\n  this.token(\",\");\n  this.newline();\n  if (this.endsWith(\"\\n\")) for (var i = 0; i < 6; i++) {\n    this.space(true);\n  }\n}\n\nfunction VariableDeclaration(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(node.kind);\n  this.space();\n  var hasInits = false;\n\n  if (!t.isFor(parent)) {\n    var _arr = node.declarations;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var declar = _arr[_i];\n\n      if (declar.init) {\n        hasInits = true;\n      }\n    }\n  }\n\n  var separator;\n\n  if (hasInits) {\n    separator = node.kind === \"const\" ? constDeclarationIndent : variableDeclarationIndent;\n  }\n\n  this.printList(node.declarations, node, {\n    separator: separator\n  });\n\n  if (t.isFor(parent)) {\n    if (parent.left === node || parent.init === node) return;\n  }\n\n  this.semicolon();\n}\n\nfunction VariableDeclarator(node) {\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n\n  if (node.init) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.init, node);\n  }\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\n\nfunction TaggedTemplateExpression(node) {\n  this.print(node.tag, node);\n  this.print(node.quasi, node);\n}\n\nfunction TemplateElement(node, parent) {\n  var isFirst = parent.quasis[0] === node;\n  var isLast = parent.quasis[parent.quasis.length - 1] === node;\n  var value = (isFirst ? \"`\" : \"}\") + node.value.raw + (isLast ? \"`\" : \"${\");\n  this.token(value);\n}\n\nfunction TemplateLiteral(node) {\n  var quasis = node.quasis;\n\n  for (var i = 0; i < quasis.length; i++) {\n    this.print(quasis[i], node);\n\n    if (i + 1 < quasis.length) {\n      this.print(node.expressions[i], node);\n    }\n  }\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.Identifier = Identifier;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.StringLiteral = StringLiteral;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar _jsesc = _interopRequireDefault(require(\"jsesc\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction Identifier(node) {\n  this.word(node.name);\n}\n\nfunction RestElement(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction ObjectExpression(node) {\n  var props = node.properties;\n  this.token(\"{\");\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n\n  this.token(\"}\");\n}\n\nfunction ObjectMethod(node) {\n  this.printJoin(node.decorators, node);\n\n  this._methodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ObjectProperty(node) {\n  this.printJoin(node.decorators, node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key, node);\n    this.token(\"]\");\n  } else {\n    if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) {\n      this.print(node.value, node);\n      return;\n    }\n\n    this.print(node.key, node);\n\n    if (node.shorthand && t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ArrayExpression(node) {\n  var elems = node.elements;\n  var len = elems.length;\n  this.token(\"[\");\n  this.printInnerComments(node);\n\n  for (var i = 0; i < elems.length; i++) {\n    var elem = elems[i];\n\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(\",\");\n    } else {\n      this.token(\",\");\n    }\n  }\n\n  this.token(\"]\");\n}\n\nfunction RegExpLiteral(node) {\n  this.word(\"/\" + node.pattern + \"/\" + node.flags);\n}\n\nfunction BooleanLiteral(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteral() {\n  this.word(\"null\");\n}\n\nfunction NumericLiteral(node) {\n  var raw = this.getPossibleRaw(node);\n  var value = node.value + \"\";\n\n  if (raw == null) {\n    this.number(value);\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\n\nfunction StringLiteral(node, parent) {\n  var raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw != null) {\n    this.token(raw);\n    return;\n  }\n\n  var opts = {\n    quotes: t.isJSX(parent) ? \"double\" : this.format.quotes,\n    wrap: true\n  };\n\n  if (this.format.jsonCompatibleStrings) {\n    opts.json = true;\n  }\n\n  var val = (0, _jsesc.default)(node.value, opts);\n  return this.token(val);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSPropertySignature = TSPropertySignature;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSThisType = TSThisType;\nexports.TSFunctionType = TSFunctionType;\nexports.TSConstructorType = TSConstructorType;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.TSTypeReference = TSTypeReference;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\nexports.tsPrintBraced = tsPrintBraced;\nexports.TSArrayType = TSArrayType;\nexports.TSTupleType = TSTupleType;\nexports.TSUnionType = TSUnionType;\nexports.TSIntersectionType = TSIntersectionType;\nexports.tsPrintUnionOrIntersectionType = tsPrintUnionOrIntersectionType;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSMappedType = TSMappedType;\nexports.TSLiteralType = TSLiteralType;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\n\nfunction TSTypeAnnotation(node) {\n  this.token(\":\");\n  this.space();\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSTypeParameterInstantiation(node) {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nfunction TSTypeParameter(node) {\n  this.word(node.name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nfunction TSDeclareFunction(node) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this._functionHead(node);\n\n  this.token(\";\");\n}\n\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n\n  this.token(\";\");\n}\n\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.token(\".\");\n  this.print(node.right, node);\n}\n\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n}\n\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n}\n\nfunction TSPropertySignature(node) {\n  var readonly = node.readonly,\n      initializer = node.initializer;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(\";\");\n}\n\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n\n  this.print(node.key, node);\n\n  if (node.computed) {\n    this.token(\"]\");\n  }\n\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nfunction TSMethodSignature(node) {\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.token(\";\");\n}\n\nfunction TSIndexSignature(node) {\n  var readonly = node.readonly;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n\n  this._parameters(node.parameters, node);\n\n  this.token(\"]\");\n  this.print(node.typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\n\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\n\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\n\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\n\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\n\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\n\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\n\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\n\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\n\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\n\nfunction TSThisType() {\n  this.word(\"this\");\n}\n\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction TSConstructorType(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction tsPrintFunctionOrConstructorType(node) {\n  var typeParameters = node.typeParameters,\n      parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(parameters, node);\n\n  this.token(\")\");\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.typeAnnotation.typeAnnotation, node);\n}\n\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSTypePredicate(node) {\n  this.print(node.parameterName);\n  this.space();\n  this.word(\"is\");\n  this.space();\n  this.print(node.typeAnnotation.typeAnnotation);\n}\n\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n}\n\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  this.tsPrintBraced(members, node);\n}\n\nfunction tsPrintBraced(members, node) {\n  this.token(\"{\");\n\n  if (members.length) {\n    this.indent();\n    this.newline();\n\n    for (var _iterator = members, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var _member = _ref;\n      this.print(_member, node);\n      this.newline();\n    }\n\n    this.dedent();\n    this.rightBrace();\n  } else {\n    this.token(\"}\");\n  }\n}\n\nfunction TSArrayType(node) {\n  this.print(node.elementType);\n  this.token(\"[]\");\n}\n\nfunction TSTupleType(node) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, node);\n  this.token(\"]\");\n}\n\nfunction TSUnionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, \"|\");\n}\n\nfunction TSIntersectionType(node) {\n  this.tsPrintUnionOrIntersectionType(node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(node, sep) {\n  this.printJoin(node.types, node, {\n    separator: function separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n  });\n}\n\nfunction TSParenthesizedType(node) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nfunction TSTypeOperator(node) {\n  this.token(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nfunction TSMappedType(node) {\n  var readonly = node.readonly,\n      typeParameter = node.typeParameter,\n      optional = node.optional;\n  this.token(\"{\");\n  this.space();\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n  this.token(\"]\");\n\n  if (optional) {\n    this.token(\"?\");\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.token(\"}\");\n}\n\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\n\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSInterfaceDeclaration(node) {\n  var declare = node.declare,\n      id = node.id,\n      typeParameters = node.typeParameters,\n      extendz = node.extends,\n      body = node.body;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n\n  if (extendz) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nfunction TSTypeAliasDeclaration(node) {\n  var declare = node.declare,\n      id = node.id,\n      typeParameters = node.typeParameters,\n      typeAnnotation = node.typeAnnotation;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation, node);\n  this.token(\";\");\n}\n\nfunction TSAsExpression(node) {\n  var expression = node.expression,\n      typeAnnotation = node.typeAnnotation;\n  this.print(expression, node);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nfunction TSTypeAssertion(node) {\n  var typeAnnotation = node.typeAnnotation,\n      expression = node.expression;\n  this.token(\"<\");\n  this.print(typeAnnotation, node);\n  this.token(\">\");\n  this.space();\n  this.print(expression, node);\n}\n\nfunction TSEnumDeclaration(node) {\n  var declare = node.declare,\n      isConst = node.const,\n      id = node.id,\n      members = node.members;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tsPrintBraced(members, node);\n}\n\nfunction TSEnumMember(node) {\n  var id = node.id,\n      initializer = node.initializer;\n  this.print(id, node);\n\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.token(\",\");\n}\n\nfunction TSModuleDeclaration(node) {\n  var declare = node.declare,\n      id = node.id;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n\n  this.print(id, node);\n\n  if (!node.body) {\n    this.token(\";\");\n    return;\n  }\n\n  var body = node.body;\n\n  while (body.type === \"TSModuleDeclaration\") {\n    this.token(\".\");\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSModuleBlock(node) {\n  this.tsPrintBraced(node.body, node);\n}\n\nfunction TSImportEqualsDeclaration(node) {\n  var isExport = node.isExport,\n      id = node.id,\n      moduleReference = node.moduleReference;\n\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference, node);\n  this.token(\";\");\n}\n\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.token(\"!\");\n}\n\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression, node);\n  this.token(\";\");\n}\n\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\n\nfunction tsPrintSignatureDeclarationBase(node) {\n  var typeParameters = node.typeParameters,\n      parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.token(\"(\");\n\n  this._parameters(parameters, node);\n\n  this.token(\")\");\n  this.print(node.typeAnnotation, node);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.default = _default;\nexports.CodeGenerator = void 0;\n\nvar _sourceMap = _interopRequireDefault(require(\"./source-map\"));\n\nvar _printer = _interopRequireDefault(require(\"./printer\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Generator = function (_Printer) {\n  _inheritsLoose(Generator, _Printer);\n\n  function Generator(ast, opts, code) {\n    var _this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    var format = normalizeOptions(code, opts);\n    var map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n    _this = _Printer.call(this, format, map) || this;\n    _this.ast = ast;\n    return _this;\n  }\n\n  var _proto = Generator.prototype;\n\n  _proto.generate = function generate() {\n    return _Printer.prototype.generate.call(this, this.ast);\n  };\n\n  return Generator;\n}(_printer.default);\n\nfunction normalizeOptions(code, opts) {\n  var format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    quotes: \"double\",\n    jsonCompatibleStrings: opts.jsonCompatibleStrings,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \",\n      base: 0\n    }\n  };\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment = format.shouldPrintComment || function () {\n      return format.comments;\n    };\n  } else {\n    format.shouldPrintComment = format.shouldPrintComment || function (value) {\n      return format.comments || value.indexOf(\"@license\") >= 0 || value.indexOf(\"@preserve\") >= 0;\n    };\n  }\n\n  if (format.compact === \"auto\") {\n    format.compact = code.length > 500000;\n\n    if (format.compact) {\n      console.error(\"[BABEL] Note: The code generator has deoptimised the styling of \" + (opts.filename + \" as it exceeds the max of \" + \"500KB\" + \".\"));\n    }\n  }\n\n  if (format.compact) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  return format;\n}\n\nvar CodeGenerator = function () {\n  function CodeGenerator(ast, opts, code) {\n    this._generator = new Generator(ast, opts, code);\n  }\n\n  var _proto2 = CodeGenerator.prototype;\n\n  _proto2.generate = function generate() {\n    return this._generator.generate();\n  };\n\n  return CodeGenerator;\n}();\n\nexports.CodeGenerator = CodeGenerator;\n\nfunction _default(ast, opts, code) {\n  var gen = new Generator(ast, opts, code);\n  return gen.generate();\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsParens = needsParens;\n\nvar whitespace = _interopRequireWildcard(require(\"./whitespace\"));\n\nvar parens = _interopRequireWildcard(require(\"./parentheses\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction expandAliases(obj) {\n  var newObj = {};\n\n  function add(type, func) {\n    var fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      var result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n\n  var _arr = Object.keys(obj);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var type = _arr[_i];\n    var aliases = t.FLIPPED_ALIAS_KEYS[type];\n\n    if (aliases) {\n      for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i2 >= _iterator.length) break;\n          _ref = _iterator[_i2++];\n        } else {\n          _i2 = _iterator.next();\n          if (_i2.done) break;\n          _ref = _i2.value;\n        }\n\n        var _alias = _ref;\n        add(_alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\nvar expandedParens = expandAliases(parens);\nvar expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nvar expandedWhitespaceList = expandAliases(whitespace.list);\n\nfunction find(obj, node, parent, printStack) {\n  var fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node) {\n  if (t.isCallExpression(node)) {\n    return true;\n  }\n\n  if (t.isMemberExpression(node)) {\n    return isOrHasCallExpression(node.object) || !node.computed && isOrHasCallExpression(node.property);\n  } else {\n    return false;\n  }\n}\n\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return 0;\n\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  var linesInfo = find(expandedWhitespaceNodes, node, parent);\n\n  if (!linesInfo) {\n    var items = find(expandedWhitespaceList, node, parent);\n\n    if (items) {\n      for (var i = 0; i < items.length; i++) {\n        linesInfo = needsWhitespace(items[i], node, type);\n        if (linesInfo) break;\n      }\n    }\n  }\n\n  return linesInfo && linesInfo[type] || 0;\n}\n\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, \"before\");\n}\n\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, \"after\");\n}\n\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n\n  if (t.isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.FunctionTypeAnnotation = exports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.AssignmentExpression = AssignmentExpression;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar PRECEDENCE = {\n  \"||\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction UpdateExpression(node, parent) {\n  return t.isMemberExpression(parent) && parent.object === node;\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerArrow: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isUnaryLike(parent) || t.isMemberExpression(parent) && parent.object === node || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    var parentOp = parent.operator;\n    var parentPos = PRECEDENCE[parentOp];\n    var nodeOp = node.operator;\n    var nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isConditionalExpression(parent) && node === parent.test;\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return t.isMemberExpression(parent, {\n    object: node\n  }) || t.isCallExpression(parent, {\n    callee: node\n  }) || t.isNewExpression(parent, {\n    callee: node\n  }) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  });\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInStatement(printStack, {\n    considerDefaultExports: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isTaggedTemplateExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction AssignmentExpression(node) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression.apply(void 0, arguments);\n  }\n}\n\nfunction isFirstInStatement(printStack, _temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$considerArrow = _ref.considerArrow,\n      considerArrow = _ref$considerArrow === void 0 ? false : _ref$considerArrow,\n      _ref$considerDefaultE = _ref.considerDefaultExports,\n      considerDefaultExports = _ref$considerDefaultE === void 0 ? false : _ref$considerDefaultE;\n\n  var i = printStack.length - 1;\n  var node = printStack[i];\n  i--;\n  var parent = printStack[i];\n\n  while (i > 0) {\n    if (t.isExpressionStatement(parent, {\n      expression: node\n    }) || t.isTaggedTemplateExpression(parent) || considerDefaultExports && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || considerArrow && t.isArrowFunctionExpression(parent, {\n      body: node\n    })) {\n      return true;\n    }\n\n    if (t.isCallExpression(parent, {\n      callee: node\n    }) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isMemberExpression(parent, {\n      object: node\n    }) || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.list = exports.nodes = void 0;\n\nvar _map = _interopRequireDefault(require(\"lodash/map\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction crawl(node, state) {\n  if (state === void 0) {\n    state = {};\n  }\n\n  if (t.isMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (t.isCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (t.isFunction(node)) {\n    state.hasFunction = true;\n  } else if (t.isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (t.isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (t.isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (t.isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);\n}\n\nvar nodes = {\n  AssignmentExpression: function AssignmentExpression(node) {\n    var state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n  SwitchCase: function SwitchCase(node, parent) {\n    return {\n      before: node.consequent.length || parent.cases[0] === node,\n      after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node\n    };\n  },\n  LogicalExpression: function LogicalExpression(node) {\n    if (t.isFunction(node.left) || t.isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n  Literal: function Literal(node) {\n    if (node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n  CallExpression: function CallExpression(node) {\n    if (t.isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n  VariableDeclaration: function VariableDeclaration(node) {\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n      var enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled) {\n        var state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n  IfStatement: function IfStatement(node) {\n    if (t.isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n};\nexports.nodes = nodes;\n\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  if (parent.callProperties[0] === node && (!parent.properties || !parent.properties.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nnodes.ObjectTypeIndexer = function (node, parent) {\n  if (parent.indexers[0] === node && (!parent.properties || !parent.properties.length) && (!parent.callProperties || !parent.callProperties.length)) {\n    return {\n      before: true\n    };\n  }\n};\n\nvar list = {\n  VariableDeclaration: function VariableDeclaration(node) {\n    return (0, _map.default)(node.declarations, \"init\");\n  },\n  ArrayExpression: function ArrayExpression(node) {\n    return node.elements;\n  },\n  ObjectExpression: function ObjectExpression(node) {\n    return node.properties;\n  }\n};\nexports.list = list;\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function (_ref) {\n  var type = _ref[0],\n      amounts = _ref[1];\n\n  if (typeof amounts === \"boolean\") {\n    amounts = {\n      after: amounts,\n      before: amounts\n    };\n  }\n\n  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    nodes[type] = function () {\n      return amounts;\n    };\n  });\n});","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _isInteger = _interopRequireDefault(require(\"lodash/isInteger\"));\n\nvar _repeat = _interopRequireDefault(require(\"lodash/repeat\"));\n\nvar _buffer = _interopRequireDefault(require(\"./buffer\"));\n\nvar n = _interopRequireWildcard(require(\"./node\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar generatorFunctions = _interopRequireWildcard(require(\"./generators\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SCIENTIFIC_NOTATION = /e/i;\nvar ZERO_DECIMAL_INTEGER = /\\.0+$/;\nvar NON_DECIMAL_LITERAL = /^0[box]/;\n\nvar Printer = function () {\n  function Printer(format, map) {\n    Object.defineProperty(this, \"inForStatementInitCounter\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_printStack\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_indent\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_insideAux\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_printedCommentStarts\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_parenPushNewlineState\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"_noLineTerminator\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_printAuxAfterOnNextUserNode\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_printedComments\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: new WeakSet()\n    });\n    Object.defineProperty(this, \"_endsWithInteger\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_endsWithWord\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: false\n    });\n    this.format = format || {};\n    this._buf = new _buffer.default(map);\n  }\n\n  var _proto = Printer.prototype;\n\n  _proto.generate = function generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  };\n\n  _proto.indent = function indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  };\n\n  _proto.dedent = function dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  };\n\n  _proto.semicolon = function semicolon(force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  };\n\n  _proto.rightBrace = function rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  };\n\n  _proto.space = function space(force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (this.format.compact) return;\n\n    if (this._buf.hasContent() && !this.endsWith(\" \") && !this.endsWith(\"\\n\") || force) {\n      this._space();\n    }\n  };\n\n  _proto.word = function word(str) {\n    if (this._endsWithWord) this._space();\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  };\n\n  _proto.number = function number(str) {\n    this.word(str);\n    this._endsWithInteger = (0, _isInteger.default)(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== \".\";\n  };\n\n  _proto.token = function token(str) {\n    if (str === \"--\" && this.endsWith(\"!\") || str[0] === \"+\" && this.endsWith(\"+\") || str[0] === \"-\" && this.endsWith(\"-\") || str[0] === \".\" && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  };\n\n  _proto.newline = function newline(i) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    if (this.endsWith(\"\\n\\n\")) return;\n    if (typeof i !== \"number\") i = 1;\n    i = Math.min(2, i);\n    if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n    if (i <= 0) return;\n\n    for (var j = 0; j < i; j++) {\n      this._newline();\n    }\n  };\n\n  _proto.endsWith = function endsWith(str) {\n    return this._buf.endsWith(str);\n  };\n\n  _proto.removeTrailingNewline = function removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  };\n\n  _proto.source = function source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  };\n\n  _proto.withSource = function withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  };\n\n  _proto._space = function _space() {\n    this._append(\" \", true);\n  };\n\n  _proto._newline = function _newline() {\n    this._append(\"\\n\", true);\n  };\n\n  _proto._append = function _append(str, queue) {\n    if (queue === void 0) {\n      queue = false;\n    }\n\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  };\n\n  _proto._maybeIndent = function _maybeIndent(str) {\n    if (this._indent && this.endsWith(\"\\n\") && str[0] !== \"\\n\") {\n      this._buf.queue(this._getIndent());\n    }\n  };\n\n  _proto._maybeAddParen = function _maybeAddParen(str) {\n    var parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    this._parenPushNewlineState = null;\n    var i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) {\n      continue;\n    }\n\n    if (i === str.length) return;\n    var cha = str[i];\n    var chaPost = str[i + 1];\n\n    if (cha === \"\\n\" || cha === \"/\" && (chaPost === \"/\" || chaPost === \"*\")) {\n      this.token(\"(\");\n      this.indent();\n      parenPushNewlineState.printed = true;\n    }\n  };\n\n  _proto._catchUp = function _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    var pos = loc ? loc[prop] : null;\n\n    if (pos && pos.line !== null) {\n      var count = pos.line - this._buf.getCurrentLine();\n\n      for (var i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  };\n\n  _proto._getIndent = function _getIndent() {\n    return (0, _repeat.default)(this.format.indent.style, this._indent);\n  };\n\n  _proto.startTerminatorless = function startTerminatorless(isLabel) {\n    if (isLabel === void 0) {\n      isLabel = false;\n    }\n\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  };\n\n  _proto.endTerminatorless = function endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state && state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  };\n\n  _proto.print = function print(node, parent) {\n    var _this = this;\n\n    if (!node) return;\n    var oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    var printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(\"unknown node of type \" + JSON.stringify(node.type) + \" with constructor \" + JSON.stringify(node && node.constructor.name));\n    }\n\n    this._printStack.push(node);\n\n    var oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    var needsParens = n.needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      needsParens = true;\n    }\n\n    if (needsParens) this.token(\"(\");\n\n    this._printLeadingComments(node, parent);\n\n    var loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, function () {\n      _this[node.type](node, parent);\n    });\n\n    this._printTrailingComments(node, parent);\n\n    if (needsParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  };\n\n  _proto._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  };\n\n  _proto._printAuxBeforeComment = function _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    var comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  };\n\n  _proto._printAuxAfterComment = function _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    var comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  };\n\n  _proto.getPossibleRaw = function getPossibleRaw(node) {\n    var extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  };\n\n  _proto.printJoin = function printJoin(nodes, parent, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (!nodes || !nodes.length) return;\n    if (opts.indent) this.indent();\n    var newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  };\n\n  _proto.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {\n    var indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  };\n\n  _proto.printBlock = function printBlock(parent) {\n    var node = parent.body;\n\n    if (!t.isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  };\n\n  _proto._printTrailingComments = function _printTrailingComments(node, parent) {\n    this._printComments(this._getComments(false, node, parent));\n  };\n\n  _proto._printLeadingComments = function _printLeadingComments(node, parent) {\n    this._printComments(this._getComments(true, node, parent));\n  };\n\n  _proto.printInnerComments = function printInnerComments(node, indent) {\n    if (indent === void 0) {\n      indent = true;\n    }\n\n    if (!node.innerComments || !node.innerComments.length) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  };\n\n  _proto.printSequence = function printSequence(nodes, parent, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  };\n\n  _proto.printList = function printList(items, parent, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  };\n\n  _proto._printNewline = function _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    var lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      var needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(lines);\n  };\n\n  _proto._getComments = function _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  };\n\n  _proto._printComment = function _printComment(comment) {\n    var _this2 = this;\n\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    if (comment.start != null) {\n      if (this._printedCommentStarts[comment.start]) return;\n      this._printedCommentStarts[comment.start] = true;\n    }\n\n    var isBlockComment = comment.type === \"CommentBlock\";\n    this.newline(this._buf.hasContent() && !this._noLineTerminator && isBlockComment ? 1 : 0);\n    if (!this.endsWith(\"[\") && !this.endsWith(\"{\")) this.space();\n    var val = !isBlockComment && !this._noLineTerminator ? \"//\" + comment.value + \"\\n\" : \"/*\" + comment.value + \"*/\";\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var offset = comment.loc && comment.loc.start.column;\n\n      if (offset) {\n        var newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, \"\\n\" + (0, _repeat.default)(\" \", indentSize));\n    }\n\n    if (this.endsWith(\"/\")) this._space();\n    this.withSource(\"start\", comment.loc, function () {\n      _this2._append(val);\n    });\n    this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);\n  };\n\n  _proto._printComments = function _printComments(comments) {\n    if (!comments || !comments.length) return;\n\n    for (var _iterator = comments, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var _comment2 = _ref;\n\n      this._printComment(_comment2);\n    }\n  };\n\n  return Printer;\n}();\n\nexports.default = Printer;\nObject.assign(Printer.prototype, generatorFunctions);\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _sourceMap = _interopRequireDefault(require(\"source-map\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar SourceMap = function () {\n  function SourceMap(opts, code) {\n    this._cachedMap = null;\n    this._code = code;\n    this._opts = opts;\n    this._rawMappings = [];\n  }\n\n  var _proto = SourceMap.prototype;\n\n  _proto.get = function get() {\n    if (!this._cachedMap) {\n      var map = this._cachedMap = new _sourceMap.default.SourceMapGenerator({\n        file: this._opts.sourceMapTarget,\n        sourceRoot: this._opts.sourceRoot\n      });\n      var code = this._code;\n\n      if (typeof code === \"string\") {\n        map.setSourceContent(this._opts.sourceFileName, code);\n      } else if (_typeof(code) === \"object\") {\n        Object.keys(code).forEach(function (sourceFileName) {\n          map.setSourceContent(sourceFileName, code[sourceFileName]);\n        });\n      }\n\n      this._rawMappings.forEach(map.addMapping, map);\n    }\n\n    return this._cachedMap.toJSON();\n  };\n\n  _proto.getRawMappings = function getRawMappings() {\n    return this._rawMappings.slice();\n  };\n\n  _proto.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename) {\n    if (this._lastGenLine !== generatedLine && line === null) return;\n\n    if (this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {\n      return;\n    }\n\n    this._cachedMap = null;\n    this._lastGenLine = generatedLine;\n    this._lastSourceLine = line;\n    this._lastSourceColumn = column;\n\n    this._rawMappings.push({\n      name: identifierName || undefined,\n      generated: {\n        line: generatedLine,\n        column: generatedColumn\n      },\n      source: line == null ? undefined : filename || this._opts.sourceFileName,\n      original: line == null ? undefined : {\n        line: line,\n        column: column\n      }\n    });\n  };\n\n  return SourceMap;\n}();\n\nexports.default = SourceMap;","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (_ref) {\n  var node = _ref.node,\n      parent = _ref.parent,\n      scope = _ref.scope,\n      id = _ref.id;\n\n  if (node.id) return;\n\n  if ((t.isObjectProperty(parent) || t.isObjectMethod(parent, { kind: \"method\" })) && (!parent.computed || t.isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (t.isVariableDeclarator(parent)) {\n    id = parent.id;\n\n    if (t.isIdentifier(id)) {\n      var binding = scope.parent.getBinding(id.name);\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = id;\n        node.id[t.NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (t.isAssignmentExpression(parent)) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  var name = void 0;\n  if (id && t.isLiteral(id)) {\n    name = id.value;\n  } else if (id && t.isIdentifier(id)) {\n    name = id.name;\n  } else {\n    return;\n  }\n\n  name = t.toBindingIdentifierName(name);\n  id = t.identifier(name);\n\n  id[t.NOT_LOCAL_BINDING] = true;\n\n  var state = visit(node, name, scope);\n  return wrap(state, node, id, scope) || node;\n};\n\nvar _babelHelperGetFunctionArity = require(\"babel-helper-get-function-arity\");\n\nvar _babelHelperGetFunctionArity2 = _interopRequireDefault(_babelHelperGetFunctionArity);\n\nvar _babelTemplate = require(\"babel-template\");\n\nvar _babelTemplate2 = _interopRequireDefault(_babelTemplate);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar buildPropertyMethodAssignmentWrapper = (0, _babelTemplate2.default)(\"\\n  (function (FUNCTION_KEY) {\\n    function FUNCTION_ID() {\\n      return FUNCTION_KEY.apply(this, arguments);\\n    }\\n\\n    FUNCTION_ID.toString = function () {\\n      return FUNCTION_KEY.toString();\\n    }\\n\\n    return FUNCTION_ID;\\n  })(FUNCTION)\\n\");\n\nvar buildGeneratorPropertyMethodAssignmentWrapper = (0, _babelTemplate2.default)(\"\\n  (function (FUNCTION_KEY) {\\n    function* FUNCTION_ID() {\\n      return yield* FUNCTION_KEY.apply(this, arguments);\\n    }\\n\\n    FUNCTION_ID.toString = function () {\\n      return FUNCTION_KEY.toString();\\n    };\\n\\n    return FUNCTION_ID;\\n  })(FUNCTION)\\n\");\n\nvar visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\": function ReferencedIdentifierBindingIdentifier(path, state) {\n    if (path.node.name !== state.name) return;\n\n    var localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n\n    state.selfReference = true;\n    path.stop();\n  }\n};\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!t.isFunction(method)) return;\n\n      var build = buildPropertyMethodAssignmentWrapper;\n      if (method.generator) build = buildGeneratorPropertyMethodAssignmentWrapper;\n      var _template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      _template.callee._skipModulesRemap = true;\n\n      var params = _template.callee.body.body[0].params;\n      for (var i = 0, len = (0, _babelHelperGetFunctionArity2.default)(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return _template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  var state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    references: [],\n    name: name\n  };\n\n  var binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (node) {\n  var params = node.params;\n  for (var i = 0; i < params.length; i++) {\n    var param = params[i];\n    if (t.isAssignmentPattern(param) || t.isRestElement(param)) {\n      return i;\n    }\n  }\n  return params.length;\n};\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nmodule.exports = exports[\"default\"];","module.exports = { \"default\": require(\"core-js/library/fn/get-iterator\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/json/stringify\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/number/max-safe-integer\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/object/create\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/object/get-own-property-symbols\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/object/keys\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/symbol/for\"), __esModule: true };","module.exports = { \"default\": require(\"core-js/library/fn/symbol/iterator\"), __esModule: true };","\"use strict\";\n\nexports.__esModule = true;\n\nvar _iterator = require(\"../core-js/symbol/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = require(\"../core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};","\"use strict\";\n\nexports.__esModule = true;\n\nvar _symbol = require(\"babel-runtime/core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nexports.default = function (code, opts) {\n  var stack = void 0;\n  try {\n    throw new Error();\n  } catch (error) {\n    if (error.stack) {\n      stack = error.stack.split(\"\\n\").slice(1).join(\"\\n\");\n    }\n  }\n\n  opts = (0, _assign2.default)({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    preserveComments: false\n  }, opts);\n\n  var _getAst = function getAst() {\n    var ast = void 0;\n\n    try {\n      ast = babylon.parse(code, opts);\n\n      ast = _babelTraverse2.default.removeProperties(ast, { preserveComments: opts.preserveComments });\n\n      _babelTraverse2.default.cheap(ast, function (node) {\n        node[FROM_TEMPLATE] = true;\n      });\n    } catch (err) {\n      err.stack = err.stack + \"from\\n\" + stack;\n      throw err;\n    }\n\n    _getAst = function getAst() {\n      return ast;\n    };\n\n    return ast;\n  };\n\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return useTemplate(_getAst(), args);\n  };\n};\n\nvar _cloneDeep = require(\"lodash/cloneDeep\");\n\nvar _cloneDeep2 = _interopRequireDefault(_cloneDeep);\n\nvar _assign = require(\"lodash/assign\");\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _has = require(\"lodash/has\");\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _babelTraverse = require(\"babel-traverse\");\n\nvar _babelTraverse2 = _interopRequireDefault(_babelTraverse);\n\nvar _babylon = require(\"babylon\");\n\nvar babylon = _interopRequireWildcard(_babylon);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar FROM_TEMPLATE = \"_fromTemplate\";\nvar TEMPLATE_SKIP = (0, _symbol2.default)();\n\nfunction useTemplate(ast, nodes) {\n  ast = (0, _cloneDeep2.default)(ast);\n  var _ast = ast,\n      program = _ast.program;\n\n\n  if (nodes.length) {\n    (0, _babelTraverse2.default)(ast, templateVisitor, null, nodes);\n  }\n\n  if (program.body.length > 1) {\n    return program.body;\n  } else {\n    return program.body[0];\n  }\n}\n\nvar templateVisitor = {\n  noScope: true,\n\n  enter: function enter(path, args) {\n    var node = path.node;\n\n    if (node[TEMPLATE_SKIP]) return path.skip();\n\n    if (t.isExpressionStatement(node)) {\n      node = node.expression;\n    }\n\n    var replacement = void 0;\n\n    if (t.isIdentifier(node) && node[FROM_TEMPLATE]) {\n      if ((0, _has2.default)(args[0], node.name)) {\n        replacement = args[0][node.name];\n      } else if (node.name[0] === \"$\") {\n        var i = +node.name.slice(1);\n        if (args[i]) replacement = args[i];\n      }\n    }\n\n    if (replacement === null) {\n      path.remove();\n    }\n\n    if (replacement) {\n      replacement[TEMPLATE_SKIP] = true;\n      path.replaceInline(replacement);\n    }\n  },\n  exit: function exit(_ref) {\n    var node = _ref.node;\n\n    if (!node.loc) _babelTraverse2.default.clearNode(node);\n  }\n};\nmodule.exports = exports[\"default\"];","\"use strict\";\n\nexports.__esModule = true;\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nvar path = new WeakMap();\nexports.path = path;\nvar scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _path4 = _interopRequireDefault(require(\"./path\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar testing = process.env.NODE_ENV === \"test\";\n\nvar TraversalContext = function () {\n  function TraversalContext(scope, opts, state, parentPath) {\n    Object.defineProperty(this, \"queue\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: null\n    });\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  var _proto = TraversalContext.prototype;\n\n  _proto.shouldVisit = function shouldVisit(node) {\n    var opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    var keys = t.VISITOR_KEYS[node.type];\n    if (!keys || !keys.length) return false;\n\n    for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var _key = _ref;\n      if (node[_key]) return true;\n    }\n\n    return false;\n  };\n\n  _proto.create = function create(node, obj, key, listKey) {\n    return _path4.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey: listKey\n    });\n  };\n\n  _proto.maybeQueue = function maybeQueue(path, notPriority) {\n    if (this.trap) {\n      throw new Error(\"Infinite cycle detected\");\n    }\n\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  };\n\n  _proto.visitMultiple = function visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    var queue = [];\n\n    for (var key = 0; key < container.length; key++) {\n      var node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  };\n\n  _proto.visitSingle = function visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  };\n\n  _proto.visitQueue = function visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    var visited = [];\n    var stop = false;\n\n    for (var _iterator2 = queue, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var _path2 = _ref2;\n\n      _path2.resync();\n\n      if (_path2.contexts.length === 0 || _path2.contexts[_path2.contexts.length - 1] !== this) {\n        _path2.pushContext(this);\n      }\n\n      if (_path2.key === null) continue;\n\n      if (testing && queue.length >= 10000) {\n        this.trap = true;\n      }\n\n      if (visited.indexOf(_path2.node) >= 0) continue;\n      visited.push(_path2.node);\n\n      if (_path2.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (var _iterator3 = queue, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var _path3 = _ref3;\n\n      _path3.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  };\n\n  _proto.visit = function visit(node, key) {\n    var nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  };\n\n  return TraversalContext;\n}();\n\nexports.default = TraversalContext;","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar Hub = function Hub(file) {\n  this.file = file;\n};\n\nexports.default = Hub;","\"use strict\";\n\nexports.__esModule = true;\nexports.default = traverse;\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function get() {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function get() {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function get() {\n    return _hub.default;\n  }\n});\nexports.visitors = void 0;\n\nvar _context = _interopRequireDefault(require(\"./context\"));\n\nvar visitors = _interopRequireWildcard(require(\"./visitors\"));\n\nexports.visitors = visitors;\n\nvar _includes = _interopRequireDefault(require(\"lodash/includes\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar cache = _interopRequireWildcard(require(\"./cache\"));\n\nvar _path = _interopRequireDefault(require(\"./path\"));\n\nvar _scope = _interopRequireDefault(require(\"./scope\"));\n\nvar _hub = _interopRequireDefault(require(\"./hub\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction traverse(parent, opts, scope, state, parentPath) {\n  if (!parent) return;\n  if (!opts) opts = {};\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + (\"Instead of that you tried to traverse a \" + parent.type + \" node without \") + \"passing scope and parentPath.\");\n    }\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\ntraverse.NodePath = require(\"./path\");\ntraverse.Scope = require(\"./scope\");\ntraverse.Hub = require(\"./hub\");\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  var keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  var context = new _context.default(scope, opts, state, parentPath);\n\n  for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _key = _ref;\n    if (skipKeys && skipKeys[_key]) continue;\n    if (context.visit(node, _key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasBlacklistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, blacklistTypes) {\n  if ((0, _includes.default)(blacklistTypes, tree.type)) return false;\n  if (tree.type === type) return true;\n  var state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    blacklist: blacklistTypes,\n    enter: hasBlacklistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nexports.__esModule = true;\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction findParent(callback) {\n  var path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  var path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(function (p) {\n    return p.isFunction();\n  });\n}\n\nfunction getStatementParent() {\n  var path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    var earliest;\n    var keys = t.VISITOR_KEYS[deepest.type];\n    var _arr = ancestries;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var ancestry = _arr[_i];\n      var path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      var earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      var currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  var _this = this;\n\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  var minDepth = Infinity;\n  var lastCommonIndex, lastCommon;\n  var ancestries = paths.map(function (path) {\n    var ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== _this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  var first = ancestries[0];\n\n  depthLoop: for (var i = 0; i < minDepth; i++) {\n    var shouldMatch = first[i];\n    var _arr2 = ancestries;\n\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var ancestry = _arr2[_i2];\n\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  var path = this;\n  var paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(function (parent) {\n    return parent === maybeAncestor;\n  });\n}\n\nfunction inType() {\n  var path = this;\n\n  while (path) {\n    var _arr3 = arguments;\n\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var type = _arr3[_i3];\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  var node = this.node;\n  if (!node) return;\n  var trailing = node.trailingComments;\n  var leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  var prev = this.getSibling(this.key - 1);\n  var next = this.getSibling(this.key + 1);\n  var hasPrev = Boolean(prev.node);\n  var hasNext = Boolean(next.node);\n\n  if (hasPrev && hasNext) {} else if (hasPrev) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = isBlacklisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction call(key) {\n  var opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (var _iterator = fns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _fn = _ref;\n    if (!_fn) continue;\n    var node = this.node;\n    if (!node) return true;\n\n    var ret = _fn.call(this.state, this, this.state);\n\n    if (ret) {\n      throw new Error(\"Unexpected return value from visitor method \" + _fn);\n    }\n\n    if (this.node !== node) return true;\n    if (this.shouldStop || this.shouldSkip || this.removed) return true;\n  }\n\n  return false;\n}\n\nfunction isBlacklisted() {\n  var blacklist = this.opts.blacklist;\n  return blacklist && blacklist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isBlacklisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this.shouldStop = true;\n  this.shouldSkip = true;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  var path = this.parentPath;\n  var target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  this.shouldSkip = false;\n  this.shouldStop = false;\n  this.removed = false;\n  this.skipKeys = {};\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (var i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (var key in this.container) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  var newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n  this.setContext(this.contexts[this.contexts.length - 1]);\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.inList = !!listKey;\n  this.listKey = listKey;\n  this.parentKey = listKey || key;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = this.node && this.node.type;\n}\n\nfunction requeue(pathToQueue) {\n  if (pathToQueue === void 0) {\n    pathToQueue = this;\n  }\n\n  if (pathToQueue.removed) return;\n  var contexts = this.contexts;\n\n  for (var _iterator2 = contexts, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref2 = _i2.value;\n    }\n\n    var _context = _ref2;\n\n    _context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  var path = this;\n  var contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar _babelHelperFunctionName = _interopRequireDefault(require(\"babel-helper-function-name\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction toComputedKey() {\n  var node = this.node;\n  var key;\n\n  if (this.isMemberExpression()) {\n    key = node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  var body = this.get(\"body\");\n  var bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  var statements = [];\n  var stringPath = \"body\";\n  var key;\n  var listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  var parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$allowInsertArrow = _ref.allowInsertArrow,\n      allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,\n      _ref$specCompliant = _ref.specCompliant,\n      specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant;\n\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  var thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (specCompliant) {\n    var checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.file.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _babelHelperFunctionName.default)(this) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, specCompliant, allowInsertArrow) {\n  if (specCompliant === void 0) {\n    specCompliant = false;\n  }\n\n  if (allowInsertArrow === void 0) {\n    allowInsertArrow = true;\n  }\n\n  var thisEnvFn = fnPath.findParent(function (p) {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  var inConstructor = thisEnvFn && thisEnvFn.node.kind === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  var _getScopeInformation = getScopeInformation(fnPath),\n      thisPaths = _getScopeInformation.thisPaths,\n      argumentsPaths = _getScopeInformation.argumentsPaths,\n      newTargetPaths = _getScopeInformation.newTargetPaths,\n      superProps = _getScopeInformation.superProps,\n      superCalls = _getScopeInformation.superCalls;\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    var allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function: function Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n      ClassProperty: function ClassProperty(child) {\n        if (child.node.static) return;\n        child.skip();\n      },\n      CallExpression: function CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n    });\n    var superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(function (superCall) {\n      return superCall.get(\"callee\").replaceWith(t.identifier(superBinding));\n    });\n  }\n\n  var thisBinding;\n\n  if (thisPaths.length > 0 || specCompliant) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(function (thisChild) {\n        thisChild.replaceWith(thisChild.isJSX() ? t.jSXIdentifier(thisBinding) : t.identifier(thisBinding));\n      });\n      if (specCompliant) thisBinding = null;\n    }\n  }\n\n  if (argumentsPaths.length > 0) {\n    var argumentsBinding = getBinding(thisEnvFn, \"arguments\", function () {\n      return t.identifier(\"arguments\");\n    });\n    argumentsPaths.forEach(function (argumentsChild) {\n      argumentsChild.replaceWith(t.identifier(argumentsBinding));\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    var newTargetBinding = getBinding(thisEnvFn, \"newtarget\", function () {\n      return t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\"));\n    });\n    newTargetPaths.forEach(function (argumentsChild) {\n      argumentsChild.replaceWith(t.identifier(newTargetBinding));\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    var flatSuperProps = superProps.reduce(function (acc, superProp) {\n      return acc.concat(standardizeSuperProperty(superProp));\n    }, []);\n    flatSuperProps.forEach(function (superProp) {\n      var key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n\n      if (superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      })) {\n        var _superBinding = getSuperPropCallBinding(thisEnvFn, key);\n\n        if (superProp.node.computed) {\n          var prop = superProp.get(\"property\").node;\n          superProp.replaceWith(t.identifier(_superBinding));\n          superProp.parentPath.node.arguments.unshift(prop);\n        } else {\n          superProp.replaceWith(t.identifier(_superBinding));\n        }\n      } else {\n        var isAssignment = superProp.parentPath.isAssignmentExpression({\n          left: superProp.node\n        });\n\n        var _superBinding2 = getSuperPropBinding(thisEnvFn, isAssignment, key);\n\n        var args = [];\n\n        if (superProp.node.computed) {\n          args.push(superProp.get(\"property\").node);\n        }\n\n        if (isAssignment) {\n          var value = superProp.parentPath.node.right;\n          args.push(value);\n          superProp.parentPath.replaceWith(t.callExpression(t.identifier(_superBinding2), args));\n        } else {\n          superProp.replaceWith(t.callExpression(t.identifier(_superBinding2), args));\n        }\n      }\n    });\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    var assignmentPath = superProp.parentPath;\n    var op = assignmentPath.node.operator.slice(0, -1);\n    var value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      var tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    var updateExpr = superProp.parentPath;\n\n    var _tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n\n    var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    var parts = [t.assignmentExpression(\"=\", _tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(_tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(_tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    var left = updateExpr.get(\"expressions.0.right\");\n    var right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", function (thisBinding) {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    var supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function: function Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n      ClassProperty: function ClassProperty(child) {\n        if (child.node.static) return;\n        child.skip();\n      },\n      CallExpression: function CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWith(t.assignmentExpression(\"=\", t.identifier(thisBinding), child.node));\n      }\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", function () {\n    var argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropCallBinding(thisEnvFn, propName) {\n  return getBinding(thisEnvFn, \"superprop_call:\" + (propName || \"\"), function () {\n    var argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    var argsList = [t.restElement(argsBinding)];\n    var fnBody;\n\n    if (propName) {\n      fnBody = t.callExpression(t.memberExpression(t.super(), t.identifier(propName)), [t.spreadElement(t.identifier(argsBinding.name))]);\n    } else {\n      var method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.callExpression(t.memberExpression(t.super(), t.identifier(method.name), true), [t.spreadElement(t.identifier(argsBinding.name))]);\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  var op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, \"superprop_\" + op + \":\" + (propName || \"\"), function () {\n    var argsList = [];\n    var fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      var method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      var valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  var cacheKey = \"binding:\" + key;\n  var data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    var id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  var thisPaths = [];\n  var argumentsPaths = [];\n  var newTargetPaths = [];\n  var superProps = [];\n  var superCalls = [];\n  fnPath.traverse({\n    ClassProperty: function ClassProperty(child) {\n      if (child.node.static) return;\n      child.skip();\n    },\n    Function: function Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n    ThisExpression: function ThisExpression(child) {\n      thisPaths.push(child);\n    },\n    JSXIdentifier: function JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n    CallExpression: function CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n    MemberExpression: function MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n    ReferencedIdentifier: function ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n    MetaProperty: function MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n  });\n  return {\n    thisPaths: thisPaths,\n    argumentsPaths: argumentsPaths,\n    newTargetPaths: newTargetPaths,\n    superProps: superProps,\n    superCalls: superCalls\n  };\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nvar INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  var res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  var node = path.node;\n  var seen = state.seen;\n\n  if (seen.has(node)) {\n    var existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    var item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    var val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  var node = path.node;\n\n  if (path.isSequenceExpression()) {\n    var exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    var object = path.get(\"tag.object\");\n    var name = object.node.name;\n    var property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name, true) && property.isIdentifier && property.node.name === \"raw\") {\n      return evaluateQuasis(path, node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    var testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: node\n  })) {\n    var _property = path.get(\"property\");\n\n    var _object = path.get(\"object\");\n\n    if (_object.isLiteral() && _property.isIdentifier()) {\n      var value = _object.node.value;\n\n      var type = _typeof(value);\n\n      if (type === \"number\" || type === \"string\") {\n        return value[_property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    var binding = path.scope.getBinding(node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      var resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (node.operator === \"void\") {\n      return undefined;\n    }\n\n    var argument = path.get(\"argument\");\n\n    if (node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    var arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return _typeof(arg);\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    var arr = [];\n    var elems = path.get(\"elements\");\n\n    for (var _iterator = elems, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var _elem = _ref;\n      _elem = _elem.evaluate();\n\n      if (_elem.confident) {\n        arr.push(_elem.value);\n      } else {\n        return deopt(_elem, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    var obj = {};\n    var props = path.get(\"properties\");\n\n    for (var _iterator2 = props, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var _prop = _ref2;\n\n      if (_prop.isObjectMethod() || _prop.isSpreadElement()) {\n        return deopt(_prop, state);\n      }\n\n      var keyPath = _prop.get(\"key\");\n\n      var key = keyPath;\n\n      if (_prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(keyPath, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      var valuePath = _prop.get(\"value\");\n\n      var _value2 = valuePath.evaluate();\n\n      if (!_value2.confident) {\n        return deopt(valuePath, state);\n      }\n\n      _value2 = _value2.value;\n      obj[key] = _value2;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    var wasConfident = state.confident;\n    var left = evaluateCached(path.get(\"left\"), state);\n    var leftConfident = state.confident;\n    state.confident = wasConfident;\n    var right = evaluateCached(path.get(\"right\"), state);\n    var rightConfident = state.confident;\n    state.confident = leftConfident && rightConfident;\n\n    switch (node.operator) {\n      case \"||\":\n        if (left && leftConfident) {\n          state.confident = true;\n          return left;\n        }\n\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        if (!left && leftConfident || !right && rightConfident) {\n          state.confident = true;\n        }\n\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    var _left = evaluateCached(path.get(\"left\"), state);\n\n    if (!state.confident) return;\n\n    var _right = evaluateCached(path.get(\"right\"), state);\n\n    if (!state.confident) return;\n\n    switch (node.operator) {\n      case \"-\":\n        return _left - _right;\n\n      case \"+\":\n        return _left + _right;\n\n      case \"/\":\n        return _left / _right;\n\n      case \"*\":\n        return _left * _right;\n\n      case \"%\":\n        return _left % _right;\n\n      case \"**\":\n        return Math.pow(_left, _right);\n\n      case \"<\":\n        return _left < _right;\n\n      case \">\":\n        return _left > _right;\n\n      case \"<=\":\n        return _left <= _right;\n\n      case \">=\":\n        return _left >= _right;\n\n      case \"==\":\n        return _left == _right;\n\n      case \"!=\":\n        return _left != _right;\n\n      case \"===\":\n        return _left === _right;\n\n      case \"!==\":\n        return _left !== _right;\n\n      case \"|\":\n        return _left | _right;\n\n      case \"&\":\n        return _left & _right;\n\n      case \"^\":\n        return _left ^ _right;\n\n      case \"<<\":\n        return _left << _right;\n\n      case \">>\":\n        return _left >> _right;\n\n      case \">>>\":\n        return _left >>> _right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    var callee = path.get(\"callee\");\n    var context;\n    var func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[node.callee.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      var _object2 = callee.get(\"object\");\n\n      var _property2 = callee.get(\"property\");\n\n      if (_object2.isIdentifier() && _property2.isIdentifier() && VALID_CALLEES.indexOf(_object2.node.name) >= 0 && INVALID_METHODS.indexOf(_property2.node.name) < 0) {\n        context = global[_object2.node.name];\n        func = context[_property2.node.name];\n      }\n\n      if (_object2.isLiteral() && _property2.isIdentifier()) {\n        var _type = _typeof(_object2.node.value);\n\n        if (_type === \"string\" || _type === \"number\") {\n          context = _object2.node.value;\n          func = context[_property2.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      var args = path.get(\"arguments\").map(function (arg) {\n        return evaluateCached(arg, state);\n      });\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw) {\n  if (raw === void 0) {\n    raw = false;\n  }\n\n  var str = \"\";\n  var i = 0;\n  var exprs = path.get(\"expressions\");\n\n  for (var _iterator3 = quasis, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var _elem2 = _ref3;\n    if (!state.confident) break;\n    str += raw ? _elem2.value.raw : _elem2.value.cooked;\n    var expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  var state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  var value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n}\n\nfunction addCompletionRecords(path, paths) {\n  if (path) return paths.concat(path.getCompletionRecords());\n  return paths;\n}\n\nfunction getCompletionRecords() {\n  var paths = [];\n\n  if (this.isIfStatement()) {\n    paths = addCompletionRecords(this.get(\"consequent\"), paths);\n    paths = addCompletionRecords(this.get(\"alternate\"), paths);\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    paths = addCompletionRecords(this.get(\"body\").pop(), paths);\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    paths = addCompletionRecords(this.get(\"block\"), paths);\n    paths = addCompletionRecords(this.get(\"handler\"), paths);\n    paths = addCompletionRecords(this.get(\"finalizer\"), paths);\n  } else if (this.isCatchClause()) {\n    paths = addCompletionRecords(this.get(\"body\"), paths);\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  });\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  var _key = this.key;\n  var sibling = this.getSibling(++_key);\n  var siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  var _key = this.key;\n  var sibling = this.getSibling(--_key);\n  var siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context) {\n  if (context === true) context = this.context;\n  var parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  var _this = this;\n\n  var node = this.node;\n  var container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map(function (_, i) {\n      return _index.default.get({\n        listKey: key,\n        parentPath: _this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  var path = this;\n  var _arr = parts;\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var part = _arr[_i];\n\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates, outerOnly) {\n  if (duplicates === void 0) {\n    duplicates = false;\n  }\n\n  if (outerOnly === void 0) {\n    outerOnly = false;\n  }\n\n  var path = this;\n  var search = [].concat(path);\n  var ids = Object.create(null);\n\n  while (search.length) {\n    var id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    var keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        var _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      var declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./lib/virtual-types\"));\n\nvar _debug2 = _interopRequireDefault(require(\"debug\"));\n\nvar _invariant = _interopRequireDefault(require(\"invariant\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _scope = _interopRequireDefault(require(\"../scope\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar _cache = require(\"../cache\");\n\nvar NodePath_ancestry = _interopRequireWildcard(require(\"./ancestry\"));\n\nvar NodePath_inference = _interopRequireWildcard(require(\"./inference\"));\n\nvar NodePath_replacement = _interopRequireWildcard(require(\"./replacement\"));\n\nvar NodePath_evaluation = _interopRequireWildcard(require(\"./evaluation\"));\n\nvar NodePath_conversion = _interopRequireWildcard(require(\"./conversion\"));\n\nvar NodePath_introspection = _interopRequireWildcard(require(\"./introspection\"));\n\nvar NodePath_context = _interopRequireWildcard(require(\"./context\"));\n\nvar NodePath_removal = _interopRequireWildcard(require(\"./removal\"));\n\nvar NodePath_modification = _interopRequireWildcard(require(\"./modification\"));\n\nvar NodePath_family = _interopRequireWildcard(require(\"./family\"));\n\nvar NodePath_comments = _interopRequireWildcard(require(\"./comments\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar _debug = (0, _debug2.default)(\"babel\");\n\nvar NodePath = function () {\n  function NodePath(hub, parent) {\n    this.parent = parent;\n    this.hub = hub;\n    this.contexts = [];\n    this.data = {};\n    this.shouldSkip = false;\n    this.shouldStop = false;\n    this.removed = false;\n    this.state = null;\n    this.opts = null;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.context = null;\n    this.container = null;\n    this.listKey = null;\n    this.inList = false;\n    this.parentKey = null;\n    this.key = null;\n    this.node = null;\n    this.scope = null;\n    this.type = null;\n    this.typeAnnotation = null;\n  }\n\n  NodePath.get = function get(_ref) {\n    var hub = _ref.hub,\n        parentPath = _ref.parentPath,\n        parent = _ref.parent,\n        container = _ref.container,\n        listKey = _ref.listKey,\n        key = _ref.key;\n\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    (0, _invariant.default)(parent, \"To get a node path the parent needs to exist\");\n    var targetNode = container[key];\n    var paths = _cache.path.get(parent) || [];\n\n    if (!_cache.path.has(parent)) {\n      _cache.path.set(parent, paths);\n    }\n\n    var path;\n\n    for (var i = 0; i < paths.length; i++) {\n      var pathCheck = paths[i];\n\n      if (pathCheck.node === targetNode) {\n        path = pathCheck;\n        break;\n      }\n    }\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      paths.push(path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  };\n\n  var _proto = NodePath.prototype;\n\n  _proto.getScope = function getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  };\n\n  _proto.setData = function setData(key, val) {\n    return this.data[key] = val;\n  };\n\n  _proto.getData = function getData(key, def) {\n    var val = this.data[key];\n    if (!val && def) val = this.data[key] = def;\n    return val;\n  };\n\n  _proto.buildCodeFrameError = function buildCodeFrameError(msg, Error) {\n    if (Error === void 0) {\n      Error = SyntaxError;\n    }\n\n    return this.hub.file.buildCodeFrameError(this.node, msg, Error);\n  };\n\n  _proto.traverse = function traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  };\n\n  _proto.set = function set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  };\n\n  _proto.getPathLocation = function getPathLocation() {\n    var parts = [];\n    var path = this;\n\n    do {\n      var key = path.key;\n      if (path.inList) key = path.listKey + \"[\" + key + \"]\";\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  };\n\n  _proto.debug = function debug(message) {\n    if (!_debug.enabled) return;\n\n    _debug(this.getPathLocation() + \" \" + this.type + \": \" + message);\n  };\n\n  return NodePath;\n}();\n\nexports.default = NodePath;\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nvar _loop = function _loop(type) {\n  var typeKey = \"is\" + type;\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return t[typeKey](this.node, opts);\n  };\n\n  NodePath.prototype[\"assert\" + type] = function (opts) {\n    if (!this[typeKey](opts)) {\n      throw new TypeError(\"Expected node path of type \" + type);\n    }\n  };\n};\n\nvar _arr = t.TYPES;\n\nfor (var _i = 0; _i < _arr.length; _i++) {\n  var type = _arr[_i];\n\n  _loop(type);\n}\n\nvar _loop2 = function _loop2(type) {\n  if (type[0] === \"_\") return \"continue\";\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  var virtualType = virtualTypes[type];\n\n  NodePath.prototype[\"is\" + type] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n};\n\nfor (var type in virtualTypes) {\n  var _ret = _loop2(type);\n\n  if (_ret === \"continue\") continue;\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = _interopRequireWildcard(require(\"./inferers\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  var type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nfunction _getTypeAnnotation() {\n  var node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      var declar = this.parentPath.parentPath;\n      var declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  var inferer = inferers[node.type];\n\n  if (inferer) {\n    return inferer.call(this, node);\n  }\n\n  inferer = inferers[this.parentPath.type];\n\n  if (inferer && inferer.validParent) {\n    return this.parentPath.getTypeAnnotation();\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(\"Unknown base type \" + baseName);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  var type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    var _arr = type.types;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var type2 = _arr[_i];\n\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(right) {\n  var left = this.getTypeAnnotation();\n  right = right.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n}\n\nfunction isGenericType(genericName) {\n  var type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.default = _default;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  var binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  var types = [];\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  var testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n    var _arr = constantViolations;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var violation = _arr[_i];\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n\n    var status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n  var target;\n\n  if (left.isIdentifier({\n    name: name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name: name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  var typeofPath;\n  var typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name: name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  var parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  var ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  for (var i = 0; i < paths.length; i++) {\n    var _path = paths[i];\n\n    if (_path.isLogicalExpression()) {\n      if (_path.node.operator === \"&&\") {\n        paths.push(_path.get(\"left\"));\n        paths.push(_path.get(\"right\"));\n      }\n    } else if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function get() {\n    return _infererReference.default;\n  }\n});\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar _infererReference = _interopRequireDefault(require(\"./inferer-reference\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction VariableDeclarator() {\n  var id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  var init = this.get(\"init\");\n  var type = init.getTypeAnnotation();\n\n  if (type && type.type === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  var operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  var operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    var right = this.get(\"right\");\n    var left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  return t.createUnionTypeAnnotation([this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()]);\n}\n\nfunction ConditionalExpression() {\n  return t.createUnionTypeAnnotation([this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()]);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  var operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nvar isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nvar isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nvar isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nvar isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  var callee = this.node.callee;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.is = void 0;\n\nvar _includes = _interopRequireDefault(require(\"lodash/includes\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  var val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nvar is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  var path = this;\n  var first = true;\n\n  do {\n    var container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return (0, _includes.default)(t.STATEMENT_OR_BLOCK_KEYS, this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n  var binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  var path = binding.path;\n  var parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  var node = this.node;\n\n  if (node.end) {\n    return this.hub.file.code.slice(node.start, node.end);\n  } else {\n    return \"\";\n  }\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  var targetFuncParent = target.scope.getFunctionParent() || target.scope.getProgramParent();\n  var selfFuncParent = this.scope.getFunctionParent() || target.scope.getProgramParent();\n\n  if (targetFuncParent.node !== selfFuncParent.node) {\n    var status = this._guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent);\n\n    if (status) {\n      return status;\n    } else {\n      target = targetFuncParent.path;\n    }\n  }\n\n  var targetPaths = target.getAncestry();\n  if (targetPaths.indexOf(this) >= 0) return \"after\";\n  var selfPaths = this.getAncestry();\n  var commonPath;\n  var targetIndex;\n  var selfIndex;\n\n  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {\n    var selfPath = selfPaths[selfIndex];\n    targetIndex = targetPaths.indexOf(selfPath);\n\n    if (targetIndex >= 0) {\n      commonPath = selfPath;\n      break;\n    }\n  }\n\n  if (!commonPath) {\n    return \"before\";\n  }\n\n  var targetRelationship = targetPaths[targetIndex - 1];\n  var selfRelationship = selfPaths[selfIndex - 1];\n\n  if (!targetRelationship || !selfRelationship) {\n    return \"before\";\n  }\n\n  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {\n    return targetRelationship.key > selfRelationship.key ? \"before\" : \"after\";\n  }\n\n  var keys = t.VISITOR_KEYS[commonPath.type];\n  var targetKeyPosition = keys.indexOf(targetRelationship.key);\n  var selfKeyPosition = keys.indexOf(selfRelationship.key);\n  return targetKeyPosition > selfKeyPosition ? \"before\" : \"after\";\n}\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(targetFuncParent) {\n  var targetFuncPath = targetFuncParent.path;\n  if (!targetFuncPath.isFunctionDeclaration()) return;\n  var binding = targetFuncPath.scope.getBinding(targetFuncPath.node.id.name);\n  if (!binding.references) return \"before\";\n  var referencePaths = binding.referencePaths;\n\n  for (var _iterator = referencePaths, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var _path2 = _ref;\n\n    if (_path2.key !== \"callee\" || !_path2.parentPath.isCallExpression()) {\n      return;\n    }\n  }\n\n  var allStatus;\n\n  for (var _iterator2 = referencePaths, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref2 = _i2.value;\n    }\n\n    var _path3 = _ref2;\n    var childOfFunction = !!_path3.find(function (path) {\n      return path.node === targetFuncPath.node;\n    });\n    if (childOfFunction) continue;\n\n    var status = this._guessExecutionStatusRelativeTo(_path3);\n\n    if (allStatus) {\n      if (allStatus !== status) return;\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    var binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      var ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(function (parent) {\n        return parent.node === ret.node;\n      })) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    var targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    var targetName = targetKey.value;\n    var target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      var props = target.get(\"properties\");\n      var _arr = props;\n\n      for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n        var prop = _arr[_i3];\n        if (!prop.isProperty()) continue;\n        var key = prop.get(\"key\");\n        var match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      var elems = target.get(\"elements\");\n      var elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar referenceVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      var scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    var binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n};\n\nvar PathHoister = function () {\n  function PathHoister(path, scope) {\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  var _proto = PathHoister.prototype;\n\n  _proto.isCompatibleScope = function isCompatibleScope(scope) {\n    for (var key in this.bindings) {\n      var binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  _proto.getCompatibleScopes = function getCompatibleScopes() {\n    var scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  };\n\n  _proto.getAttachmentPath = function getAttachmentPath() {\n    var path = this._getAttachmentPath();\n\n    if (!path) return;\n    var targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (var name in this.bindings) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        var binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        var bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n          var _arr = binding.constantViolations;\n\n          for (var _i = 0; _i < _arr.length; _i++) {\n            var violationPath = _arr[_i];\n\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    if (path.parentPath.isExportDeclaration()) {\n      path = path.parentPath;\n    }\n\n    return path;\n  };\n\n  _proto._getAttachmentPath = function _getAttachmentPath() {\n    var scopes = this.scopes;\n    var scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        var bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (var i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  };\n\n  _proto.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {\n    var scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  };\n\n  _proto.getAttachmentParentForPath = function getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  };\n\n  _proto.hasOwnParamBindings = function hasOwnParamBindings(scope) {\n    for (var name in this.bindings) {\n      if (!scope.hasOwnBinding(name)) continue;\n      var binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  };\n\n  _proto.run = function run() {\n    this.path.traverse(referenceVisitor, this);\n    this.getCompatibleScopes();\n    var attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    var uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    var declarator = t.variableDeclarator(uid, this.path.node);\n    var insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    var parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(uid);\n  };\n\n  return PathHoister;\n}();\n\nexports.default = PathHoister;","\"use strict\";\n\nexports.__esModule = true;\nexports.hooks = void 0;\nvar hooks = [function (self, parent) {\n  var removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nexports.__esModule = true;\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n  checkPath: function checkPath(_ref, opts) {\n    var node = _ref.node,\n        parent = _ref.parent;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent);\n  }\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nvar ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n  checkPath: function checkPath(_ref2) {\n    var node = _ref2.node,\n        parent = _ref2.parent;\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nvar BindingIdentifier = {\n  types: [\"Identifier\"],\n  checkPath: function checkPath(_ref3) {\n    var node = _ref3.node,\n        parent = _ref3.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent);\n  }\n};\nexports.BindingIdentifier = BindingIdentifier;\nvar Statement = {\n  types: [\"Statement\"],\n  checkPath: function checkPath(_ref4) {\n    var node = _ref4.node,\n        parent = _ref4.parent;\n\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\nexports.Statement = Statement;\nvar Expression = {\n  types: [\"Expression\"],\n  checkPath: function checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n};\nexports.Expression = Expression;\nvar Scope = {\n  types: [\"Scopable\"],\n  checkPath: function checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n};\nexports.Scope = Scope;\nvar Referenced = {\n  checkPath: function checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n};\nexports.Referenced = Referenced;\nvar BlockScoped = {\n  checkPath: function checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n};\nexports.BlockScoped = BlockScoped;\nvar Var = {\n  types: [\"VariableDeclaration\"],\n  checkPath: function checkPath(path) {\n    return t.isVar(path.node);\n  }\n};\nexports.Var = Var;\nvar User = {\n  checkPath: function checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n};\nexports.User = User;\nvar Generated = {\n  checkPath: function checkPath(path) {\n    return !path.isUser();\n  }\n};\nexports.Generated = Generated;\nvar Pure = {\n  checkPath: function checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n};\nexports.Pure = Pure;\nvar Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n  checkPath: function checkPath(_ref5) {\n    var node = _ref5.node;\n\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n};\nexports.Flow = Flow;\nvar RestProperty = {\n  types: [\"RestElement\"],\n  checkPath: function checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n};\nexports.RestProperty = RestProperty;\nvar SpreadProperty = {\n  types: [\"RestElement\"],\n  checkPath: function checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n};\nexports.SpreadProperty = SpreadProperty;\nvar ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nvar NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nvar ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n  checkPath: function checkPath(_ref6) {\n    var node = _ref6.node;\n    return node.await === true;\n  }\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nexports.__esModule = true;\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = _interopRequireDefault(require(\"./lib/hoister\"));\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {\n    return this.parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && this.listKey !== \"params\" && this.listKey !== \"arguments\" || this.parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  var _container;\n\n  this.updateSiblingKeys(from, nodes.length);\n  var paths = [];\n\n  (_container = this.container).splice.apply(_container, [from, 0].concat(nodes));\n\n  for (var i = 0; i < nodes.length; i++) {\n    var to = from + i;\n    var path = this.getSibling(\"\" + to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  var contexts = this._getQueueContexts();\n\n  for (var _i = 0; _i < paths.length; _i++) {\n    var _path = paths[_i];\n\n    _path.setScope();\n\n    _path.debug(\"Inserted.\");\n\n    for (var _iterator = contexts, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i2 >= _iterator.length) break;\n        _ref = _iterator[_i2++];\n      } else {\n        _i2 = _iterator.next();\n        if (_i2.done) break;\n        _ref = _i2.value;\n      }\n\n      var _context = _ref;\n\n      _context.maybeQueue(_path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {\n    return this.parentPath.insertAfter(nodes);\n  } else if (this.isNodeType(\"Expression\") || this.parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      var temp = this.scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", temp, this.node)));\n      nodes.push(t.expressionStatement(temp));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    var shouldInsertCurrentNode = this.node && (!this.isExpressionStatement() || this.node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [this.node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  var paths = _cache.path.get(this.parent);\n\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var msg = void 0;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (_typeof(node) !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      var type = Array.isArray(node) ? \"array\" : _typeof(node);\n      throw new Error(\"Node list \" + msg + \" with the index of \" + i + \" and type of \" + type);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  var path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey: listKey,\n    key: 0\n  });\n\n  return path.insertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n  var container = this.node[listKey];\n\n  var path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey: listKey,\n    key: container.length\n  });\n\n  return path.replaceWithMultiple(nodes);\n}\n\nfunction hoist(scope) {\n  if (scope === void 0) {\n    scope = this.scope;\n  }\n\n  var hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.remove = remove;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nfunction remove() {\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _callRemovalHooks() {\n  var _arr = _removalHooks.hooks;\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fn = _arr[_i];\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this.shouldSkip = true;\n  this.removed = true;\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _babelCodeFrame = require(\"babel-code-frame\");\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _index2 = _interopRequireDefault(require(\"./index\"));\n\nvar _babylon = require(\"babylon\");\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar hoistVariablesVisitor = {\n  Function: function Function(path) {\n    path.skip();\n  },\n  VariableDeclaration: function VariableDeclaration(path) {\n    if (path.node.kind !== \"var\") return;\n    var bindings = path.getBindingIdentifiers();\n\n    for (var key in bindings) {\n      path.scope.push({\n        id: bindings[key]\n      });\n    }\n\n    var exprs = [];\n    var _arr = path.node.declarations;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var declar = _arr[_i];\n\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    path.replaceWithMultiple(exprs);\n  }\n};\n\nfunction replaceWithMultiple(nodes) {\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  this.node = this.container[this.key] = null;\n  var paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = \"(\" + replacement + \")\";\n    replacement = (0, _babylon.parse)(replacement);\n  } catch (err) {\n    var loc = err.loc;\n\n    if (loc) {\n      err.loc = null;\n      err.message += \" - make sure this is an expression.\\n\" + (0, _babelCodeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  var nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  var oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(\"Replace with \" + (node && node.type));\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  var toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  var container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  this.traverse(hoistVariablesVisitor);\n  var completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (var _iterator = completionRecords, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i2 >= _iterator.length) break;\n      _ref = _iterator[_i2++];\n    } else {\n      _i2 = _iterator.next();\n      if (_i2.done) break;\n      _ref = _i2.value;\n    }\n\n    var _path = _ref;\n    if (!_path.isExpressionStatement()) continue;\n\n    var loop = _path.findParent(function (path) {\n      return path.isLoop();\n    });\n\n    if (loop) {\n      var uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        var _callee = this.get(\"callee\");\n\n        uid = _callee.scope.generateDeclaredUidIdentifier(\"ret\");\n\n        _callee.get(\"body\").pushContainer(\"body\", t.returnStatement(uid));\n\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      _path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", uid, _path.node.expression));\n    } else {\n      _path.replaceWith(t.returnStatement(_path.node.expression));\n    }\n  }\n\n  var callee = this.get(\"callee\");\n  callee.arrowFunctionToExpression();\n  return callee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      var paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar Binding = function () {\n  function Binding(_ref) {\n    var identifier = _ref.identifier,\n        scope = _ref.scope,\n        path = _ref.path,\n        kind = _ref.kind;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.clearValue();\n  }\n\n  var _proto = Binding.prototype;\n\n  _proto.deoptValue = function deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  };\n\n  _proto.setValue = function setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  };\n\n  _proto.clearValue = function clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  };\n\n  _proto.reassign = function reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  };\n\n  _proto.reference = function reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  };\n\n  _proto.dereference = function dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  };\n\n  return Binding;\n}();\n\nexports.default = Binding;","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _includes = _interopRequireDefault(require(\"lodash/includes\"));\n\nvar _repeat = _interopRequireDefault(require(\"lodash/repeat\"));\n\nvar _renamer = _interopRequireDefault(require(\"./lib/renamer\"));\n\nvar _index = _interopRequireDefault(require(\"../index\"));\n\nvar _defaults = _interopRequireDefault(require(\"lodash/defaults\"));\n\nvar _binding2 = _interopRequireDefault(require(\"./binding\"));\n\nvar _globals = _interopRequireDefault(require(\"globals\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar _cache = require(\"../cache\");\n\nvar _class, _temp;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _crawlCallsCount = 0;\n\nfunction gatherNodeParts(node, parts) {\n  if (t.isModuleDeclaration(node)) {\n    if (node.source) {\n      gatherNodeParts(node.source, parts);\n    } else if (node.specifiers && node.specifiers.length) {\n      var _arr = node.specifiers;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var specifier = _arr[_i];\n        gatherNodeParts(specifier, parts);\n      }\n    } else if (node.declaration) {\n      gatherNodeParts(node.declaration, parts);\n    }\n  } else if (t.isModuleSpecifier(node)) {\n    gatherNodeParts(node.local, parts);\n  } else if (t.isMemberExpression(node)) {\n    gatherNodeParts(node.object, parts);\n    gatherNodeParts(node.property, parts);\n  } else if (t.isIdentifier(node)) {\n    parts.push(node.name);\n  } else if (t.isLiteral(node)) {\n    parts.push(node.value);\n  } else if (t.isCallExpression(node)) {\n    gatherNodeParts(node.callee, parts);\n  } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {\n    var _arr2 = node.properties;\n\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var prop = _arr2[_i2];\n      gatherNodeParts(prop.key || prop.argument, parts);\n    }\n  }\n}\n\nvar collectorVisitor = {\n  For: function For(path) {\n    var _arr3 = t.FOR_INIT_KEYS;\n\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var key = _arr3[_i3];\n      var declar = path.get(key);\n\n      if (declar.isVar()) {\n        var parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n  Declaration: function Declaration(path) {\n    if (path.isBlockScoped()) return;\n\n    if (path.isExportDeclaration() && path.get(\"declaration\").isDeclaration()) {\n      return;\n    }\n\n    var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n  ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n  ForXStatement: function ForXStatement(path, state) {\n    var left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n  ExportDeclaration: {\n    exit: function exit(path) {\n      var node = path.node,\n          scope = path.scope;\n      var declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        var _id = declar.id;\n        if (!_id) return;\n        var binding = scope.getBinding(_id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        var _arr4 = declar.declarations;\n\n        for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n          var decl = _arr4[_i4];\n          var ids = t.getBindingIdentifiers(decl);\n\n          for (var name in ids) {\n            var _binding = scope.getBinding(name);\n\n            if (_binding) _binding.reference(path);\n          }\n        }\n      }\n    }\n  },\n  LabeledStatement: function LabeledStatement(path) {\n    path.scope.getProgramParent().addGlobal(path.node);\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n  AssignmentExpression: function AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n  UpdateExpression: function UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n  UnaryExpression: function UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n  BlockScoped: function BlockScoped(path) {\n    var scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    scope.getBlockParent().registerDeclaration(path);\n  },\n  ClassDeclaration: function ClassDeclaration(path) {\n    var id = path.node.id;\n    if (!id) return;\n    var name = id.name;\n    path.scope.bindings[name] = path.scope.getBinding(name);\n  },\n  Block: function Block(path) {\n    var paths = path.get(\"body\");\n    var _arr5 = paths;\n\n    for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n      var bodyPath = _arr5[_i5];\n\n      if (bodyPath.isFunctionDeclaration()) {\n        path.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  }\n};\nvar uid = 0;\nvar Scope = (_temp = _class = function () {\n  function Scope(path) {\n    var node = path.node;\n\n    var cached = _cache.scope.get(node);\n\n    if (cached && cached.path === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n  }\n\n  var _proto = Scope.prototype;\n\n  _proto.traverse = function traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  };\n\n  _proto.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier(name) {\n    if (name === void 0) {\n      name = \"temp\";\n    }\n\n    var id = this.generateUidIdentifier(name);\n    this.push({\n      id: id\n    });\n    return id;\n  };\n\n  _proto.generateUidIdentifier = function generateUidIdentifier(name) {\n    if (name === void 0) {\n      name = \"temp\";\n    }\n\n    return t.identifier(this.generateUid(name));\n  };\n\n  _proto.generateUid = function generateUid(name) {\n    if (name === void 0) {\n      name = \"temp\";\n    }\n\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    var uid;\n    var i = 0;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    var program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  };\n\n  _proto._generateUid = function _generateUid(name, i) {\n    var id = name;\n    if (i > 1) id += i;\n    return \"_\" + id;\n  };\n\n  _proto.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) {\n    var node = parent;\n\n    if (t.isAssignmentExpression(parent)) {\n      node = parent.left;\n    } else if (t.isVariableDeclarator(parent)) {\n      node = parent.id;\n    } else if (t.isObjectProperty(node) || t.isObjectMethod(node)) {\n      node = node.key;\n    }\n\n    var parts = [];\n    gatherNodeParts(node, parts);\n    var id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUidIdentifier(id.slice(0, 20));\n  };\n\n  _proto.isStatic = function isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      var binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  };\n\n  _proto.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      var _id2 = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) this.push({\n        id: _id2\n      });\n      return _id2;\n    }\n  };\n\n  _proto.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    if (kind === \"hoisted\" && local.kind === \"let\") return;\n    var duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.file.buildCodeFrameError(id, \"Duplicate declaration \\\"\" + name + \"\\\"\", TypeError);\n    }\n  };\n\n  _proto.rename = function rename(oldName, newName, block) {\n    var binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  };\n\n  _proto._renameFromMap = function _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  };\n\n  _proto.dump = function dump() {\n    var sep = (0, _repeat.default)(\"-\", 60);\n    console.log(sep);\n    var scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (var name in scope.bindings) {\n        var binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  };\n\n  _proto.toArray = function toArray(node, i) {\n    var file = this.hub.file;\n\n    if (t.isIdentifier(node)) {\n      var binding = this.getBinding(node.name);\n\n      if (binding && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    var helperName = \"toArray\";\n    var args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    }\n\n    return t.callExpression(file.addHelper(helperName), args);\n  };\n\n  _proto.hasLabel = function hasLabel(name) {\n    return !!this.getLabel(name);\n  };\n\n  _proto.getLabel = function getLabel(name) {\n    return this.labels.get(name);\n  };\n\n  _proto.registerLabel = function registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  };\n\n  _proto.registerDeclaration = function registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      var declarations = path.get(\"declarations\");\n      var _arr6 = declarations;\n\n      for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n        var declar = _arr6[_i6];\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      var specifiers = path.get(\"specifiers\");\n      var _arr7 = specifiers;\n\n      for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n        var specifier = _arr7[_i7];\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      var _declar = path.get(\"declaration\");\n\n      if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {\n        this.registerDeclaration(_declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  };\n\n  _proto.buildUndefinedNode = function buildUndefinedNode() {\n    if (this.hasBinding(\"undefined\")) {\n      return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n    } else {\n      return t.identifier(\"undefined\");\n    }\n  };\n\n  _proto.registerConstantViolation = function registerConstantViolation(path) {\n    var ids = path.getBindingIdentifiers();\n\n    for (var name in ids) {\n      var binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  };\n\n  _proto.registerBinding = function registerBinding(kind, path, bindingPath) {\n    if (bindingPath === void 0) {\n      bindingPath = path;\n    }\n\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      var declarators = path.get(\"declarations\");\n\n      for (var _iterator = declarators, _isArray = Array.isArray(_iterator), _i8 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i8 >= _iterator.length) break;\n          _ref = _iterator[_i8++];\n        } else {\n          _i8 = _iterator.next();\n          if (_i8.done) break;\n          _ref = _i8.value;\n        }\n\n        var _declar2 = _ref;\n        this.registerBinding(kind, _declar2);\n      }\n\n      return;\n    }\n\n    var parent = this.getProgramParent();\n    var ids = path.getBindingIdentifiers(true);\n\n    for (var name in ids) {\n      var _arr8 = ids[name];\n\n      for (var _i9 = 0; _i9 < _arr8.length; _i9++) {\n        var _id3 = _arr8[_i9];\n        var local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === _id3) continue;\n          this.checkBlockScopedCollisions(local, kind, name, _id3);\n        }\n\n        if (local && local.path.isFlow()) local = null;\n        parent.references[name] = true;\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding2.default({\n            identifier: _id3,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  };\n\n  _proto.addGlobal = function addGlobal(node) {\n    this.globals[node.name] = node;\n  };\n\n  _proto.hasUid = function hasUid(name) {\n    var scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  };\n\n  _proto.hasGlobal = function hasGlobal(name) {\n    var scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  };\n\n  _proto.hasReference = function hasReference(name) {\n    var scope = this;\n\n    do {\n      if (scope.references[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  };\n\n  _proto.isPure = function isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      var binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (var _iterator2 = node.body, _isArray2 = Array.isArray(_iterator2), _i10 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i10 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i10++];\n        } else {\n          _i10 = _iterator2.next();\n          if (_i10.done) break;\n          _ref2 = _i10.value;\n        }\n\n        var _method = _ref2;\n        if (!this.isPure(_method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      var _arr9 = node.elements;\n\n      for (var _i11 = 0; _i11 < _arr9.length; _i11++) {\n        var elem = _arr9[_i11];\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      var _arr10 = node.properties;\n\n      for (var _i12 = 0; _i12 < _arr10.length; _i12++) {\n        var prop = _arr10[_i12];\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isClassMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isClassProperty(node) || t.isObjectProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      var _arr11 = node.expressions;\n\n      for (var _i13 = 0; _i13 < _arr11.length; _i13++) {\n        var expression = _arr11[_i13];\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  };\n\n  _proto.setData = function setData(key, val) {\n    return this.data[key] = val;\n  };\n\n  _proto.getData = function getData(key) {\n    var scope = this;\n\n    do {\n      var data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  };\n\n  _proto.removeData = function removeData(key) {\n    var scope = this;\n\n    do {\n      var data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  };\n\n  _proto.init = function init() {\n    if (!this.references) this.crawl();\n  };\n\n  _proto.crawl = function crawl() {\n    _crawlCallsCount++;\n\n    this._crawl();\n\n    _crawlCallsCount--;\n  };\n\n  _proto._crawl = function _crawl() {\n    var path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    if (path.isLoop()) {\n      var _arr12 = t.FOR_INIT_KEYS;\n\n      for (var _i14 = 0; _i14 < _arr12.length; _i14++) {\n        var key = _arr12[_i14];\n        var node = path.get(key);\n        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);\n      }\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\")) {\n      if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path.get(\"id\"), path);\n      }\n    }\n\n    if (path.isClassExpression() && path.has(\"id\")) {\n      if (!path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n        this.registerBinding(\"local\", path);\n      }\n    }\n\n    if (path.isFunction()) {\n      var params = path.get(\"params\");\n\n      for (var _iterator3 = params, _isArray3 = Array.isArray(_iterator3), _i15 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray3) {\n          if (_i15 >= _iterator3.length) break;\n          _ref3 = _iterator3[_i15++];\n        } else {\n          _i15 = _iterator3.next();\n          if (_i15.done) break;\n          _ref3 = _i15.value;\n        }\n\n        var _param = _ref3;\n        this.registerBinding(\"param\", _param);\n      }\n    }\n\n    if (path.isCatchClause()) {\n      this.registerBinding(\"let\", path);\n    }\n\n    var parent = this.getProgramParent();\n    if (parent.crawling) return;\n    var state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (var _iterator4 = state.assignments, _isArray4 = Array.isArray(_iterator4), _i16 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i16 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i16++];\n      } else {\n        _i16 = _iterator4.next();\n        if (_i16.done) break;\n        _ref4 = _i16.value;\n      }\n\n      var _path3 = _ref4;\n\n      var ids = _path3.getBindingIdentifiers();\n\n      var programParent = void 0;\n\n      for (var name in ids) {\n        if (_path3.scope.getBinding(name)) continue;\n        programParent = programParent || _path3.scope.getProgramParent();\n        programParent.addGlobal(ids[name]);\n      }\n\n      _path3.scope.registerConstantViolation(_path3);\n    }\n\n    for (var _iterator5 = state.references, _isArray5 = Array.isArray(_iterator5), _i17 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n      var _ref5;\n\n      if (_isArray5) {\n        if (_i17 >= _iterator5.length) break;\n        _ref5 = _iterator5[_i17++];\n      } else {\n        _i17 = _iterator5.next();\n        if (_i17.done) break;\n        _ref5 = _i17.value;\n      }\n\n      var _ref7 = _ref5;\n\n      var binding = _ref7.scope.getBinding(_ref7.node.name);\n\n      if (binding) {\n        binding.reference(_ref7);\n      } else {\n        _ref7.scope.getProgramParent().addGlobal(_ref7.node);\n      }\n    }\n\n    for (var _iterator6 = state.constantViolations, _isArray6 = Array.isArray(_iterator6), _i18 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n      var _ref6;\n\n      if (_isArray6) {\n        if (_i18 >= _iterator6.length) break;\n        _ref6 = _iterator6[_i18++];\n      } else {\n        _i18 = _iterator6.next();\n        if (_i18.done) break;\n        _ref6 = _i18.value;\n      }\n\n      var _path4 = _ref6;\n\n      _path4.scope.registerConstantViolation(_path4);\n    }\n  };\n\n  _proto.push = function push(opts) {\n    var path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    var unique = opts.unique;\n    var kind = opts.kind || \"var\";\n    var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    var dataKey = \"declaration:\" + kind + \":\" + blockHoist;\n    var declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      var declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n\n      var _path$unshiftContaine = path.unshiftContainer(\"body\", [declar]);\n\n      declarPath = _path$unshiftContaine[0];\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    var declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  };\n\n  _proto.getProgramParent = function getProgramParent() {\n    var scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  };\n\n  _proto.getFunctionParent = function getFunctionParent() {\n    var scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  };\n\n  _proto.getBlockParent = function getBlockParent() {\n    var scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  };\n\n  _proto.getAllBindings = function getAllBindings() {\n    var ids = Object.create(null);\n    var scope = this;\n\n    do {\n      (0, _defaults.default)(ids, scope.bindings);\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  };\n\n  _proto.getAllBindingsOfKind = function getAllBindingsOfKind() {\n    var ids = Object.create(null);\n    var _arr13 = arguments;\n\n    for (var _i19 = 0; _i19 < _arr13.length; _i19++) {\n      var kind = _arr13[_i19];\n      var scope = this;\n\n      do {\n        for (var name in scope.bindings) {\n          var binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  };\n\n  _proto.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  };\n\n  _proto.warnOnFlowBinding = function warnOnFlowBinding(binding) {\n    if (_crawlCallsCount === 0 && binding && binding.path.isFlow()) {\n      console.warn(\"\\n        You or one of the Babel plugins you are using are using Flow declarations as bindings.\\n        Support for this will be removed in version 7. To find out the caller, grep for this\\n        message and change it to a `console.trace()`.\\n      \");\n    }\n\n    return binding;\n  };\n\n  _proto.getBinding = function getBinding(name) {\n    var scope = this;\n\n    do {\n      var binding = scope.getOwnBinding(name);\n      if (binding) return this.warnOnFlowBinding(binding);\n    } while (scope = scope.parent);\n  };\n\n  _proto.getOwnBinding = function getOwnBinding(name) {\n    return this.warnOnFlowBinding(this.bindings[name]);\n  };\n\n  _proto.getBindingIdentifier = function getBindingIdentifier(name) {\n    var info = this.getBinding(name);\n    return info && info.identifier;\n  };\n\n  _proto.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {\n    var binding = this.bindings[name];\n    return binding && binding.identifier;\n  };\n\n  _proto.hasOwnBinding = function hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  };\n\n  _proto.hasBinding = function hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && (0, _includes.default)(Scope.globals, name)) return true;\n    if (!noGlobals && (0, _includes.default)(Scope.contextVariables, name)) return true;\n    return false;\n  };\n\n  _proto.parentHasBinding = function parentHasBinding(name, noGlobals) {\n    return this.parent && this.parent.hasBinding(name, noGlobals);\n  };\n\n  _proto.moveBindingTo = function moveBindingTo(name, scope) {\n    var info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  };\n\n  _proto.removeOwnBinding = function removeOwnBinding(name) {\n    delete this.bindings[name];\n  };\n\n  _proto.removeBinding = function removeBinding(name) {\n    var info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n    }\n\n    var scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  };\n\n  _createClass(Scope, [{\n    key: \"parent\",\n    get: function get() {\n      var parent = this.path.findParent(function (p) {\n        return p.isScope();\n      });\n      return parent && parent.scope;\n    }\n  }, {\n    key: \"parentBlock\",\n    get: function get() {\n      return this.path.parent;\n    }\n  }, {\n    key: \"hub\",\n    get: function get() {\n      return this.path.hub;\n    }\n  }]);\n\n  return Scope;\n}(), Object.defineProperty(_class, \"globals\", {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: Object.keys(_globals.default.builtin)\n}), Object.defineProperty(_class, \"contextVariables\", {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  value: [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"]\n}), _temp);\nexports.default = Scope;","\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _binding = _interopRequireDefault(require(\"../binding\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar renameVisitor = {\n  ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {\n    var node = _ref.node;\n\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n    }\n  },\n  \"AssignmentExpression|Declaration\": function AssignmentExpressionDeclaration(path, state) {\n    var ids = path.getOuterBindingIdentifiers();\n\n    for (var name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n};\n\nvar Renamer = function () {\n  function Renamer(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  var _proto = Renamer.prototype;\n\n  _proto.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {\n    var exportDeclar = parentDeclar.parentPath.isExportDeclaration() && parentDeclar.parentPath;\n    if (!exportDeclar) return;\n    var isDefault = exportDeclar.isExportDefaultDeclaration();\n\n    if (isDefault && (parentDeclar.isFunctionDeclaration() || parentDeclar.isClassDeclaration()) && !parentDeclar.node.id) {\n      parentDeclar.node.id = parentDeclar.scope.generateUidIdentifier(\"default\");\n    }\n\n    var bindingIdentifiers = parentDeclar.getOuterBindingIdentifiers();\n    var specifiers = [];\n\n    for (var name in bindingIdentifiers) {\n      var localName = name === this.oldName ? this.newName : name;\n      var exportedName = isDefault ? \"default\" : name;\n      specifiers.push(t.exportSpecifier(t.identifier(localName), t.identifier(exportedName)));\n    }\n\n    if (specifiers.length) {\n      var aliasDeclar = t.exportNamedDeclaration(null, specifiers);\n\n      if (parentDeclar.isFunctionDeclaration()) {\n        aliasDeclar._blockHoist = 3;\n      }\n\n      exportDeclar.insertAfter(aliasDeclar);\n      exportDeclar.replaceWith(parentDeclar.node);\n    }\n  };\n\n  _proto.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  };\n\n  _proto.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  };\n\n  _proto.rename = function rename(block) {\n    var binding = this.binding,\n        oldName = this.oldName,\n        newName = this.newName;\n    var scope = binding.scope,\n        path = binding.path;\n    var parentDeclar = path.find(function (path) {\n      return path.isDeclaration() || path.isFunctionExpression();\n    });\n\n    if (parentDeclar) {\n      this.maybeConvertFromExportDeclaration(parentDeclar);\n    }\n\n    scope.traverse(block || scope.block, renameVisitor, this);\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (binding.type === \"hoisted\") {}\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  };\n\n  return Renamer;\n}();\n\nexports.default = Renamer;","\"use strict\";\n\nexports.__esModule = true;\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = _interopRequireWildcard(require(\"./path/lib/virtual-types\"));\n\nvar t = _interopRequireWildcard(require(\"babel-types\"));\n\nvar _clone = _interopRequireDefault(require(\"lodash/clone\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (var nodeType in visitor) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    var parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    var fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var _part = _ref;\n      visitor[_part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  var _arr = Object.keys(visitor);\n\n  for (var _i2 = 0; _i2 < _arr.length; _i2++) {\n    var _nodeType = _arr[_i2];\n    if (shouldIgnoreKey(_nodeType)) continue;\n    var wrapper = virtualTypes[_nodeType];\n    if (!wrapper) continue;\n    var _fns = visitor[_nodeType];\n\n    for (var type in _fns) {\n      _fns[type] = wrapCheck(wrapper, _fns[type]);\n    }\n\n    delete visitor[_nodeType];\n\n    if (wrapper.types) {\n      var _arr2 = wrapper.types;\n\n      for (var _i4 = 0; _i4 < _arr2.length; _i4++) {\n        var _type = _arr2[_i4];\n\n        if (visitor[_type]) {\n          mergePair(visitor[_type], _fns);\n        } else {\n          visitor[_type] = _fns;\n        }\n      }\n    } else {\n      mergePair(visitor, _fns);\n    }\n  }\n\n  for (var _nodeType2 in visitor) {\n    if (shouldIgnoreKey(_nodeType2)) continue;\n    var _fns2 = visitor[_nodeType2];\n    var aliases = t.FLIPPED_ALIAS_KEYS[_nodeType2];\n    var deprecratedKey = t.DEPRECATED_KEYS[_nodeType2];\n\n    if (deprecratedKey) {\n      console.trace(\"Visitor defined for \" + _nodeType2 + \" but it has been renamed to \" + deprecratedKey);\n      aliases = [deprecratedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[_nodeType2];\n\n    for (var _iterator2 = aliases, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i3 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i3++];\n      } else {\n        _i3 = _iterator2.next();\n        if (_i3.done) break;\n        _ref2 = _i3.value;\n      }\n\n      var _alias = _ref2;\n      var existing = visitor[_alias];\n\n      if (existing) {\n        mergePair(existing, _fns2);\n      } else {\n        visitor[_alias] = (0, _clone.default)(_fns2);\n      }\n    }\n  }\n\n  for (var _nodeType3 in visitor) {\n    if (shouldIgnoreKey(_nodeType3)) continue;\n    ensureCallbackArrays(visitor[_nodeType3]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (var nodeType in visitor) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(\"You gave us a visitor for the node type \" + nodeType + \" but it's not a valid type\");\n    }\n\n    var visitors = visitor[nodeType];\n\n    if (_typeof(visitors) === \"object\") {\n      for (var visitorKey in visitors) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(nodeType + \".\" + visitorKey, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + (nodeType + \" that has the invalid property \" + visitorKey));\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  var fns = [].concat(val);\n\n  for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i5 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i5 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i5++];\n    } else {\n      _i5 = _iterator3.next();\n      if (_i5.done) break;\n      _ref3 = _i5.value;\n    }\n\n    var _fn = _ref3;\n\n    if (typeof _fn !== \"function\") {\n      throw new TypeError(\"Non-function found defined in \" + path + \" with type \" + _typeof(_fn));\n    }\n  }\n}\n\nfunction merge(visitors, states, wrapper) {\n  if (states === void 0) {\n    states = [];\n  }\n\n  var rootVisitor = {};\n\n  for (var i = 0; i < visitors.length; i++) {\n    var visitor = visitors[i];\n    var state = states[i];\n    explode(visitor);\n\n    for (var type in visitor) {\n      var visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  var newVisitor = {};\n\n  var _loop = function _loop(key) {\n    var fns = oldVisitor[key];\n    if (!Array.isArray(fns)) return \"continue\";\n    fns = fns.map(function (fn) {\n      var newFn = fn;\n\n      if (state) {\n        newFn = function newFn(path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  };\n\n  for (var key in oldVisitor) {\n    var _ret = _loop(key);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (var key in obj) {\n    if (shouldIgnoreKey(key)) continue;\n    var fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  var newFn = function newFn(path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = function () {\n    return fn.toString();\n  };\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"blacklist\" || key === \"noScope\" || key === \"skipKeys\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (var key in src) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;\n\nvar _for = require(\"babel-runtime/core-js/symbol/for\");\n\nvar _for2 = _interopRequireDefault(_for);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nvar FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nvar FOR_INIT_KEYS = exports.FOR_INIT_KEYS = [\"left\", \"init\"];\nvar COMMENT_KEYS = exports.COMMENT_KEYS = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\n\nvar LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = [\"||\", \"&&\"];\nvar UPDATE_OPERATORS = exports.UPDATE_OPERATORS = [\"++\", \"--\"];\n\nvar BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nvar EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nvar COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, [\"in\", \"instanceof\"]);\nvar BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);\nvar NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = [\"-\", \"/\", \"%\", \"*\", \"**\", \"&\", \"|\", \">>\", \">>>\", \"<<\", \"^\"];\nvar BINARY_OPERATORS = exports.BINARY_OPERATORS = [\"+\"].concat(NUMBER_BINARY_OPERATORS, BOOLEAN_BINARY_OPERATORS);\n\nvar BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nvar NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"++\", \"--\", \"~\"];\nvar STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = [\"typeof\"];\nvar UNARY_OPERATORS = exports.UNARY_OPERATORS = [\"void\"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);\n\nvar INHERIT_KEYS = exports.INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"]\n};\n\nvar BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = (0, _for2.default)(\"var used to be block scoped\");\nvar NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = (0, _for2.default)(\"should not be considered a local binding\");","\"use strict\";\n\nexports.__esModule = true;\n\nvar _maxSafeInteger = require(\"babel-runtime/core-js/number/max-safe-integer\");\n\nvar _maxSafeInteger2 = _interopRequireDefault(_maxSafeInteger);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.toComputedKey = toComputedKey;\nexports.toSequenceExpression = toSequenceExpression;\nexports.toKeyAlias = toKeyAlias;\nexports.toIdentifier = toIdentifier;\nexports.toBindingIdentifierName = toBindingIdentifierName;\nexports.toStatement = toStatement;\nexports.toExpression = toExpression;\nexports.toBlock = toBlock;\nexports.valueToNode = valueToNode;\n\nvar _isPlainObject = require(\"lodash/isPlainObject\");\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _isRegExp = require(\"lodash/isRegExp\");\n\nvar _isRegExp2 = _interopRequireDefault(_isRegExp);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toComputedKey(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key || node.property;\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n  return key;\n}\n\nfunction gatherSequenceExpressions(nodes, scope, declars) {\n  var exprs = [];\n  var ensureLastUndefined = true;\n\n  for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var node = _ref;\n\n    ensureLastUndefined = false;\n\n    if (t.isExpression(node)) {\n      exprs.push(node);\n    } else if (t.isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (t.isVariableDeclaration(node)) {\n      if (node.kind !== \"var\") return;\n\n      for (var _iterator2 = node.declarations, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n        var _ref2;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref2 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref2 = _i2.value;\n        }\n\n        var declar = _ref2;\n\n        var bindings = t.getBindingIdentifiers(declar);\n        for (var key in bindings) {\n          declars.push({\n            kind: node.kind,\n            id: bindings[key]\n          });\n        }\n\n        if (declar.init) {\n          exprs.push(t.assignmentExpression(\"=\", declar.id, declar.init));\n        }\n      }\n\n      ensureLastUndefined = true;\n    } else if (t.isIfStatement(node)) {\n      var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();\n      var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();\n      if (!consequent || !alternate) return;\n\n      exprs.push(t.conditionalExpression(node.test, consequent, alternate));\n    } else if (t.isBlockStatement(node)) {\n      var body = gatherSequenceExpressions(node.body, scope, declars);\n      if (!body) return;\n\n      exprs.push(body);\n    } else if (t.isEmptyStatement(node)) {\n      ensureLastUndefined = true;\n    } else {\n      return;\n    }\n  }\n\n  if (ensureLastUndefined) {\n    exprs.push(scope.buildUndefinedNode());\n  }\n\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return t.sequenceExpression(exprs);\n  }\n}\n\nfunction toSequenceExpression(nodes, scope) {\n  if (!nodes || !nodes.length) return;\n\n  var declars = [];\n  var result = gatherSequenceExpressions(nodes, scope, declars);\n  if (!result) return;\n\n  for (var _iterator3 = declars, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var declar = _ref3;\n\n    scope.push(declar);\n  }\n\n  return result;\n}\n\nfunction toKeyAlias(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.key;\n\n  var alias = void 0;\n\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if (t.isIdentifier(key)) {\n    alias = key.name;\n  } else if (t.isStringLiteral(key)) {\n    alias = (0, _stringify2.default)(key.value);\n  } else {\n    alias = (0, _stringify2.default)(t.removePropertiesDeep(t.cloneDeep(key)));\n  }\n\n  if (node.computed) {\n    alias = \"[\" + alias + \"]\";\n  }\n\n  if (node.static) {\n    alias = \"static:\" + alias;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= _maxSafeInteger2.default) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n\nfunction toIdentifier(name) {\n  name = name + \"\";\n\n  name = name.replace(/[^a-zA-Z0-9$_]/g, \"-\");\n\n  name = name.replace(/^[-0-9]+/, \"\");\n\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!t.isValidIdentifier(name)) {\n    name = \"_\" + name;\n  }\n\n  return name || \"_\";\n}\n\nfunction toBindingIdentifierName(name) {\n  name = toIdentifier(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}\n\nfunction toStatement(node, ignore) {\n  if (t.isStatement(node)) {\n    return node;\n  }\n\n  var mustHaveId = false;\n  var newType = void 0;\n\n  if (t.isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if (t.isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if (t.isAssignmentExpression(node)) {\n    return t.expressionStatement(node);\n  }\n\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(\"cannot turn \" + node.type + \" to a statement\");\n    }\n  }\n\n  node.type = newType;\n\n  return node;\n}\n\nfunction toExpression(node) {\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  if (t.isExpression(node)) {\n    return node;\n  }\n\n  if (t.isClass(node)) {\n    node.type = \"ClassExpression\";\n  } else if (t.isFunction(node)) {\n    node.type = \"FunctionExpression\";\n  }\n\n  if (!t.isExpression(node)) {\n    throw new Error(\"cannot turn \" + node.type + \" to an expression\");\n  }\n\n  return node;\n}\n\nfunction toBlock(node, parent) {\n  if (t.isBlockStatement(node)) {\n    return node;\n  }\n\n  if (t.isEmptyStatement(node)) {\n    node = [];\n  }\n\n  if (!Array.isArray(node)) {\n    if (!t.isStatement(node)) {\n      if (t.isFunction(parent)) {\n        node = t.returnStatement(node);\n      } else {\n        node = t.expressionStatement(node);\n      }\n    }\n\n    node = [node];\n  }\n\n  return t.blockStatement(node);\n}\n\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return t.identifier(\"undefined\");\n  }\n\n  if (value === true || value === false) {\n    return t.booleanLiteral(value);\n  }\n\n  if (value === null) {\n    return t.nullLiteral();\n  }\n\n  if (typeof value === \"string\") {\n    return t.stringLiteral(value);\n  }\n\n  if (typeof value === \"number\") {\n    return t.numericLiteral(value);\n  }\n\n  if ((0, _isRegExp2.default)(value)) {\n    var pattern = value.source;\n    var flags = value.toString().match(/\\/([a-z]+|)$/)[1];\n    return t.regExpLiteral(pattern, flags);\n  }\n\n  if (Array.isArray(value)) {\n    return t.arrayExpression(value.map(t.valueToNode));\n  }\n\n  if ((0, _isPlainObject2.default)(value)) {\n    var props = [];\n    for (var key in value) {\n      var nodeKey = void 0;\n      if (t.isValidIdentifier(key)) {\n        nodeKey = t.identifier(key);\n      } else {\n        nodeKey = t.stringLiteral(key);\n      }\n      props.push(t.objectProperty(nodeKey, t.valueToNode(value[key])));\n    }\n    return t.objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}","\"use strict\";\n\nvar _index = require(\"../index\");\n\nvar t = _interopRequireWildcard(_index);\n\nvar _constants = require(\"../constants\");\n\nvar _index2 = require(\"./index\");\n\nvar _index3 = _interopRequireDefault(_index2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n(0, _index3.default)(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: []\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: (0, _index2.assertValueType)(\"string\")\n    },\n    left: {\n      validate: (0, _index2.assertNodeType)(\"LVal\")\n    },\n    right: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: _index2.assertOneOf.apply(undefined, _constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n\n(0, _index3.default)(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index2.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\n\n(0, _index3.default)(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index2.assertValueType)(\"string\")\n    }\n  }\n});\n\n(0, _index3.default)(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n\n(0, _index3.default)(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n\n(0, _index3.default)(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\"],\n  fields: {\n    callee: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Expression\", \"SpreadElement\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\"]\n});\n\n(0, _index3.default)(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\n\n(0, _index3.default)(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n\n(0, _index3.default)(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n\n(0, _index3.default)(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n\n(0, _index3.default)(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n\n(0, _index3.default)(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\n\n(0, _index3.default)(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _index2.assertNodeType)(\"Program\")\n    }\n  }\n});\n\n(0, _index3.default)(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: (0, _index2.assertNodeType)(\"VariableDeclaration\", \"LVal\")\n    },\n    right: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _index2.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _index2.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: {\n    id: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\")\n    },\n    params: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"LVal\")))\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    generator: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    },\n    async: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"]\n});\n\n(0, _index3.default)(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: {\n    id: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    params: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"LVal\")))\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    generator: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    },\n    async: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    }\n  }\n});\n\n(0, _index3.default)(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: {\n    name: {\n      validate: function validate(node, key, val) {\n        if (!t.isValidIdentifier(val)) {}\n      }\n    },\n    decorators: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _index2.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index2.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n\n(0, _index3.default)(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _index2.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n\n(0, _index3.default)(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n\n(0, _index3.default)(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\n\n(0, _index3.default)(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _index2.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _index2.assertValueType)(\"string\"),\n      default: \"\"\n    }\n  }\n});\n\n(0, _index3.default)(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: _index2.assertOneOf.apply(undefined, _constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index3.default)(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: {\n    object: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function validate(node, key, val) {\n        var expectedType = node.computed ? \"Expression\" : \"Identifier\";\n        (0, _index2.assertNodeType)(expectedType)(node, key, val);\n      }\n    },\n    computed: {\n      default: false\n    }\n  }\n});\n\n(0, _index3.default)(\"NewExpression\", {\n  visitor: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Expression\", \"SpreadElement\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\"],\n  fields: {\n    directives: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"FunctionParent\"]\n});\n\n(0, _index3.default)(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadProperty\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\"],\n  fields: {\n    kind: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"string\"), (0, _index2.assertOneOf)(\"method\", \"get\", \"set\")),\n      default: \"method\"\n    },\n    computed: {\n      validate: (0, _index2.assertValueType)(\"boolean\"),\n      default: false\n    },\n    key: {\n      validate: function validate(node, key, val) {\n        var expectedTypes = node.computed ? [\"Expression\"] : [\"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);\n      }\n    },\n    decorators: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Decorator\")))\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    generator: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    },\n    async: {\n      default: false,\n      validate: (0, _index2.assertValueType)(\"boolean\")\n    }\n  },\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\n\n(0, _index3.default)(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", \"decorators\"],\n  fields: {\n    computed: {\n      validate: (0, _index2.assertValueType)(\"boolean\"),\n      default: false\n    },\n    key: {\n      validate: function validate(node, key, val) {\n        var expectedTypes = node.computed ? [\"Expression\"] : [\"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        _index2.assertNodeType.apply(undefined, expectedTypes)(node, key, val);\n      }\n    },\n    value: {\n      validate: (0, _index2.assertNodeType)(\"Expression\", \"Pattern\", \"RestElement\")\n    },\n    shorthand: {\n      validate: (0, _index2.assertValueType)(\"boolean\"),\n      default: false\n    },\n    decorators: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"]\n});\n\n(0, _index3.default)(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  aliases: [\"LVal\"],\n  fields: {\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"LVal\")\n    },\n    decorators: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\n\n(0, _index3.default)(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"Statement\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index3.default)(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    handler: {\n      optional: true,\n      handler: (0, _index2.assertNodeType)(\"BlockStatement\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: _index2.assertOneOf.apply(undefined, _constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n\n(0, _index3.default)(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: _index2.assertOneOf.apply(undefined, _constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n\n(0, _index3.default)(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    kind: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"string\"), (0, _index2.assertOneOf)(\"var\", \"let\", \"const\"))\n    },\n    declarations: {\n      validate: (0, _index2.chain)((0, _index2.assertValueType)(\"array\"), (0, _index2.assertEach)((0, _index2.assertNodeType)(\"VariableDeclarator\")))\n    }\n  }\n});\n\n(0, _index3.default)(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: (0, _index2.assertNodeType)(\"LVal\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index3.default)(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\", \"Statement\")\n    }\n  }\n});\n\n(0, _index3.default)(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      object: (0, _index2.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index2.assertNodeType)(\"BlockStatement\", \"Statement\")\n    }\n  }\n});","\"use strict\";\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"LVal\"],\n  fields: {\n    left: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    right: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  aliases: [\"Pattern\", \"LVal\"],\n  fields: {\n    elements: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: {\n    params: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"LVal\")))\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    async: {\n      validate: (0, _index.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n\n(0, _index2.default)(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"ClassMethod\", \"ClassProperty\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ClassDeclaration\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\", \"Pureish\"],\n  fields: {\n    id: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ClassExpression\", {\n  inherits: \"ClassDeclaration\",\n  aliases: [\"Scopable\", \"Class\", \"Expression\", \"Pureish\"],\n  fields: {\n    id: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _index.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _index.assertNodeType)(\"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _index.assertNodeType)(\"Declaration\"),\n      optional: true\n    },\n    specifiers: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"ExportSpecifier\")))\n    },\n    source: {\n      validate: (0, _index.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: (0, _index.assertNodeType)(\"VariableDeclaration\", \"LVal\")\n    },\n    right: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    specifiers: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _index.assertNodeType)(\"StringLiteral\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    },\n    importKind: {\n      validate: (0, _index.assertOneOf)(null, \"type\", \"typeof\")\n    }\n  }\n});\n\n(0, _index2.default)(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _index.assertValueType)(\"string\")\n    },\n    property: {\n      validate: (0, _index.assertValueType)(\"string\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: {\n    kind: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"string\"), (0, _index.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\")),\n      default: \"method\"\n    },\n    computed: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    },\n    static: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    },\n    key: {\n      validate: function validate(node, key, val) {\n        var expectedTypes = node.computed ? [\"Expression\"] : [\"Identifier\", \"StringLiteral\", \"NumericLiteral\"];\n        _index.assertNodeType.apply(undefined, expectedTypes)(node, key, val);\n      }\n    },\n    params: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"LVal\")))\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"BlockStatement\")\n    },\n    generator: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    },\n    async: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\"],\n  aliases: [\"Pattern\", \"LVal\"],\n  fields: {\n    properties: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"RestProperty\", \"Property\")))\n    },\n    decorators: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Decorator\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"Super\", {\n  aliases: [\"Expression\"]\n});\n\n(0, _index2.default)(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _index.assertNodeType)(\"TemplateLiteral\")\n    }\n  }\n});\n\n(0, _index2.default)(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {},\n    tail: {\n      validate: (0, _index.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n\n(0, _index2.default)(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"Expression\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _index.assertValueType)(\"boolean\"),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});","\"use strict\";\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ForAwaitStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: (0, _index.assertNodeType)(\"VariableDeclaration\", \"LVal\")\n    },\n    right: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _index.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\n(0, _index2.default)(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"Import\", {\n  aliases: [\"Expression\"]\n});\n\n(0, _index2.default)(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"DoExpression\", {\n  visitor: [\"body\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: (0, _index.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _index.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"RestProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"LVal\")\n    }\n  }\n});\n\n(0, _index2.default)(\"SpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});","\"use strict\";\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"AnyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"BooleanTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"BooleanLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\"],\n  aliases: [\"Property\"],\n  fields: {\n    computed: {\n      validate: (0, _index.assertValueType)(\"boolean\"),\n      default: false\n    }\n  }\n});\n\n(0, _index2.default)(\"DeclareClass\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareFunction\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareInterface\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareModule\", {\n  visitor: [\"id\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ExistentialTypeParam\", {\n  aliases: [\"Flow\"]\n});\n\n(0, _index2.default)(\"FunctionTypeAnnotation\", {\n  visitor: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"InterfaceDeclaration\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"MixedTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n(0, _index2.default)(\"EmptyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n(0, _index2.default)(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"NumericLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"NumberTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"StringLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"StringTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ThisTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"impltype\", \"supertype\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"Flow\", \"ExpressionWrapper\", \"Expression\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeParameter\", {\n  visitor: [\"bound\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"TypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeIndexer\", {\n  visitor: [\"id\", \"key\", \"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"QualifiedTypeIdentifier\", {\n  visitor: [\"id\", \"qualification\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"],\n  fields: {}\n});\n\n(0, _index2.default)(\"VoidTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"],\n  fields: {}\n});","\"use strict\";\n\nexports.__esModule = true;\nexports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = undefined;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nexports.assertEach = assertEach;\nexports.assertOneOf = assertOneOf;\nexports.assertNodeType = assertNodeType;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports.default = defineType;\n\nvar _index = require(\"../index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar VISITOR_KEYS = exports.VISITOR_KEYS = {};\nvar ALIAS_KEYS = exports.ALIAS_KEYS = {};\nvar NODE_FIELDS = exports.NODE_FIELDS = {};\nvar BUILDER_KEYS = exports.BUILDER_KEYS = {};\nvar DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else if (val === undefined) {\n    return \"undefined\";\n  } else {\n    return typeof val === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(val);\n  }\n}\n\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n\n    for (var i = 0; i < val.length; i++) {\n      callback(node, key + \"[\" + i + \"]\", val[i]);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\n\nfunction assertOneOf() {\n  for (var _len = arguments.length, vals = Array(_len), _key = 0; _key < _len; _key++) {\n    vals[_key] = arguments[_key];\n  }\n\n  function validate(node, key, val) {\n    if (vals.indexOf(val) < 0) {\n      throw new TypeError(\"Property \" + key + \" expected value to be one of \" + (0, _stringify2.default)(vals) + \" but got \" + (0, _stringify2.default)(val));\n    }\n  }\n\n  validate.oneOf = vals;\n\n  return validate;\n}\n\nfunction assertNodeType() {\n  for (var _len2 = arguments.length, types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n\n  function validate(node, key, val) {\n    var valid = false;\n\n    for (var _iterator = types, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var type = _ref;\n\n      if (t.is(type, val)) {\n        valid = true;\n        break;\n      }\n    }\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected node to be of a type \" + (0, _stringify2.default)(types) + \" \" + (\"but instead got \" + (0, _stringify2.default)(val && val.type)));\n    }\n  }\n\n  validate.oneOfNodeTypes = types;\n\n  return validate;\n}\n\nfunction assertNodeOrValueType() {\n  for (var _len3 = arguments.length, types = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    types[_key3] = arguments[_key3];\n  }\n\n  function validate(node, key, val) {\n    var valid = false;\n\n    for (var _iterator2 = types, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var type = _ref2;\n\n      if (getType(val) === type || t.is(type, val)) {\n        valid = true;\n        break;\n      }\n    }\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" of \" + node.type + \" expected node to be of a type \" + (0, _stringify2.default)(types) + \" \" + (\"but instead got \" + (0, _stringify2.default)(val && val.type)));\n    }\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n\n  return validate;\n}\n\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    var valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\"Property \" + key + \" expected type of \" + type + \" but got \" + getType(val));\n    }\n  }\n\n  validate.type = type;\n\n  return validate;\n}\n\nfunction chain() {\n  for (var _len4 = arguments.length, fns = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    fns[_key4] = arguments[_key4];\n  }\n\n  function validate() {\n    for (var _iterator3 = fns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i3 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i3++];\n      } else {\n        _i3 = _iterator3.next();\n        if (_i3.done) break;\n        _ref3 = _i3.value;\n      }\n\n      var fn = _ref3;\n\n      fn.apply(undefined, arguments);\n    }\n  }\n  validate.chainOf = fns;\n  return validate;\n}\n\nfunction defineType(type) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var inherits = opts.inherits && store[opts.inherits] || {};\n\n  opts.fields = opts.fields || inherits.fields || {};\n  opts.visitor = opts.visitor || inherits.visitor || [];\n  opts.aliases = opts.aliases || inherits.aliases || [];\n  opts.builder = opts.builder || inherits.builder || opts.visitor || [];\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n\n  for (var _iterator4 = opts.visitor.concat(opts.builder), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n    var _ref4;\n\n    if (_isArray4) {\n      if (_i4 >= _iterator4.length) break;\n      _ref4 = _iterator4[_i4++];\n    } else {\n      _i4 = _iterator4.next();\n      if (_i4.done) break;\n      _ref4 = _i4.value;\n    }\n\n    var _key5 = _ref4;\n\n    opts.fields[_key5] = opts.fields[_key5] || {};\n  }\n\n  for (var key in opts.fields) {\n    var field = opts.fields[key];\n\n    if (opts.builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate) {\n      field.validate = assertValueType(getType(field.default));\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor;\n  BUILDER_KEYS[type] = opts.builder;\n  NODE_FIELDS[type] = opts.fields;\n  ALIAS_KEYS[type] = opts.aliases;\n\n  store[type] = opts;\n}\n\nvar store = {};","\"use strict\";\n\nrequire(\"./index\");\n\nrequire(\"./core\");\n\nrequire(\"./es2015\");\n\nrequire(\"./flow\");\n\nrequire(\"./jsx\");\n\nrequire(\"./misc\");\n\nrequire(\"./experimental\");","\"use strict\";\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\", \"JSXNamespacedName\")\n    },\n    value: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"JSXElement\", \"StringLiteral\", \"JSXExpressionContainer\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXElement\", {\n  builder: [\"openingElement\", \"closingElement\", \"children\", \"selfClosing\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"JSX\", \"Immutable\", \"Expression\"],\n  fields: {\n    openingElement: {\n      validate: (0, _index.assertNodeType)(\"JSXOpeningElement\")\n    },\n    closingElement: {\n      optional: true,\n      validate: (0, _index.assertNodeType)(\"JSXClosingElement\")\n    },\n    children: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"JSXText\", \"JSXExpressionContainer\", \"JSXSpreadChild\", \"JSXElement\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXEmptyExpression\", {\n  aliases: [\"JSX\", \"Expression\"]\n});\n\n(0, _index2.default)(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    expression: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  aliases: [\"JSX\", \"Expression\"],\n  fields: {\n    name: {\n      validate: (0, _index.assertValueType)(\"string\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  aliases: [\"JSX\", \"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _index.assertNodeType)(\"JSXMemberExpression\", \"JSXIdentifier\")\n    },\n    property: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  aliases: [\"JSX\"],\n  fields: {\n    namespace: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\")\n    },\n    name: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"attributes\"],\n  aliases: [\"JSX\", \"Immutable\"],\n  fields: {\n    name: {\n      validate: (0, _index.assertNodeType)(\"JSXIdentifier\", \"JSXMemberExpression\")\n    },\n    selfClosing: {\n      default: false,\n      validate: (0, _index.assertValueType)(\"boolean\")\n    },\n    attributes: {\n      validate: (0, _index.chain)((0, _index.assertValueType)(\"array\"), (0, _index.assertEach)((0, _index.assertNodeType)(\"JSXAttribute\", \"JSXSpreadAttribute\")))\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  aliases: [\"JSX\"],\n  fields: {\n    argument: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});\n\n(0, _index2.default)(\"JSXText\", {\n  aliases: [\"JSX\", \"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _index.assertValueType)(\"string\")\n    }\n  }\n});","\"use strict\";\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _index2.default)(\"Noop\", {\n  visitor: []\n});\n\n(0, _index2.default)(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _index.assertNodeType)(\"Expression\")\n    }\n  }\n});","\"use strict\";\n\nexports.__esModule = true;\nexports.createUnionTypeAnnotation = createUnionTypeAnnotation;\nexports.removeTypeDuplicates = removeTypeDuplicates;\nexports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction createUnionTypeAnnotation(types) {\n  var flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return t.unionTypeAnnotation(flattened);\n  }\n}\n\nfunction removeTypeDuplicates(nodes) {\n  var generics = {};\n  var bases = {};\n\n  var typeGroups = [];\n\n  var types = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if (t.isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    if (t.isFlowBaseAnnotation(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    if (t.isUnionTypeAnnotation(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n      continue;\n    }\n\n    if (t.isGenericTypeAnnotation(node)) {\n      var name = node.id.name;\n\n      if (generics[name]) {\n        var existing = generics[name];\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (var type in bases) {\n    types.push(bases[type]);\n  }\n\n  for (var _name in generics) {\n    types.push(generics[_name]);\n  }\n\n  return types;\n}\n\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  if (type === \"string\") {\n    return t.stringTypeAnnotation();\n  } else if (type === \"number\") {\n    return t.numberTypeAnnotation();\n  } else if (type === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (type === \"boolean\") {\n    return t.booleanTypeAnnotation();\n  } else if (type === \"function\") {\n    return t.genericTypeAnnotation(t.identifier(\"Function\"));\n  } else if (type === \"object\") {\n    return t.genericTypeAnnotation(t.identifier(\"Object\"));\n  } else if (type === \"symbol\") {\n    return t.genericTypeAnnotation(t.identifier(\"Symbol\"));\n  } else {\n    throw new Error(\"Invalid typeof value\");\n  }\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.createTypeAnnotationBasedOnTypeof = exports.removeTypeDuplicates = exports.createUnionTypeAnnotation = exports.valueToNode = exports.toBlock = exports.toExpression = exports.toStatement = exports.toBindingIdentifierName = exports.toIdentifier = exports.toKeyAlias = exports.toSequenceExpression = exports.toComputedKey = exports.isNodesEquivalent = exports.isImmutable = exports.isScope = exports.isSpecifierDefault = exports.isVar = exports.isBlockScoped = exports.isLet = exports.isValidIdentifier = exports.isReferenced = exports.isBinding = exports.getOuterBindingIdentifiers = exports.getBindingIdentifiers = exports.TYPES = exports.react = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.NODE_FIELDS = exports.ALIAS_KEYS = exports.VISITOR_KEYS = exports.NOT_LOCAL_BINDING = exports.BLOCK_SCOPED_SYMBOL = exports.INHERIT_KEYS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = exports.BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.UPDATE_OPERATORS = exports.LOGICAL_OPERATORS = exports.COMMENT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = undefined;\n\nvar _getOwnPropertySymbols = require(\"babel-runtime/core-js/object/get-own-property-symbols\");\n\nvar _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _stringify = require(\"babel-runtime/core-js/json/stringify\");\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _constants = require(\"./constants\");\n\nObject.defineProperty(exports, \"STATEMENT_OR_BLOCK_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.STATEMENT_OR_BLOCK_KEYS;\n  }\n});\nObject.defineProperty(exports, \"FLATTENABLE_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.FLATTENABLE_KEYS;\n  }\n});\nObject.defineProperty(exports, \"FOR_INIT_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.FOR_INIT_KEYS;\n  }\n});\nObject.defineProperty(exports, \"COMMENT_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.COMMENT_KEYS;\n  }\n});\nObject.defineProperty(exports, \"LOGICAL_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.LOGICAL_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"UPDATE_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.UPDATE_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"BOOLEAN_NUMBER_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BOOLEAN_NUMBER_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"EQUALITY_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.EQUALITY_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"COMPARISON_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.COMPARISON_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"BOOLEAN_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BOOLEAN_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"NUMBER_BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.NUMBER_BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"BINARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BINARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"BOOLEAN_UNARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BOOLEAN_UNARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"NUMBER_UNARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.NUMBER_UNARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"STRING_UNARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.STRING_UNARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"UNARY_OPERATORS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.UNARY_OPERATORS;\n  }\n});\nObject.defineProperty(exports, \"INHERIT_KEYS\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.INHERIT_KEYS;\n  }\n});\nObject.defineProperty(exports, \"BLOCK_SCOPED_SYMBOL\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.BLOCK_SCOPED_SYMBOL;\n  }\n});\nObject.defineProperty(exports, \"NOT_LOCAL_BINDING\", {\n  enumerable: true,\n  get: function get() {\n    return _constants.NOT_LOCAL_BINDING;\n  }\n});\nexports.is = is;\nexports.isType = isType;\nexports.validate = validate;\nexports.shallowEqual = shallowEqual;\nexports.appendToMemberExpression = appendToMemberExpression;\nexports.prependToMemberExpression = prependToMemberExpression;\nexports.ensureBlock = ensureBlock;\nexports.clone = clone;\nexports.cloneWithoutLoc = cloneWithoutLoc;\nexports.cloneDeep = cloneDeep;\nexports.buildMatchMemberExpression = buildMatchMemberExpression;\nexports.removeComments = removeComments;\nexports.inheritsComments = inheritsComments;\nexports.inheritTrailingComments = inheritTrailingComments;\nexports.inheritLeadingComments = inheritLeadingComments;\nexports.inheritInnerComments = inheritInnerComments;\nexports.inherits = inherits;\nexports.assertNode = assertNode;\nexports.isNode = isNode;\nexports.traverseFast = traverseFast;\nexports.removeProperties = removeProperties;\nexports.removePropertiesDeep = removePropertiesDeep;\n\nvar _retrievers = require(\"./retrievers\");\n\nObject.defineProperty(exports, \"getBindingIdentifiers\", {\n  enumerable: true,\n  get: function get() {\n    return _retrievers.getBindingIdentifiers;\n  }\n});\nObject.defineProperty(exports, \"getOuterBindingIdentifiers\", {\n  enumerable: true,\n  get: function get() {\n    return _retrievers.getOuterBindingIdentifiers;\n  }\n});\n\nvar _validators = require(\"./validators\");\n\nObject.defineProperty(exports, \"isBinding\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isBinding;\n  }\n});\nObject.defineProperty(exports, \"isReferenced\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isReferenced;\n  }\n});\nObject.defineProperty(exports, \"isValidIdentifier\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isValidIdentifier;\n  }\n});\nObject.defineProperty(exports, \"isLet\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isLet;\n  }\n});\nObject.defineProperty(exports, \"isBlockScoped\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isBlockScoped;\n  }\n});\nObject.defineProperty(exports, \"isVar\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isVar;\n  }\n});\nObject.defineProperty(exports, \"isSpecifierDefault\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isSpecifierDefault;\n  }\n});\nObject.defineProperty(exports, \"isScope\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isScope;\n  }\n});\nObject.defineProperty(exports, \"isImmutable\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isImmutable;\n  }\n});\nObject.defineProperty(exports, \"isNodesEquivalent\", {\n  enumerable: true,\n  get: function get() {\n    return _validators.isNodesEquivalent;\n  }\n});\n\nvar _converters = require(\"./converters\");\n\nObject.defineProperty(exports, \"toComputedKey\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toComputedKey;\n  }\n});\nObject.defineProperty(exports, \"toSequenceExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toSequenceExpression;\n  }\n});\nObject.defineProperty(exports, \"toKeyAlias\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toKeyAlias;\n  }\n});\nObject.defineProperty(exports, \"toIdentifier\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toIdentifier;\n  }\n});\nObject.defineProperty(exports, \"toBindingIdentifierName\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toBindingIdentifierName;\n  }\n});\nObject.defineProperty(exports, \"toStatement\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toStatement;\n  }\n});\nObject.defineProperty(exports, \"toExpression\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toExpression;\n  }\n});\nObject.defineProperty(exports, \"toBlock\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.toBlock;\n  }\n});\nObject.defineProperty(exports, \"valueToNode\", {\n  enumerable: true,\n  get: function get() {\n    return _converters.valueToNode;\n  }\n});\n\nvar _flow = require(\"./flow\");\n\nObject.defineProperty(exports, \"createUnionTypeAnnotation\", {\n  enumerable: true,\n  get: function get() {\n    return _flow.createUnionTypeAnnotation;\n  }\n});\nObject.defineProperty(exports, \"removeTypeDuplicates\", {\n  enumerable: true,\n  get: function get() {\n    return _flow.removeTypeDuplicates;\n  }\n});\nObject.defineProperty(exports, \"createTypeAnnotationBasedOnTypeof\", {\n  enumerable: true,\n  get: function get() {\n    return _flow.createTypeAnnotationBasedOnTypeof;\n  }\n});\n\nvar _toFastProperties = require(\"to-fast-properties\");\n\nvar _toFastProperties2 = _interopRequireDefault(_toFastProperties);\n\nvar _clone = require(\"lodash/clone\");\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _uniq = require(\"lodash/uniq\");\n\nvar _uniq2 = _interopRequireDefault(_uniq);\n\nrequire(\"./definitions/init\");\n\nvar _definitions = require(\"./definitions\");\n\nvar _react2 = require(\"./react\");\n\nvar _react = _interopRequireWildcard(_react2);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar t = exports;\n\nfunction registerType(type) {\n  var is = t[\"is\" + type];\n  if (!is) {\n    is = t[\"is\" + type] = function (node, opts) {\n      return t.is(type, node, opts);\n    };\n  }\n\n  t[\"assert\" + type] = function (node, opts) {\n    opts = opts || {};\n    if (!is(node, opts)) {\n      throw new Error(\"Expected type \" + (0, _stringify2.default)(type) + \" with option \" + (0, _stringify2.default)(opts));\n    }\n  };\n}\n\nexports.VISITOR_KEYS = _definitions.VISITOR_KEYS;\nexports.ALIAS_KEYS = _definitions.ALIAS_KEYS;\nexports.NODE_FIELDS = _definitions.NODE_FIELDS;\nexports.BUILDER_KEYS = _definitions.BUILDER_KEYS;\nexports.DEPRECATED_KEYS = _definitions.DEPRECATED_KEYS;\nexports.react = _react;\n\n\nfor (var type in t.VISITOR_KEYS) {\n  registerType(type);\n}\n\nt.FLIPPED_ALIAS_KEYS = {};\n\n(0, _keys2.default)(t.ALIAS_KEYS).forEach(function (type) {\n  t.ALIAS_KEYS[type].forEach(function (alias) {\n    var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];\n    types.push(type);\n  });\n});\n\n(0, _keys2.default)(t.FLIPPED_ALIAS_KEYS).forEach(function (type) {\n  t[type.toUpperCase() + \"_TYPES\"] = t.FLIPPED_ALIAS_KEYS[type];\n  registerType(type);\n});\n\nvar TYPES = exports.TYPES = (0, _keys2.default)(t.VISITOR_KEYS).concat((0, _keys2.default)(t.FLIPPED_ALIAS_KEYS)).concat((0, _keys2.default)(t.DEPRECATED_KEYS));\n\nfunction is(type, node, opts) {\n  if (!node) return false;\n\n  var matches = isType(node.type, type);\n  if (!matches) return false;\n\n  if (typeof opts === \"undefined\") {\n    return true;\n  } else {\n    return t.shallowEqual(node, opts);\n  }\n}\n\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n\n  if (t.ALIAS_KEYS[targetType]) return false;\n\n  var aliases = t.FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases) {\n    if (aliases[0] === nodeType) return true;\n\n    for (var _iterator = aliases, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var alias = _ref;\n\n      if (nodeType === alias) return true;\n    }\n  }\n\n  return false;\n}\n\n(0, _keys2.default)(t.BUILDER_KEYS).forEach(function (type) {\n  var keys = t.BUILDER_KEYS[type];\n\n  function builder() {\n    if (arguments.length > keys.length) {\n      throw new Error(\"t.\" + type + \": Too many arguments passed. Received \" + arguments.length + \" but can receive \" + (\"no more than \" + keys.length));\n    }\n\n    var node = {};\n    node.type = type;\n\n    var i = 0;\n\n    for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var _key = _ref2;\n\n      var field = t.NODE_FIELDS[type][_key];\n\n      var arg = arguments[i++];\n      if (arg === undefined) arg = (0, _clone2.default)(field.default);\n\n      node[_key] = arg;\n    }\n\n    for (var key in node) {\n      validate(node, key, node[key]);\n    }\n\n    return node;\n  }\n\n  t[type] = builder;\n  t[type[0].toLowerCase() + type.slice(1)] = builder;\n});\n\nvar _loop = function _loop(_type) {\n  var newType = t.DEPRECATED_KEYS[_type];\n\n  function proxy(fn) {\n    return function () {\n      console.trace(\"The node type \" + _type + \" has been renamed to \" + newType);\n      return fn.apply(this, arguments);\n    };\n  }\n\n  t[_type] = t[_type[0].toLowerCase() + _type.slice(1)] = proxy(t[newType]);\n  t[\"is\" + _type] = proxy(t[\"is\" + newType]);\n  t[\"assert\" + _type] = proxy(t[\"assert\" + newType]);\n};\n\nfor (var _type in t.DEPRECATED_KEYS) {\n  _loop(_type);\n}\n\nfunction validate(node, key, val) {\n  if (!node) return;\n\n  var fields = t.NODE_FIELDS[node.type];\n  if (!fields) return;\n\n  var field = fields[key];\n  if (!field || !field.validate) return;\n  if (field.optional && val == null) return;\n\n  field.validate(node, key, val);\n}\n\nfunction shallowEqual(actual, expected) {\n  var keys = (0, _keys2.default)(expected);\n\n  for (var _iterator3 = keys, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n    var _ref3;\n\n    if (_isArray3) {\n      if (_i3 >= _iterator3.length) break;\n      _ref3 = _iterator3[_i3++];\n    } else {\n      _i3 = _iterator3.next();\n      if (_i3.done) break;\n      _ref3 = _i3.value;\n    }\n\n    var key = _ref3;\n\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction appendToMemberExpression(member, append, computed) {\n  member.object = t.memberExpression(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}\n\nfunction prependToMemberExpression(member, prepend) {\n  member.object = t.memberExpression(prepend, member.object);\n  return member;\n}\n\nfunction ensureBlock(node) {\n  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"body\";\n\n  return node[key] = t.toBlock(node[key], node);\n}\n\nfunction clone(node) {\n  if (!node) return node;\n  var newNode = {};\n  for (var key in node) {\n    if (key[0] === \"_\") continue;\n    newNode[key] = node[key];\n  }\n  return newNode;\n}\n\nfunction cloneWithoutLoc(node) {\n  var newNode = clone(node);\n  delete newNode.loc;\n  return newNode;\n}\n\nfunction cloneDeep(node) {\n  if (!node) return node;\n  var newNode = {};\n\n  for (var key in node) {\n    if (key[0] === \"_\") continue;\n\n    var val = node[key];\n\n    if (val) {\n      if (val.type) {\n        val = t.cloneDeep(val);\n      } else if (Array.isArray(val)) {\n        val = val.map(t.cloneDeep);\n      }\n    }\n\n    newNode[key] = val;\n  }\n\n  return newNode;\n}\n\nfunction buildMatchMemberExpression(match, allowPartial) {\n  var parts = match.split(\".\");\n\n  return function (member) {\n    if (!t.isMemberExpression(member)) return false;\n\n    var search = [member];\n    var i = 0;\n\n    while (search.length) {\n      var node = search.shift();\n\n      if (allowPartial && i === parts.length) {\n        return true;\n      }\n\n      if (t.isIdentifier(node)) {\n        if (parts[i] !== node.name) return false;\n      } else if (t.isStringLiteral(node)) {\n        if (parts[i] !== node.value) return false;\n      } else if (t.isMemberExpression(node)) {\n        if (node.computed && !t.isStringLiteral(node.property)) {\n          return false;\n        } else {\n          search.push(node.object);\n          search.push(node.property);\n          continue;\n        }\n      } else {\n        return false;\n      }\n\n      if (++i > parts.length) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n\nfunction removeComments(node) {\n  for (var _iterator4 = t.COMMENT_KEYS, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n    var _ref4;\n\n    if (_isArray4) {\n      if (_i4 >= _iterator4.length) break;\n      _ref4 = _iterator4[_i4++];\n    } else {\n      _i4 = _iterator4.next();\n      if (_i4.done) break;\n      _ref4 = _i4.value;\n    }\n\n    var key = _ref4;\n\n    delete node[key];\n  }\n  return node;\n}\n\nfunction inheritsComments(child, parent) {\n  inheritTrailingComments(child, parent);\n  inheritLeadingComments(child, parent);\n  inheritInnerComments(child, parent);\n  return child;\n}\n\nfunction inheritTrailingComments(child, parent) {\n  _inheritComments(\"trailingComments\", child, parent);\n}\n\nfunction inheritLeadingComments(child, parent) {\n  _inheritComments(\"leadingComments\", child, parent);\n}\n\nfunction inheritInnerComments(child, parent) {\n  _inheritComments(\"innerComments\", child, parent);\n}\n\nfunction _inheritComments(key, child, parent) {\n  if (child && parent) {\n    child[key] = (0, _uniq2.default)([].concat(child[key], parent[key]).filter(Boolean));\n  }\n}\n\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n\n  for (var _iterator5 = t.INHERIT_KEYS.optional, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {\n    var _ref5;\n\n    if (_isArray5) {\n      if (_i5 >= _iterator5.length) break;\n      _ref5 = _iterator5[_i5++];\n    } else {\n      _i5 = _iterator5.next();\n      if (_i5.done) break;\n      _ref5 = _i5.value;\n    }\n\n    var _key2 = _ref5;\n\n    if (child[_key2] == null) {\n      child[_key2] = parent[_key2];\n    }\n  }\n\n  for (var key in parent) {\n    if (key[0] === \"_\") child[key] = parent[key];\n  }\n\n  for (var _iterator6 = t.INHERIT_KEYS.force, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {\n    var _ref6;\n\n    if (_isArray6) {\n      if (_i6 >= _iterator6.length) break;\n      _ref6 = _iterator6[_i6++];\n    } else {\n      _i6 = _iterator6.next();\n      if (_i6.done) break;\n      _ref6 = _i6.value;\n    }\n\n    var _key3 = _ref6;\n\n    child[_key3] = parent[_key3];\n  }\n\n  t.inheritsComments(child, parent);\n\n  return child;\n}\n\nfunction assertNode(node) {\n  if (!isNode(node)) {\n    throw new TypeError(\"Not a valid node \" + (node && node.type));\n  }\n}\n\nfunction isNode(node) {\n  return !!(node && _definitions.VISITOR_KEYS[node.type]);\n}\n\n(0, _toFastProperties2.default)(t);\n(0, _toFastProperties2.default)(t.VISITOR_KEYS);\n\nfunction traverseFast(node, enter, opts) {\n  if (!node) return;\n\n  var keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  opts = opts || {};\n  enter(node, opts);\n\n  for (var _iterator7 = keys, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {\n    var _ref7;\n\n    if (_isArray7) {\n      if (_i7 >= _iterator7.length) break;\n      _ref7 = _iterator7[_i7++];\n    } else {\n      _i7 = _iterator7.next();\n      if (_i7.done) break;\n      _ref7 = _i7.value;\n    }\n\n    var key = _ref7;\n\n    var subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (var _iterator8 = subNode, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {\n        var _ref8;\n\n        if (_isArray8) {\n          if (_i8 >= _iterator8.length) break;\n          _ref8 = _iterator8[_i8++];\n        } else {\n          _i8 = _iterator8.next();\n          if (_i8.done) break;\n          _ref8 = _i8.value;\n        }\n\n        var _node = _ref8;\n\n        traverseFast(_node, enter, opts);\n      }\n    } else {\n      traverseFast(subNode, enter, opts);\n    }\n  }\n}\n\nvar CLEAR_KEYS = [\"tokens\", \"start\", \"end\", \"loc\", \"raw\", \"rawValue\"];\n\nvar CLEAR_KEYS_PLUS_COMMENTS = t.COMMENT_KEYS.concat([\"comments\"]).concat(CLEAR_KEYS);\n\nfunction removeProperties(node, opts) {\n  opts = opts || {};\n  var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n  for (var _iterator9 = map, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {\n    var _ref9;\n\n    if (_isArray9) {\n      if (_i9 >= _iterator9.length) break;\n      _ref9 = _iterator9[_i9++];\n    } else {\n      _i9 = _iterator9.next();\n      if (_i9.done) break;\n      _ref9 = _i9.value;\n    }\n\n    var _key4 = _ref9;\n\n    if (node[_key4] != null) node[_key4] = undefined;\n  }\n\n  for (var key in node) {\n    if (key[0] === \"_\" && node[key] != null) node[key] = undefined;\n  }\n\n  var syms = (0, _getOwnPropertySymbols2.default)(node);\n  for (var _iterator10 = syms, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {\n    var _ref10;\n\n    if (_isArray10) {\n      if (_i10 >= _iterator10.length) break;\n      _ref10 = _iterator10[_i10++];\n    } else {\n      _i10 = _iterator10.next();\n      if (_i10.done) break;\n      _ref10 = _i10.value;\n    }\n\n    var sym = _ref10;\n\n    node[sym] = null;\n  }\n}\n\nfunction removePropertiesDeep(tree, opts) {\n  traverseFast(tree, removeProperties, opts);\n  return tree;\n}","\"use strict\";\n\nexports.__esModule = true;\nexports.isReactComponent = undefined;\nexports.isCompatTag = isCompatTag;\nexports.buildChildren = buildChildren;\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar isReactComponent = exports.isReactComponent = t.buildMatchMemberExpression(\"React.Component\");\n\nfunction isCompatTag(tagName) {\n  return !!tagName && /^[a-z]|\\-/.test(tagName);\n}\n\nfunction cleanJSXElementLiteralChild(child, args) {\n  var lines = child.value.split(/\\r\\n|\\n|\\r/);\n\n  var lastNonEmptyLine = 0;\n\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].match(/[^ \\t]/)) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  var str = \"\";\n\n  for (var _i = 0; _i < lines.length; _i++) {\n    var line = lines[_i];\n\n    var isFirstLine = _i === 0;\n    var isLastLine = _i === lines.length - 1;\n    var isLastNonEmptyLine = _i === lastNonEmptyLine;\n\n    var trimmedLine = line.replace(/\\t/g, \" \");\n\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^[ ]+/, \"\");\n    }\n\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/[ ]+$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push(t.stringLiteral(str));\n}\n\nfunction buildChildren(node) {\n  var elems = [];\n\n  for (var i = 0; i < node.children.length; i++) {\n    var child = node.children[i];\n\n    if (t.isJSXText(child)) {\n      cleanJSXElementLiteralChild(child, elems);\n      continue;\n    }\n\n    if (t.isJSXExpressionContainer(child)) child = child.expression;\n    if (t.isJSXEmptyExpression(child)) continue;\n\n    elems.push(child);\n  }\n\n  return elems;\n}","\"use strict\";\n\nexports.__esModule = true;\n\nvar _create = require(\"babel-runtime/core-js/object/create\");\n\nvar _create2 = _interopRequireDefault(_create);\n\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getBindingIdentifiers(node, duplicates, outerOnly) {\n  var search = [].concat(node);\n  var ids = (0, _create2.default)(null);\n\n  while (search.length) {\n    var id = search.shift();\n    if (!id) continue;\n\n    var keys = t.getBindingIdentifiers.keys[id.type];\n\n    if (t.isIdentifier(id)) {\n      if (duplicates) {\n        var _ids = ids[id.name] = ids[id.name] || [];\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n      continue;\n    }\n\n    if (t.isExportDeclaration(id)) {\n      if (t.isDeclaration(id.declaration)) {\n        search.push(id.declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (t.isFunctionDeclaration(id)) {\n        search.push(id.id);\n        continue;\n      }\n\n      if (t.isFunctionExpression(id)) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (id[key]) {\n          search = search.concat(id[key]);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\ngetBindingIdentifiers.keys = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n\n  RestProperty: [\"argument\"],\n  ObjectProperty: [\"value\"],\n\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"]\n};\n\nfunction getOuterBindingIdentifiers(node, duplicates) {\n  return getBindingIdentifiers(node, duplicates, true);\n}","\"use strict\";\n\nexports.__esModule = true;\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.isBinding = isBinding;\nexports.isReferenced = isReferenced;\nexports.isValidIdentifier = isValidIdentifier;\nexports.isLet = isLet;\nexports.isBlockScoped = isBlockScoped;\nexports.isVar = isVar;\nexports.isSpecifierDefault = isSpecifierDefault;\nexports.isScope = isScope;\nexports.isImmutable = isImmutable;\nexports.isNodesEquivalent = isNodesEquivalent;\n\nvar _retrievers = require(\"./retrievers\");\n\nvar _esutils = require(\"esutils\");\n\nvar _esutils2 = _interopRequireDefault(_esutils);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\nvar _constants = require(\"./constants\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isBinding(node, parent) {\n  var keys = _retrievers.getBindingIdentifiers.keys[parent.type];\n  if (keys) {\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = parent[key];\n      if (Array.isArray(val)) {\n        if (val.indexOf(node) >= 0) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isReferenced(node, parent) {\n  switch (parent.type) {\n    case \"BindExpression\":\n      return parent.object === node || parent.callee === node;\n\n    case \"MemberExpression\":\n    case \"JSXMemberExpression\":\n      if (parent.property === node && parent.computed) {\n        return true;\n      } else if (parent.object === node) {\n        return true;\n      } else {\n        return false;\n      }\n\n    case \"MetaProperty\":\n      return false;\n\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return parent.computed;\n      }\n\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    case \"ArrowFunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      for (var _iterator = parent.params, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var param = _ref;\n\n        if (param === node) return false;\n      }\n\n      return parent.id !== node;\n\n    case \"ExportSpecifier\":\n      if (parent.source) {\n        return false;\n      } else {\n        return parent.local === node;\n      }\n\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n\n    case \"JSXAttribute\":\n      return parent.name !== node;\n\n    case \"ClassProperty\":\n      if (parent.key === node) {\n        return parent.computed;\n      } else {\n        return parent.value === node;\n      }\n\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.id !== node;\n\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n      return parent.key === node && parent.computed;\n\n    case \"LabeledStatement\":\n      return false;\n\n    case \"CatchClause\":\n      return parent.param !== node;\n\n    case \"RestElement\":\n      return false;\n\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n  }\n\n  return true;\n}\n\nfunction isValidIdentifier(name) {\n  if (typeof name !== \"string\" || _esutils2.default.keyword.isReservedWordES6(name, true)) {\n    return false;\n  } else if (name === \"await\") {\n    return false;\n  } else {\n    return _esutils2.default.keyword.isIdentifierNameES6(name);\n  }\n}\n\nfunction isLet(node) {\n  return t.isVariableDeclaration(node) && (node.kind !== \"var\" || node[_constants.BLOCK_SCOPED_SYMBOL]);\n}\n\nfunction isBlockScoped(node) {\n  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);\n}\n\nfunction isVar(node) {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !node[_constants.BLOCK_SCOPED_SYMBOL];\n}\n\nfunction isSpecifierDefault(specifier) {\n  return t.isImportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, { name: \"default\" });\n}\n\nfunction isScope(node, parent) {\n  if (t.isBlockStatement(node) && t.isFunction(parent, { body: node })) {\n    return false;\n  }\n\n  return t.isScopable(node);\n}\n\nfunction isImmutable(node) {\n  if (t.isType(node.type, \"Immutable\")) return true;\n\n  if (t.isIdentifier(node)) {\n    if (node.name === \"undefined\") {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction isNodesEquivalent(a, b) {\n  if ((typeof a === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(a)) !== \"object\" || (typeof a === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(a)) !== \"object\" || a == null || b == null) {\n    return a === b;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  var fields = (0, _keys2.default)(t.NODE_FIELDS[a.type] || a.type);\n\n  for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n    var _ref2;\n\n    if (_isArray2) {\n      if (_i2 >= _iterator2.length) break;\n      _ref2 = _iterator2[_i2++];\n    } else {\n      _i2 = _iterator2.next();\n      if (_i2.done) break;\n      _ref2 = _i2.value;\n    }\n\n    var field = _ref2;\n\n    if ((0, _typeof3.default)(a[field]) !== (0, _typeof3.default)(b[field])) {\n      return false;\n    }\n\n    if (Array.isArray(a[field])) {\n      if (!Array.isArray(b[field])) {\n        return false;\n      }\n      if (a[field].length !== b[field].length) {\n        return false;\n      }\n\n      for (var i = 0; i < a[field].length; i++) {\n        if (!isNodesEquivalent(a[field][i], b[field][i])) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    if (!isNodesEquivalent(a[field], b[field])) {\n      return false;\n    }\n  }\n\n  return true;\n}","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(\"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startLine: 1,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false\n};\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var key in defaultOptions) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nvar beforeExpr = true;\nvar startsExpr = true;\nvar isLoop = true;\nvar isAssign = true;\nvar prefix = true;\nvar postfix = true;\nvar TokenType = function TokenType(label, conf) {\n  if (conf === void 0) {\n    conf = {};\n  }\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.rightAssociative = !!conf.rightAssociative;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop === 0 ? 0 : conf.binop || null;\n  this.updateContext = null;\n};\n\nvar KeywordTokenType = function (_TokenType) {\n  _inheritsLoose(KeywordTokenType, _TokenType);\n\n  function KeywordTokenType(name, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    options.keyword = name;\n    return _TokenType.call(this, name, options) || this;\n  }\n\n  return KeywordTokenType;\n}(TokenType);\n\nvar BinopTokenType = function (_TokenType2) {\n  _inheritsLoose(BinopTokenType, _TokenType2);\n\n  function BinopTokenType(name, prec) {\n    return _TokenType2.call(this, name, {\n      beforeExpr: beforeExpr,\n      binop: prec\n    }) || this;\n  }\n\n  return BinopTokenType;\n}(TokenType);\nvar types = {\n  num: new TokenType(\"num\", {\n    startsExpr: startsExpr\n  }),\n  bigint: new TokenType(\"bigint\", {\n    startsExpr: startsExpr\n  }),\n  regexp: new TokenType(\"regexp\", {\n    startsExpr: startsExpr\n  }),\n  string: new TokenType(\"string\", {\n    startsExpr: startsExpr\n  }),\n  name: new TokenType(\"name\", {\n    startsExpr: startsExpr\n  }),\n  eof: new TokenType(\"eof\"),\n  bracketL: new TokenType(\"[\", {\n    beforeExpr: beforeExpr,\n    startsExpr: startsExpr\n  }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr: beforeExpr,\n    startsExpr: startsExpr\n  }),\n  braceBarL: new TokenType(\"{|\", {\n    beforeExpr: beforeExpr,\n    startsExpr: startsExpr\n  }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr: beforeExpr,\n    startsExpr: startsExpr\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", {\n    beforeExpr: beforeExpr\n  }),\n  semi: new TokenType(\";\", {\n    beforeExpr: beforeExpr\n  }),\n  colon: new TokenType(\":\", {\n    beforeExpr: beforeExpr\n  }),\n  doubleColon: new TokenType(\"::\", {\n    beforeExpr: beforeExpr\n  }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", {\n    beforeExpr: beforeExpr\n  }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", {\n    beforeExpr: beforeExpr\n  }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", {\n    beforeExpr: beforeExpr\n  }),\n  backQuote: new TokenType(\"`\", {\n    startsExpr: startsExpr\n  }),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr: beforeExpr,\n    startsExpr: startsExpr\n  }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\"),\n  eq: new TokenType(\"=\", {\n    beforeExpr: beforeExpr,\n    isAssign: isAssign\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr: beforeExpr,\n    isAssign: isAssign\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix: prefix,\n    postfix: postfix,\n    startsExpr: startsExpr\n  }),\n  bang: new TokenType(\"!\", {\n    beforeExpr: beforeExpr,\n    prefix: prefix,\n    startsExpr: startsExpr\n  }),\n  tilde: new TokenType(\"~\", {\n    beforeExpr: beforeExpr,\n    prefix: prefix,\n    startsExpr: startsExpr\n  }),\n  pipeline: new BinopTokenType(\"|>\", 0),\n  nullishCoalescing: new BinopTokenType(\"??\", 1),\n  logicalOR: new BinopTokenType(\"||\", 1),\n  logicalAND: new BinopTokenType(\"&&\", 2),\n  bitwiseOR: new BinopTokenType(\"|\", 3),\n  bitwiseXOR: new BinopTokenType(\"^\", 4),\n  bitwiseAND: new BinopTokenType(\"&\", 5),\n  equality: new BinopTokenType(\"==/!=\", 6),\n  relational: new BinopTokenType(\"</>\", 7),\n  bitShift: new BinopTokenType(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr: beforeExpr,\n    binop: 9,\n    prefix: prefix,\n    startsExpr: startsExpr\n  }),\n  modulo: new BinopTokenType(\"%\", 10),\n  star: new BinopTokenType(\"*\", 10),\n  slash: new BinopTokenType(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr: beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  })\n};\nvar keywords = {\n  break: new KeywordTokenType(\"break\"),\n  case: new KeywordTokenType(\"case\", {\n    beforeExpr: beforeExpr\n  }),\n  catch: new KeywordTokenType(\"catch\"),\n  continue: new KeywordTokenType(\"continue\"),\n  debugger: new KeywordTokenType(\"debugger\"),\n  default: new KeywordTokenType(\"default\", {\n    beforeExpr: beforeExpr\n  }),\n  do: new KeywordTokenType(\"do\", {\n    isLoop: isLoop,\n    beforeExpr: beforeExpr\n  }),\n  else: new KeywordTokenType(\"else\", {\n    beforeExpr: beforeExpr\n  }),\n  finally: new KeywordTokenType(\"finally\"),\n  for: new KeywordTokenType(\"for\", {\n    isLoop: isLoop\n  }),\n  function: new KeywordTokenType(\"function\", {\n    startsExpr: startsExpr\n  }),\n  if: new KeywordTokenType(\"if\"),\n  return: new KeywordTokenType(\"return\", {\n    beforeExpr: beforeExpr\n  }),\n  switch: new KeywordTokenType(\"switch\"),\n  throw: new KeywordTokenType(\"throw\", {\n    beforeExpr: beforeExpr,\n    prefix: prefix,\n    startsExpr: startsExpr\n  }),\n  try: new KeywordTokenType(\"try\"),\n  var: new KeywordTokenType(\"var\"),\n  let: new KeywordTokenType(\"let\"),\n  const: new KeywordTokenType(\"const\"),\n  while: new KeywordTokenType(\"while\", {\n    isLoop: isLoop\n  }),\n  with: new KeywordTokenType(\"with\"),\n  new: new KeywordTokenType(\"new\", {\n    beforeExpr: beforeExpr,\n    startsExpr: startsExpr\n  }),\n  this: new KeywordTokenType(\"this\", {\n    startsExpr: startsExpr\n  }),\n  super: new KeywordTokenType(\"super\", {\n    startsExpr: startsExpr\n  }),\n  class: new KeywordTokenType(\"class\"),\n  extends: new KeywordTokenType(\"extends\", {\n    beforeExpr: beforeExpr\n  }),\n  export: new KeywordTokenType(\"export\"),\n  import: new KeywordTokenType(\"import\", {\n    startsExpr: startsExpr\n  }),\n  yield: new KeywordTokenType(\"yield\", {\n    beforeExpr: beforeExpr,\n    startsExpr: startsExpr\n  }),\n  null: new KeywordTokenType(\"null\", {\n    startsExpr: startsExpr\n  }),\n  true: new KeywordTokenType(\"true\", {\n    startsExpr: startsExpr\n  }),\n  false: new KeywordTokenType(\"false\", {\n    startsExpr: startsExpr\n  }),\n  in: new KeywordTokenType(\"in\", {\n    beforeExpr: beforeExpr,\n    binop: 7\n  }),\n  instanceof: new KeywordTokenType(\"instanceof\", {\n    beforeExpr: beforeExpr,\n    binop: 7\n  }),\n  typeof: new KeywordTokenType(\"typeof\", {\n    beforeExpr: beforeExpr,\n    prefix: prefix,\n    startsExpr: startsExpr\n  }),\n  void: new KeywordTokenType(\"void\", {\n    beforeExpr: beforeExpr,\n    prefix: prefix,\n    startsExpr: startsExpr\n  }),\n  delete: new KeywordTokenType(\"delete\", {\n    beforeExpr: beforeExpr,\n    prefix: prefix,\n    startsExpr: startsExpr\n  })\n};\nObject.keys(keywords).forEach(function (name) {\n  types[\"_\" + name] = keywords[name];\n});\n\nfunction makePredicate(words) {\n  var wordsArr = words.split(\" \");\n  return function (str) {\n    return wordsArr.indexOf(str) >= 0;\n  };\n}\n\nvar reservedWords = {\n  \"6\": makePredicate(\"enum await\"),\n  strict: makePredicate(\"implements interface let package private protected public static yield\"),\n  strictBind: makePredicate(\"eval arguments\")\n};\nvar isKeyword = makePredicate(\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super\");\nvar nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\nvar nonASCIIidentifierChars = \"\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D4-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA900-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\";\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 55, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 698, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 1, 31, 6124, 20, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 19719, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];\n\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIteratorStart(current, next) {\n  return current === 64 && next === 64;\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code < 91) return true;\n  if (code < 97) return code === 95;\n  if (code < 123) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;\n}\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n};\nvar types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  templateQuasi: new TokContext(\"${\", true),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, function (p) {\n    return p.readTmplToken();\n  }),\n  functionExpression: new TokContext(\"function\", true)\n};\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  var out = this.state.context.pop();\n\n  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {\n    this.state.context.pop();\n    this.state.exprAllowed = false;\n  } else if (out === types$1.templateQuasi) {\n    this.state.exprAllowed = true;\n  } else {\n    this.state.exprAllowed = !out.isExpr;\n  }\n};\n\ntypes.name.updateContext = function (prevType) {\n  if (this.state.value === \"of\" && this.curContext() === types$1.parenStatement) {\n    this.state.exprAllowed = !prevType.beforeExpr;\n    return;\n  }\n\n  this.state.exprAllowed = false;\n\n  if (prevType === types._let || prevType === types._const || prevType === types._var) {\n    if (lineBreak.test(this.input.slice(this.state.end))) {\n      this.state.exprAllowed = true;\n    }\n  }\n\n  if (this.state.isIterator) {\n    this.state.isIterator = false;\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {};\n\ntypes._function.updateContext = function (prevType) {\n  if (this.state.exprAllowed && !this.braceIsBlock(prevType)) {\n    this.state.context.push(types$1.functionExpression);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n\n  this.state.exprAllowed = false;\n};\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\nvar SourceLocation = function SourceLocation(start, end) {\n  this.start = start;\n  this.end = end;\n};\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  }\n\n  throw new Error(\"Unreachable\");\n}\n\nvar BaseParser = function () {\n  function BaseParser() {\n    this.sawUnambiguousESM = false;\n  }\n\n  var _proto = BaseParser.prototype;\n\n  _proto.isReservedWord = function isReservedWord(word) {\n    if (word === \"await\") {\n      return this.inModule;\n    } else {\n      return reservedWords[6](word);\n    }\n  };\n\n  _proto.hasPlugin = function hasPlugin(name) {\n    return !!this.plugins[name];\n  };\n\n  return BaseParser;\n}();\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nvar CommentsParser = function (_BaseParser) {\n  _inheritsLoose(CommentsParser, _BaseParser);\n\n  function CommentsParser() {\n    return _BaseParser.apply(this, arguments) || this;\n  }\n\n  var _proto = CommentsParser.prototype;\n\n  _proto.addComment = function addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  };\n\n  _proto.processComment = function processComment(node) {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n    var stack = this.state.commentStack;\n    var firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        this.state.trailingComments.length = 0;\n      }\n    } else if (stack.length > 0) {\n      var lastInStack = last(stack);\n\n      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n        trailingComments = lastInStack.trailingComments;\n        delete lastInStack.trailingComments;\n      }\n    }\n\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild;\n\n    if (firstChild && this.state.leadingComments.length > 0) {\n      var lastComment = last(this.state.leadingComments);\n\n      if (firstChild.type === \"ObjectProperty\") {\n        if (lastComment.start >= node.start) {\n          if (this.state.commentPreviousNode) {\n            for (j = 0; j < this.state.leadingComments.length; j++) {\n              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n                this.state.leadingComments.splice(j, 1);\n                j--;\n              }\n            }\n\n            if (this.state.leadingComments.length > 0) {\n              firstChild.trailingComments = this.state.leadingComments;\n              this.state.leadingComments = [];\n            }\n          }\n        }\n      } else if (node.type === \"CallExpression\" && node.arguments && node.arguments.length) {\n        var lastArg = last(node.arguments);\n\n        if (lastArg && lastComment.start >= lastArg.start && lastComment.end <= node.end) {\n          if (this.state.commentPreviousNode) {\n            if (this.state.leadingComments.length > 0) {\n              lastArg.trailingComments = this.state.leadingComments;\n              this.state.leadingComments = [];\n            }\n          }\n        }\n      }\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        } else {\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        }\n\n        var leadingComments = this.state.leadingComments.slice(0, i);\n\n        if (leadingComments.length) {\n          node.leadingComments = leadingComments;\n        }\n\n        trailingComments = this.state.leadingComments.slice(i);\n\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n        node.innerComments = trailingComments;\n      } else {\n        node.trailingComments = trailingComments;\n      }\n    }\n\n    stack.push(node);\n  };\n\n  return CommentsParser;\n}(BaseParser);\n\nvar LocationParser = function (_CommentsParser) {\n  _inheritsLoose(LocationParser, _CommentsParser);\n\n  function LocationParser() {\n    return _CommentsParser.apply(this, arguments) || this;\n  }\n\n  var _proto = LocationParser.prototype;\n\n  _proto.raise = function raise(pos, message, _temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        missingPluginNames = _ref.missingPluginNames,\n        code = _ref.code;\n\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos;\n    err.loc = loc;\n\n    if (missingPluginNames) {\n      err.missingPlugin = missingPluginNames;\n    }\n\n    if (code !== undefined) {\n      err.code = code;\n    }\n\n    throw err;\n  };\n\n  return LocationParser;\n}(CommentsParser);\n\nvar State = function () {\n  function State() {}\n\n  var _proto = State.prototype;\n\n  _proto.init = function init(options, input) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n    this.input = input;\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.inMethod = this.inFunction = this.inParameters = this.maybeInArrowParameters = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.inClassProperty = this.noAnonFunctionType = this.hasFlowComment = this.isIterator = false;\n    this.classLevel = 0;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.yieldInPossibleArrowParameters = null;\n    this.tokens = [];\n    this.comments = [];\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n    this.commentPreviousNode = null;\n    this.pos = this.lineStart = 0;\n    this.curLine = options.startLine;\n    this.type = types.eof;\n    this.value = null;\n    this.start = this.end = this.pos;\n    this.startLoc = this.endLoc = this.curPosition();\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n    this.containsEsc = this.containsOctal = false;\n    this.octalPosition = null;\n    this.invalidTemplateEscapePosition = null;\n    this.exportedIdentifiers = [];\n  };\n\n  _proto.curPosition = function curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  };\n\n  _proto.clone = function clone(skipArrays) {\n    var _this = this;\n\n    var state = new State();\n    Object.keys(this).forEach(function (key) {\n      var val = _this[key];\n\n      if ((!skipArrays || key === \"context\") && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    });\n    return state;\n  };\n\n  return State;\n}();\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\n\nvar forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n  hex: [46, 88, 95, 120]\n};\nvar allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [48, 49];\nallowedNumericSeparatorSiblings.oct = allowedNumericSeparatorSiblings.bin.concat([50, 51, 52, 53, 54, 55]);\nallowedNumericSeparatorSiblings.dec = allowedNumericSeparatorSiblings.oct.concat([56, 57]);\nallowedNumericSeparatorSiblings.hex = allowedNumericSeparatorSiblings.dec.concat([65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);\nvar Token = function Token(state) {\n  this.type = state.type;\n  this.value = state.value;\n  this.start = state.start;\n  this.end = state.end;\n  this.loc = new SourceLocation(state.startLoc, state.endLoc);\n};\n\nfunction codePointToString(code) {\n  if (code <= 0xffff) {\n    return String.fromCharCode(code);\n  } else {\n    return String.fromCharCode((code - 0x10000 >> 10) + 0xd800, (code - 0x10000 & 1023) + 0xdc00);\n  }\n}\n\nvar Tokenizer = function (_LocationParser) {\n  _inheritsLoose(Tokenizer, _LocationParser);\n\n  function Tokenizer(options, input) {\n    var _this;\n\n    _this = _LocationParser.call(this) || this;\n    _this.state = new State();\n\n    _this.state.init(options, input);\n\n    _this.isLookahead = false;\n    return _this;\n  }\n\n  var _proto = Tokenizer.prototype;\n\n  _proto.next = function next() {\n    if (this.options.tokens && !this.isLookahead) {\n      this.state.tokens.push(new Token(this.state));\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  };\n\n  _proto.eat = function eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  _proto.match = function match(type) {\n    return this.state.type === type;\n  };\n\n  _proto.isKeyword = function isKeyword$$1(word) {\n    return isKeyword(word);\n  };\n\n  _proto.lookahead = function lookahead() {\n    var old = this.state;\n    this.state = old.clone(true);\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n    var curr = this.state;\n    this.state = old;\n    return curr;\n  };\n\n  _proto.setStrict = function setStrict(strict) {\n    this.state.strict = strict;\n    if (!this.match(types.num) && !this.match(types.string)) return;\n    this.state.pos = this.state.start;\n\n    while (this.state.pos < this.state.lineStart) {\n      this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1;\n      --this.state.curLine;\n    }\n\n    this.nextToken();\n  };\n\n  _proto.curContext = function curContext() {\n    return this.state.context[this.state.context.length - 1];\n  };\n\n  _proto.nextToken = function nextToken() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n    this.state.containsOctal = false;\n    this.state.octalPosition = null;\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.input.length) {\n      this.finishToken(types.eof);\n      return;\n    }\n\n    if (curContext.override) {\n      curContext.override(this);\n    } else {\n      this.readToken(this.fullCharCodeAtPos());\n    }\n  };\n\n  _proto.readToken = function readToken(code) {\n    if (isIdentifierStart(code) || code === 92) {\n      this.readWord();\n    } else {\n      this.getTokenFromCode(code);\n    }\n  };\n\n  _proto.fullCharCodeAtPos = function fullCharCodeAtPos() {\n    var code = this.input.charCodeAt(this.state.pos);\n    if (code <= 0xd7ff || code >= 0xe000) return code;\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    return (code << 10) + next - 0x35fdc00;\n  };\n\n  _proto.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n\n    if (!this.isLookahead) {\n      if (this.options.tokens) this.state.tokens.push(comment);\n      this.state.comments.push(comment);\n      this.addComment(comment);\n    }\n  };\n\n  _proto.skipBlockComment = function skipBlockComment() {\n    var startLoc = this.state.curPosition();\n    var start = this.state.pos;\n    var end = this.input.indexOf(\"*/\", this.state.pos += 2);\n    if (end === -1) this.raise(this.state.pos - 2, \"Unterminated comment\");\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    var match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  };\n\n  _proto.skipLineComment = function skipLineComment(startSkip) {\n    var start = this.state.pos;\n    var startLoc = this.state.curPosition();\n    var ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.input.length) {\n      while (ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233 && ++this.state.pos < this.input.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  };\n\n  _proto.skipSpace = function skipSpace() {\n    loop: while (this.state.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  };\n\n  _proto.finishToken = function finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    var prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    this.updateContext(prevType);\n  };\n\n  _proto.readToken_dot = function readToken_dot() {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    var next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 46 && next2 === 46) {\n      this.state.pos += 3;\n      this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.dot);\n    }\n  };\n\n  _proto.readToken_slash = function readToken_slash() {\n    if (this.state.exprAllowed) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.slash, 1);\n    }\n  };\n\n  _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {\n    var type = code === 42 ? types.star : types.modulo;\n    var width = 1;\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    var exprAllowed = this.state.exprAllowed;\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61 && !exprAllowed) {\n      width++;\n      type = types.assign;\n    }\n\n    this.finishOp(type, width);\n  };\n\n  _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      var assign = this.input.charCodeAt(this.state.pos + 2) === 61;\n\n      if (assign) {\n        this.expectPlugin(\"logicalAssignment\");\n      }\n\n      this.finishOp(assign ? types.assign : code === 124 ? types.logicalOR : types.logicalAND, assign ? 3 : 2);\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(types.pipeline, 2);\n        return;\n      } else if (next === 125 && this.hasPlugin(\"flow\")) {\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  };\n\n  _proto.readToken_caret = function readToken_caret() {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.bitwiseXOR, 1);\n    }\n  };\n\n  _proto.readToken_plus_min = function readToken_plus_min(code) {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n\n      this.finishOp(types.incDec, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.plusMin, 1);\n    }\n  };\n\n  _proto.readToken_lt_gt = function readToken_lt_gt(code) {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    var size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(types.assign, size + 1);\n        return;\n      }\n\n      this.finishOp(types.bitShift, size);\n      return;\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    this.finishOp(types.relational, size);\n  };\n\n  _proto.readToken_eq_excl = function readToken_eq_excl(code) {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(types.arrow);\n      return;\n    }\n\n    this.finishOp(code === 61 ? types.eq : types.bang, 1);\n  };\n\n  _proto.readToken_question = function readToken_question() {\n    var next = this.input.charCodeAt(this.state.pos + 1);\n    var next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63) {\n      this.finishOp(types.nullishCoalescing, 2);\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(types.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.question);\n    }\n  };\n\n  _proto.getTokenFromCode = function getTokenFromCode(code) {\n    switch (code) {\n      case 35:\n        if ((this.hasPlugin(\"classPrivateProperties\") || this.hasPlugin(\"classPrivateMethods\")) && this.state.classLevel > 0) {\n          ++this.state.pos;\n          this.finishToken(types.hash);\n          return;\n        } else {\n          this.raise(this.state.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n        }\n\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(types.parenL);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(types.parenR);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(types.semi);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(types.comma);\n        return;\n\n      case 91:\n        ++this.state.pos;\n        this.finishToken(types.bracketL);\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(types.bracketR);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"flow\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          this.finishOp(types.braceBarL, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.braceL);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(types.braceR);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.colon);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(types.at);\n        return;\n\n      case 96:\n        ++this.state.pos;\n        this.finishToken(types.backQuote);\n        return;\n\n      case 48:\n        {\n          var next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(types.tilde, 1);\n        return;\n    }\n\n    this.raise(this.state.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n  };\n\n  _proto.finishOp = function finishOp(type, size) {\n    var str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  };\n\n  _proto.readRegexp = function readRegexp() {\n    var start = this.state.pos;\n    var escaped, inClass;\n\n    for (;;) {\n      if (this.state.pos >= this.input.length) {\n        this.raise(start, \"Unterminated regular expression\");\n      }\n\n      var ch = this.input.charAt(this.state.pos);\n\n      if (lineBreak.test(ch)) {\n        this.raise(start, \"Unterminated regular expression\");\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      }\n\n      ++this.state.pos;\n    }\n\n    var content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    var validFlags = /^[gmsiyu]$/;\n    var mods = \"\";\n\n    while (this.state.pos < this.input.length) {\n      var char = this.input[this.state.pos];\n      var charCode = this.fullCharCodeAtPos();\n\n      if (validFlags.test(char)) {\n        ++this.state.pos;\n        mods += char;\n      } else if (isIdentifierChar(charCode) || charCode === 92) {\n        this.raise(this.state.pos, \"Invalid regular expression flag\");\n      } else {\n        break;\n      }\n    }\n\n    this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  };\n\n  _proto.readInt = function readInt(radix, len) {\n    var start = this.state.pos;\n    var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    var total = 0;\n\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.state.pos);\n      var val = void 0;\n\n      if (this.hasPlugin(\"numericSeparator\")) {\n        var prev = this.input.charCodeAt(this.state.pos - 1);\n        var next = this.input.charCodeAt(this.state.pos + 1);\n\n        if (code === 95) {\n          if (allowedSiblings.indexOf(next) === -1) {\n            this.raise(this.state.pos, \"Invalid or unexpected token\");\n          }\n\n          if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n            this.raise(this.state.pos, \"Invalid or unexpected token\");\n          }\n\n          ++this.state.pos;\n          continue;\n        }\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) break;\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len) {\n      return null;\n    }\n\n    return total;\n  };\n\n  _proto.readRadixNumber = function readRadixNumber(radix) {\n    var start = this.state.pos;\n    var isBigInt = false;\n    this.state.pos += 2;\n    var val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, \"Expected number in radix \" + radix);\n    }\n\n    if (this.hasPlugin(\"bigInt\")) {\n      if (this.input.charCodeAt(this.state.pos) === 110) {\n        ++this.state.pos;\n        isBigInt = true;\n      }\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n      this.raise(this.state.pos, \"Identifier directly after number\");\n    }\n\n    if (isBigInt) {\n      var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    this.finishToken(types.num, val);\n  };\n\n  _proto.readNumber = function readNumber(startsWithDot) {\n    var start = this.state.pos;\n    var octal = this.input.charCodeAt(start) === 48;\n    var isFloat = false;\n    var isBigInt = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, \"Invalid number\");\n    }\n\n    if (octal && this.state.pos == start + 1) octal = false;\n    var next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !octal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !octal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (this.hasPlugin(\"bigInt\")) {\n      if (next === 110) {\n        if (isFloat || octal) this.raise(start, \"Invalid BigIntLiteral\");\n        ++this.state.pos;\n        isBigInt = true;\n      }\n    }\n\n    if (isIdentifierStart(this.fullCharCodeAtPos())) {\n      this.raise(this.state.pos, \"Identifier directly after number\");\n    }\n\n    var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    var val;\n\n    if (isFloat) {\n      val = parseFloat(str);\n    } else if (!octal || str.length === 1) {\n      val = parseInt(str, 10);\n    } else if (this.state.strict) {\n      this.raise(start, \"Invalid number\");\n    } else if (/[89]/.test(str)) {\n      val = parseInt(str, 10);\n    } else {\n      val = parseInt(str, 8);\n    }\n\n    this.finishToken(types.num, val);\n  };\n\n  _proto.readCodePoint = function readCodePoint(throwOnInvalid) {\n    var ch = this.input.charCodeAt(this.state.pos);\n    var code;\n\n    if (ch === 123) {\n      var codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code === null) {\n        --this.state.invalidTemplateEscapePosition;\n      } else if (code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, \"Code point out of bounds\");\n        } else {\n          this.state.invalidTemplateEscapePosition = codePos - 2;\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, throwOnInvalid);\n    }\n\n    return code;\n  };\n\n  _proto.readString = function readString(quote) {\n    var out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.input.length) {\n        this.raise(this.state.start, \"Unterminated string constant\");\n      }\n\n      var ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else {\n        if (isNewLine(ch)) {\n          this.raise(this.state.start, \"Unterminated string constant\");\n        }\n\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(types.string, out);\n  };\n\n  _proto.readTmplToken = function readTmplToken() {\n    var out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.input.length) {\n        this.raise(this.state.start, \"Unterminated template\");\n      }\n\n      var ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(types.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(types.backQuote);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(types.template, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        var escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  };\n\n  _proto.readEscapedChar = function readEscapedChar(inTemplate) {\n    var throwOnInvalid = !inTemplate;\n    var ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          var code = this.readHexChar(2, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          var _code = this.readCodePoint(throwOnInvalid);\n\n          return _code === null ? null : codePointToString(_code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\x0B\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n        return \"\";\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          var codePos = this.state.pos - 1;\n          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];\n          var octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          if (octal > 0) {\n            if (inTemplate) {\n              this.state.invalidTemplateEscapePosition = codePos;\n              return null;\n            } else if (this.state.strict) {\n              this.raise(codePos, \"Octal literal in strict mode\");\n            } else if (!this.state.containsOctal) {\n              this.state.containsOctal = true;\n              this.state.octalPosition = codePos;\n            }\n          }\n\n          this.state.pos += octalStr.length - 1;\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  };\n\n  _proto.readHexChar = function readHexChar(len, throwOnInvalid) {\n    var codePos = this.state.pos;\n    var n = this.readInt(16, len);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, \"Bad character escape sequence\");\n      } else {\n        this.state.pos = codePos - 1;\n        this.state.invalidTemplateEscapePosition = codePos - 1;\n      }\n    }\n\n    return n;\n  };\n\n  _proto.readWord1 = function readWord1() {\n    this.state.containsEsc = false;\n    var word = \"\",\n        first = true,\n        chunkStart = this.state.pos;\n\n    while (this.state.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (this.state.isIterator && ch === 64) {\n        this.state.pos += 1;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        var escStart = this.state.pos;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(this.state.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        }\n\n        ++this.state.pos;\n        var esc = this.readCodePoint(true);\n\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {\n          this.raise(escStart, \"Invalid Unicode escape\");\n        }\n\n        word += codePointToString(esc);\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n\n      first = false;\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  };\n\n  _proto.isIterator = function isIterator(word) {\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\n  };\n\n  _proto.readWord = function readWord() {\n    var word = this.readWord1();\n    var type = types.name;\n\n    if (this.isKeyword(word)) {\n      if (this.state.containsEsc) {\n        this.raise(this.state.pos, \"Escape sequence in keyword \" + word);\n      }\n\n      type = keywords[word];\n    }\n\n    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {\n      this.raise(this.state.pos, \"Invalid identifier \" + word);\n    }\n\n    this.finishToken(type, word);\n  };\n\n  _proto.braceIsBlock = function braceIsBlock(prevType) {\n    if (prevType === types.colon) {\n      var parent = this.curContext();\n\n      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {\n        return !parent.isExpr;\n      }\n    }\n\n    if (prevType === types._return) {\n      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return this.curContext() === types$1.braceStatement;\n    }\n\n    if (prevType === types.relational) {\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  };\n\n  _proto.updateContext = function updateContext(prevType) {\n    var type = this.state.type;\n    var update;\n\n    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  };\n\n  return Tokenizer;\n}(LocationParser);\n\nvar UtilParser = function (_Tokenizer) {\n  _inheritsLoose(UtilParser, _Tokenizer);\n\n  function UtilParser() {\n    return _Tokenizer.apply(this, arguments) || this;\n  }\n\n  var _proto = UtilParser.prototype;\n\n  _proto.addExtra = function addExtra(node, key, val) {\n    if (!node) return;\n    var extra = node.extra = node.extra || {};\n    extra[key] = val;\n  };\n\n  _proto.isRelational = function isRelational(op) {\n    return this.match(types.relational) && this.state.value === op;\n  };\n\n  _proto.expectRelational = function expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, types.relational);\n    }\n  };\n\n  _proto.eatRelational = function eatRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.isContextual = function isContextual(name) {\n    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;\n  };\n\n  _proto.isLookaheadContextual = function isLookaheadContextual(name) {\n    var l = this.lookahead();\n    return l.type === types.name && l.value === name;\n  };\n\n  _proto.eatContextual = function eatContextual(name) {\n    return this.isContextual(name) && this.eat(types.name);\n  };\n\n  _proto.expectContextual = function expectContextual(name, message) {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  };\n\n  _proto.canInsertSemicolon = function canInsertSemicolon() {\n    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();\n  };\n\n  _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  };\n\n  _proto.isLineTerminator = function isLineTerminator() {\n    return this.eat(types.semi) || this.canInsertSemicolon();\n  };\n\n  _proto.semicolon = function semicolon() {\n    if (!this.isLineTerminator()) this.unexpected(null, types.semi);\n  };\n\n  _proto.expect = function expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  };\n\n  _proto.unexpected = function unexpected(pos, messageOrType) {\n    if (messageOrType === void 0) {\n      messageOrType = \"Unexpected token\";\n    }\n\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = \"Unexpected token, expected \\\"\" + messageOrType.label + \"\\\"\";\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  };\n\n  _proto.expectPlugin = function expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raise(pos != null ? pos : this.state.start, \"This experimental syntax requires enabling the parser plugin: '\" + name + \"'\", {\n        missingPluginNames: [name]\n      });\n    }\n\n    return true;\n  };\n\n  _proto.expectOnePlugin = function expectOnePlugin(names, pos) {\n    var _this = this;\n\n    if (!names.some(function (n) {\n      return _this.hasPlugin(n);\n    })) {\n      throw this.raise(pos != null ? pos : this.state.start, \"This experimental syntax requires enabling one of the following parser plugin(s): '\" + names.join(\", \") + \"'\", {\n        missingPluginNames: names\n      });\n    }\n  };\n\n  return UtilParser;\n}(Tokenizer);\n\nvar commentKeys = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\n\nvar Node = function () {\n  function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser && parser.options.ranges) this.range = [pos, 0];\n    if (parser && parser.filename) this.loc.filename = parser.filename;\n  }\n\n  var _proto = Node.prototype;\n\n  _proto.__clone = function __clone() {\n    var _this = this;\n\n    var node2 = new Node();\n    Object.keys(this).forEach(function (key) {\n      if (commentKeys.indexOf(key) < 0) {\n        node2[key] = _this[key];\n      }\n    });\n    return node2;\n  };\n\n  return Node;\n}();\n\nvar NodeUtils = function (_UtilParser) {\n  _inheritsLoose(NodeUtils, _UtilParser);\n\n  function NodeUtils() {\n    return _UtilParser.apply(this, arguments) || this;\n  }\n\n  var _proto2 = NodeUtils.prototype;\n\n  _proto2.startNode = function startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  };\n\n  _proto2.startNodeAt = function startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  };\n\n  _proto2.startNodeAtNode = function startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  };\n\n  _proto2.finishNode = function finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  };\n\n  _proto2.finishNodeAt = function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  };\n\n  _proto2.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {\n    node.start = locationNode.start;\n    node.loc.start = locationNode.loc.start;\n    if (this.options.ranges) node.range[0] = locationNode.range[0];\n  };\n\n  return NodeUtils;\n}(UtilParser);\n\nvar LValParser = function (_NodeUtils) {\n  _inheritsLoose(LValParser, _NodeUtils);\n\n  function LValParser() {\n    return _NodeUtils.apply(this, arguments) || this;\n  }\n\n  var _proto = LValParser.prototype;\n\n  _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {\n    if (node) {\n      switch (node.type) {\n        case \"Identifier\":\n        case \"ObjectPattern\":\n        case \"ArrayPattern\":\n        case \"AssignmentPattern\":\n          break;\n\n        case \"ObjectExpression\":\n          node.type = \"ObjectPattern\";\n\n          for (var index = 0; index < node.properties.length; index++) {\n            var prop = node.properties[index];\n            var isLast = index === node.properties.length - 1;\n            this.toAssignableObjectExpressionProp(prop, isBinding, isLast);\n          }\n\n          break;\n\n        case \"ObjectProperty\":\n          this.toAssignable(node.value, isBinding, contextDescription);\n          break;\n\n        case \"SpreadElement\":\n          {\n            this.checkToRestConversion(node);\n            node.type = \"RestElement\";\n            var arg = node.argument;\n            this.toAssignable(arg, isBinding, contextDescription);\n            break;\n          }\n\n        case \"ArrayExpression\":\n          node.type = \"ArrayPattern\";\n          this.toAssignableList(node.elements, isBinding, contextDescription);\n          break;\n\n        case \"AssignmentExpression\":\n          if (node.operator === \"=\") {\n            node.type = \"AssignmentPattern\";\n            delete node.operator;\n          } else {\n            this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n          }\n\n          break;\n\n        case \"MemberExpression\":\n          if (!isBinding) break;\n\n        default:\n          {\n            var message = \"Invalid left-hand side\" + (contextDescription ? \" in \" + contextDescription : \"expression\");\n            this.raise(node.start, message);\n          }\n      }\n    }\n\n    return node;\n  };\n\n  _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isBinding, isLast) {\n    if (prop.type === \"ObjectMethod\") {\n      var error = prop.kind === \"get\" || prop.kind === \"set\" ? \"Object pattern can't contain getter or setter\" : \"Object pattern can't contain methods\";\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raise(prop.start, \"The rest element has to be the last element when destructuring\");\n    } else {\n      this.toAssignable(prop, isBinding, \"object destructuring pattern\");\n    }\n  };\n\n  _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {\n    var end = exprList.length;\n\n    if (end) {\n      var last = exprList[end - 1];\n\n      if (last && last.type === \"RestElement\") {\n        --end;\n      } else if (last && last.type === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        var arg = last.argument;\n        this.toAssignable(arg, isBinding, contextDescription);\n\n        if ([\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\"].indexOf(arg.type) === -1) {\n          this.unexpected(arg.start);\n        }\n\n        --end;\n      }\n    }\n\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n\n      if (elt && elt.type === \"SpreadElement\") {\n        this.raise(elt.start, \"The rest element has to be the last element when destructuring\");\n      }\n\n      if (elt) this.toAssignable(elt, isBinding, contextDescription);\n    }\n\n    return exprList;\n  };\n\n  _proto.toReferencedList = function toReferencedList(exprList) {\n    return exprList;\n  };\n\n  _proto.parseSpread = function parseSpread(refShorthandDefaultPos, refNeedsArrowPos) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  };\n\n  _proto.parseRest = function parseRest() {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  };\n\n  _proto.shouldAllowYieldIdentifier = function shouldAllowYieldIdentifier() {\n    return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;\n  };\n\n  _proto.parseBindingIdentifier = function parseBindingIdentifier() {\n    return this.parseIdentifier(this.shouldAllowYieldIdentifier());\n  };\n\n  _proto.parseBindingAtom = function parseBindingAtom() {\n    switch (this.state.type) {\n      case types._yield:\n      case types.name:\n        return this.parseBindingIdentifier();\n\n      case types.bracketL:\n        {\n          var node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case types.braceL:\n        return this.parseObj(true);\n\n      default:\n        throw this.unexpected();\n    }\n  };\n\n  _proto.parseBindingList = function parseBindingList(close, allowEmpty, allowModifiers) {\n    var elts = [];\n    var first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n      }\n\n      if (allowEmpty && this.match(types.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(types.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRest()));\n        this.expect(close);\n        break;\n      } else {\n        var decorators = [];\n\n        if (this.match(types.at) && this.hasPlugin(\"decorators2\")) {\n          this.raise(this.state.start, \"Stage 2 decorators cannot be used to decorate parameters\");\n        }\n\n        while (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  };\n\n  _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {\n    var left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    var elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  };\n\n  _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {\n    return param;\n  };\n\n  _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {\n    startLoc = startLoc || this.state.startLoc;\n    startPos = startPos || this.state.start;\n    left = left || this.parseBindingAtom();\n    if (!this.eat(types.eq)) return left;\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n  };\n\n  _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {\n    switch (expr.type) {\n      case \"Identifier\":\n        this.checkReservedWord(expr.name, expr.start, false, true);\n\n        if (checkClashes) {\n          var _key = \"_\" + expr.name;\n\n          if (checkClashes[_key]) {\n            this.raise(expr.start, \"Argument name clash in strict mode\");\n          } else {\n            checkClashes[_key] = true;\n          }\n        }\n\n        break;\n\n      case \"MemberExpression\":\n        if (isBinding) this.raise(expr.start, \"Binding member expression\");\n        break;\n\n      case \"ObjectPattern\":\n        for (var _i2 = 0, _expr$properties2 = expr.properties; _i2 < _expr$properties2.length; _i2++) {\n          var prop = _expr$properties2[_i2];\n          if (prop.type === \"ObjectProperty\") prop = prop.value;\n          this.checkLVal(prop, isBinding, checkClashes, \"object destructuring pattern\");\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (var _i4 = 0, _expr$elements2 = expr.elements; _i4 < _expr$elements2.length; _i4++) {\n          var elem = _expr$elements2[_i4];\n\n          if (elem) {\n            this.checkLVal(elem, isBinding, checkClashes, \"array destructuring pattern\");\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, isBinding, checkClashes, \"assignment pattern\");\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, isBinding, checkClashes, \"rest element\");\n        break;\n\n      default:\n        {\n          var message = (isBinding ? \"Binding invalid\" : \"Invalid\") + \" left-hand side\" + (contextDescription ? \" in \" + contextDescription : \"expression\");\n          this.raise(expr.start, message);\n        }\n    }\n  };\n\n  _proto.checkToRestConversion = function checkToRestConversion(node) {\n    var validArgumentTypes = [\"Identifier\", \"MemberExpression\"];\n\n    if (validArgumentTypes.indexOf(node.argument.type) !== -1) {\n      return;\n    }\n\n    this.raise(node.argument.start, \"Invalid rest operator's argument\");\n  };\n\n  return LValParser;\n}(NodeUtils);\n\nvar ExpressionParser = function (_LValParser) {\n  _inheritsLoose(ExpressionParser, _LValParser);\n\n  function ExpressionParser() {\n    return _LValParser.apply(this, arguments) || this;\n  }\n\n  var _proto = ExpressionParser.prototype;\n\n  _proto.checkPropClash = function checkPropClash(prop, propHash) {\n    if (prop.computed || prop.kind) return;\n    var key = prop.key;\n    var name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n    if (name === \"__proto__\") {\n      if (propHash.proto) {\n        this.raise(key.start, \"Redefinition of __proto__ property\");\n      }\n\n      propHash.proto = true;\n    }\n  };\n\n  _proto.getExpression = function getExpression() {\n    this.nextToken();\n    var expr = this.parseExpression();\n\n    if (!this.match(types.eof)) {\n      this.unexpected();\n    }\n\n    expr.comments = this.state.comments;\n    return expr;\n  };\n\n  _proto.parseExpression = function parseExpression(noIn, refShorthandDefaultPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);\n\n    if (this.match(types.comma)) {\n      var _node = this.startNodeAt(startPos, startLoc);\n\n      _node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        _node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));\n      }\n\n      this.toReferencedList(_node.expressions);\n      return this.finishNode(_node, \"SequenceExpression\");\n    }\n\n    return expr;\n  };\n\n  _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n\n    if (this.match(types._yield) && this.state.inGenerator) {\n      var _left = this.parseYield();\n\n      if (afterLeftParse) {\n        _left = afterLeftParse.call(this, _left, startPos, startLoc);\n      }\n\n      return _left;\n    }\n\n    var failOnShorthandAssign;\n\n    if (refShorthandDefaultPos) {\n      failOnShorthandAssign = false;\n    } else {\n      refShorthandDefaultPos = {\n        start: 0\n      };\n      failOnShorthandAssign = true;\n    }\n\n    if (this.match(types.parenL) || this.match(types.name) || this.match(types._yield)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.state.type.isAssign) {\n      var _node2 = this.startNodeAt(startPos, startLoc);\n\n      _node2.operator = this.state.value;\n      _node2.left = this.match(types.eq) ? this.toAssignable(left, undefined, \"assignment expression\") : left;\n      refShorthandDefaultPos.start = 0;\n      this.checkLVal(left, undefined, undefined, \"assignment expression\");\n\n      if (left.extra && left.extra.parenthesized) {\n        var errorMsg;\n\n        if (left.type === \"ObjectPattern\") {\n          errorMsg = \"`({a}) = 0` use `({a} = 0)`\";\n        } else if (left.type === \"ArrayPattern\") {\n          errorMsg = \"`([a]) = 0` use `([a] = 0)`\";\n        }\n\n        if (errorMsg) {\n          this.raise(left.start, \"You're trying to assign to a parenthesized expression, eg. instead of \" + errorMsg);\n        }\n      }\n\n      this.next();\n      _node2.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(_node2, \"AssignmentExpression\");\n    } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    return left;\n  };\n\n  _proto.parseMaybeConditional = function parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var potentialArrowAt = this.state.potentialArrowAt;\n    var expr = this.parseExprOps(noIn, refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n  };\n\n  _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (this.eat(types.question)) {\n      var _node3 = this.startNodeAt(startPos, startLoc);\n\n      _node3.test = expr;\n      _node3.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      _node3.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(_node3, \"ConditionalExpression\");\n    }\n\n    return expr;\n  };\n\n  _proto.parseExprOps = function parseExprOps(noIn, refShorthandDefaultPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var potentialArrowAt = this.state.potentialArrowAt;\n    var expr = this.parseMaybeUnary(refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  };\n\n  _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.state.type.binop;\n\n    if (prec != null && (!noIn || !this.match(types._in))) {\n      if (prec > minPrec) {\n        var _node4 = this.startNodeAt(leftStartPos, leftStartLoc);\n\n        _node4.left = left;\n        _node4.operator = this.state.value;\n\n        if (_node4.operator === \"**\" && left.type === \"UnaryExpression\" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {\n          this.raise(left.argument.start, \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\");\n        }\n\n        var op = this.state.type;\n        this.next();\n        var startPos = this.state.start;\n        var startLoc = this.state.startLoc;\n\n        if (_node4.operator === \"|>\") {\n          this.expectPlugin(\"pipelineOperator\");\n          this.state.potentialArrowAt = startPos;\n        }\n\n        if (_node4.operator === \"??\") {\n          this.expectPlugin(\"nullishCoalescingOperator\");\n        }\n\n        _node4.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);\n        this.finishNode(_node4, op === types.logicalOR || op === types.logicalAND || op === types.nullishCoalescing ? \"LogicalExpression\" : \"BinaryExpression\");\n        return this.parseExprOp(_node4, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n    }\n\n    return left;\n  };\n\n  _proto.parseMaybeUnary = function parseMaybeUnary(refShorthandDefaultPos) {\n    if (this.state.type.prefix) {\n      var _node5 = this.startNode();\n\n      var update = this.match(types.incDec);\n      _node5.operator = this.state.value;\n      _node5.prefix = true;\n\n      if (_node5.operator === \"throw\") {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      this.next();\n      var argType = this.state.type;\n      _node5.argument = this.parseMaybeUnary();\n      this.addExtra(_node5, \"parenthesizedArgument\", argType === types.parenL && (!_node5.argument.extra || !_node5.argument.extra.parenthesized));\n\n      if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n        this.unexpected(refShorthandDefaultPos.start);\n      }\n\n      if (update) {\n        this.checkLVal(_node5.argument, undefined, undefined, \"prefix operation\");\n      } else if (this.state.strict && _node5.operator === \"delete\") {\n        var arg = _node5.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(_node5.start, \"Deleting local variable in strict mode\");\n        } else if (arg.type === \"MemberExpression\" && arg.property.type === \"PrivateName\") {\n          this.raise(_node5.start, \"Deleting a private field is not allowed\");\n        }\n      }\n\n      return this.finishNode(_node5, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var expr = this.parseExprSubscripts(refShorthandDefaultPos);\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;\n\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      var _node6 = this.startNodeAt(startPos, startLoc);\n\n      _node6.operator = this.state.value;\n      _node6.prefix = false;\n      _node6.argument = expr;\n      this.checkLVal(expr, undefined, undefined, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(_node6, \"UpdateExpression\");\n    }\n\n    return expr;\n  };\n\n  _proto.parseExprSubscripts = function parseExprSubscripts(refShorthandDefaultPos) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var potentialArrowAt = this.state.potentialArrowAt;\n    var expr = this.parseExprAtom(refShorthandDefaultPos);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  };\n\n  _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {\n    var state = {\n      optionalChainMember: false,\n      stop: false\n    };\n\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n    } while (!state.stop);\n\n    return base;\n  };\n\n  _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      var _node7 = this.startNodeAt(startPos, startLoc);\n\n      _node7.object = base;\n      _node7.callee = this.parseNoCallExpr();\n      state.stop = true;\n      return this.parseSubscripts(this.finishNode(_node7, \"BindExpression\"), startPos, startLoc, noCalls);\n    } else if (this.match(types.questionDot)) {\n      this.expectPlugin(\"optionalChaining\");\n      state.optionalChainMember = true;\n\n      if (noCalls && this.lookahead().type == types.parenL) {\n        state.stop = true;\n        return base;\n      }\n\n      this.next();\n\n      var _node8 = this.startNodeAt(startPos, startLoc);\n\n      if (this.eat(types.bracketL)) {\n        _node8.object = base;\n        _node8.property = this.parseExpression();\n        _node8.computed = true;\n        _node8.optional = true;\n        this.expect(types.bracketR);\n        return this.finishNode(_node8, \"OptionalMemberExpression\");\n      } else if (this.eat(types.parenL)) {\n        var possibleAsync = this.atPossibleAsync(base);\n        _node8.callee = base;\n        _node8.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);\n        _node8.optional = true;\n        return this.finishNode(_node8, \"OptionalCallExpression\");\n      } else {\n        _node8.object = base;\n        _node8.property = this.parseIdentifier(true);\n        _node8.computed = false;\n        _node8.optional = true;\n        return this.finishNode(_node8, \"OptionalMemberExpression\");\n      }\n    } else if (this.eat(types.dot)) {\n      var _node9 = this.startNodeAt(startPos, startLoc);\n\n      _node9.object = base;\n      _node9.property = this.parseMaybePrivateName();\n      _node9.computed = false;\n\n      if (state.optionalChainMember) {\n        _node9.optional = false;\n        return this.finishNode(_node9, \"OptionalMemberExpression\");\n      }\n\n      return this.finishNode(_node9, \"MemberExpression\");\n    } else if (this.eat(types.bracketL)) {\n      var _node10 = this.startNodeAt(startPos, startLoc);\n\n      _node10.object = base;\n      _node10.property = this.parseExpression();\n      _node10.computed = true;\n      this.expect(types.bracketR);\n\n      if (state.optionalChainMember) {\n        _node10.optional = false;\n        return this.finishNode(_node10, \"OptionalMemberExpression\");\n      }\n\n      return this.finishNode(_node10, \"MemberExpression\");\n    } else if (!noCalls && this.match(types.parenL)) {\n      var _possibleAsync = this.atPossibleAsync(base);\n\n      this.next();\n\n      var _node11 = this.startNodeAt(startPos, startLoc);\n\n      _node11.callee = base;\n      var refTrailingCommaPos = {\n        start: -1\n      };\n      _node11.arguments = this.parseCallExpressionArguments(types.parenR, _possibleAsync, refTrailingCommaPos);\n\n      if (!state.optionalChainMember) {\n        this.finishCallExpression(_node11);\n      } else {\n        this.finishOptionalCallExpression(_node11);\n      }\n\n      if (_possibleAsync && this.shouldParseAsyncArrow()) {\n        state.stop = true;\n\n        if (refTrailingCommaPos.start > -1) {\n          this.raise(refTrailingCommaPos.start, \"A trailing comma is not permitted after the rest element\");\n        }\n\n        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node11);\n      } else {\n        this.toReferencedList(_node11.arguments);\n      }\n\n      return _node11;\n    } else if (this.match(types.backQuote)) {\n      var _node12 = this.startNodeAt(startPos, startLoc);\n\n      _node12.tag = base;\n      _node12.quasi = this.parseTemplate(true);\n\n      if (state.optionalChainMember) {\n        this.raise(startPos, \"Tagged Template Literals are not allowed in optionalChain\");\n      }\n\n      return this.finishNode(_node12, \"TaggedTemplateExpression\");\n    } else {\n      state.stop = true;\n      return base;\n    }\n  };\n\n  _proto.atPossibleAsync = function atPossibleAsync(base) {\n    return !this.state.containsEsc && this.state.potentialArrowAt === base.start && base.type === \"Identifier\" && base.name === \"async\" && !this.canInsertSemicolon();\n  };\n\n  _proto.finishCallExpression = function finishCallExpression(node) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length !== 1) {\n        this.raise(node.start, \"import() requires exactly one argument\");\n      }\n\n      var importArg = node.arguments[0];\n\n      if (importArg && importArg.type === \"SpreadElement\") {\n        this.raise(importArg.start, \"... is not allowed in import()\");\n      }\n    }\n\n    return this.finishNode(node, \"CallExpression\");\n  };\n\n  _proto.finishOptionalCallExpression = function finishOptionalCallExpression(node) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length !== 1) {\n        this.raise(node.start, \"import() requires exactly one argument\");\n      }\n\n      var importArg = node.arguments[0];\n\n      if (importArg && importArg.type === \"SpreadElement\") {\n        this.raise(importArg.start, \"... is not allowed in import()\");\n      }\n    }\n\n    return this.finishNode(node, \"OptionalCallExpression\");\n  };\n\n  _proto.parseCallExpressionArguments = function parseCallExpressionArguments(close, possibleAsyncArrow, refTrailingCommaPos) {\n    var elts = [];\n    var innerParenStart;\n    var first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(close)) break;\n      }\n\n      if (this.match(types.parenL) && !innerParenStart) {\n        innerParenStart = this.state.start;\n      }\n\n      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, possibleAsyncArrow ? refTrailingCommaPos : undefined));\n    }\n\n    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {\n      this.unexpected();\n    }\n\n    return elts;\n  };\n\n  _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {\n    return this.match(types.arrow);\n  };\n\n  _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {\n    var oldYield = this.state.yieldInPossibleArrowParameters;\n    this.state.yieldInPossibleArrowParameters = null;\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, call.arguments, true);\n    this.state.yieldInPossibleArrowParameters = oldYield;\n    return node;\n  };\n\n  _proto.parseNoCallExpr = function parseNoCallExpr() {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  };\n\n  _proto.parseExprAtom = function parseExprAtom(refShorthandDefaultPos) {\n    var canBeArrow = this.state.potentialArrowAt === this.state.start;\n    var node;\n\n    switch (this.state.type) {\n      case types._super:\n        if (!this.state.inMethod && !this.state.inClassProperty && !this.options.allowSuperOutsideMethod) {\n          this.raise(this.state.start, \"super is only allowed in object methods and classes\");\n        }\n\n        node = this.startNode();\n        this.next();\n\n        if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n          this.unexpected();\n        }\n\n        if (this.match(types.parenL) && this.state.inMethod !== \"constructor\" && !this.options.allowSuperOutsideMethod) {\n          this.raise(node.start, \"super() is only valid inside a class constructor. Make sure the method name is spelled exactly as 'constructor'.\");\n        }\n\n        return this.finishNode(node, \"Super\");\n\n      case types._import:\n        if (this.lookahead().type === types.dot) {\n          return this.parseImportMetaProperty();\n        }\n\n        this.expectPlugin(\"dynamicImport\");\n        node = this.startNode();\n        this.next();\n\n        if (!this.match(types.parenL)) {\n          this.unexpected(null, types.parenL);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types._yield:\n        if (this.state.inGenerator) this.unexpected();\n\n      case types.name:\n        {\n          node = this.startNode();\n          var allowAwait = this.state.value === \"await\" && this.state.inAsync;\n          var containsEsc = this.state.containsEsc;\n          var allowYield = this.shouldAllowYieldIdentifier();\n          var id = this.parseIdentifier(allowAwait || allowYield);\n\n          if (id.name === \"await\") {\n            if (this.state.inAsync || this.inModule) {\n              return this.parseAwait(node);\n            }\n          } else if (!containsEsc && id.name === \"async\" && this.match(types._function) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseFunction(node, false, false, true);\n          } else if (canBeArrow && id.name === \"async\" && this.match(types.name)) {\n            var oldYield = this.state.yieldInPossibleArrowParameters;\n            this.state.yieldInPossibleArrowParameters = null;\n            var params = [this.parseIdentifier()];\n            this.expect(types.arrow);\n            this.parseArrowExpression(node, params, true);\n            this.state.yieldInPossibleArrowParameters = oldYield;\n            return node;\n          }\n\n          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n            var _oldYield = this.state.yieldInPossibleArrowParameters;\n            this.state.yieldInPossibleArrowParameters = null;\n            this.parseArrowExpression(node, [id]);\n            this.state.yieldInPossibleArrowParameters = _oldYield;\n            return node;\n          }\n\n          return id;\n        }\n\n      case types._do:\n        {\n          this.expectPlugin(\"doExpressions\");\n\n          var _node13 = this.startNode();\n\n          this.next();\n          var oldInFunction = this.state.inFunction;\n          var oldLabels = this.state.labels;\n          this.state.labels = [];\n          this.state.inFunction = false;\n          _node13.body = this.parseBlock(false);\n          this.state.inFunction = oldInFunction;\n          this.state.labels = oldLabels;\n          return this.finishNode(_node13, \"DoExpression\");\n        }\n\n      case types.regexp:\n        {\n          var value = this.state.value;\n          node = this.parseLiteral(value.value, \"RegExpLiteral\");\n          node.pattern = value.pattern;\n          node.flags = value.flags;\n          return node;\n        }\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case types._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case types._true:\n      case types._false:\n        return this.parseBooleanLiteral();\n\n      case types.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case types.bracketL:\n        node = this.startNode();\n        this.next();\n        node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);\n        this.toReferencedList(node.elements);\n        return this.finishNode(node, \"ArrayExpression\");\n\n      case types.braceL:\n        return this.parseObj(false, refShorthandDefaultPos);\n\n      case types._function:\n        return this.parseFunctionExpression();\n\n      case types.at:\n        this.parseDecorators();\n\n      case types._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case types._new:\n        return this.parseNew();\n\n      case types.backQuote:\n        return this.parseTemplate(false);\n\n      case types.doubleColon:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          var callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, \"Binding should be performed on object property.\");\n          }\n        }\n\n      default:\n        throw this.unexpected();\n    }\n  };\n\n  _proto.parseBooleanLiteral = function parseBooleanLiteral() {\n    var node = this.startNode();\n    node.value = this.match(types._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  };\n\n  _proto.parseMaybePrivateName = function parseMaybePrivateName() {\n    var isPrivate = this.match(types.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n\n      var _node14 = this.startNode();\n\n      this.next();\n      _node14.id = this.parseIdentifier(true);\n      return this.finishNode(_node14, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  };\n\n  _proto.parseFunctionExpression = function parseFunctionExpression() {\n    var node = this.startNode();\n    var meta = this.parseIdentifier(true);\n\n    if (this.state.inGenerator && this.eat(types.dot)) {\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node, false);\n  };\n\n  _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n    }\n\n    var containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(node.property.start, \"The only valid meta property for \" + meta.name + \" is \" + meta.name + \".\" + propertyName);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  };\n\n  _proto.parseImportMetaProperty = function parseImportMetaProperty() {\n    var node = this.startNode();\n    var id = this.parseIdentifier(true);\n    this.expect(types.dot);\n\n    if (id.name === \"import\") {\n      if (this.isContextual(\"meta\")) {\n        this.expectPlugin(\"importMeta\");\n      } else if (!this.hasPlugin(\"importMeta\")) {\n        this.raise(id.start, \"Dynamic imports require a parameter: import('a.js').then\");\n      }\n    }\n\n    if (!this.inModule) {\n      this.raise(id.start, \"import.meta may appear only with 'sourceType: \\\"module\\\"'\", {\n        code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n      });\n    }\n\n    this.sawUnambiguousESM = true;\n    return this.parseMetaProperty(node, id, \"meta\");\n  };\n\n  _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    var node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  };\n\n  _proto.parseParenExpression = function parseParenExpression() {\n    this.expect(types.parenL);\n    var val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  };\n\n  _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {\n    var startPos = this.state.start;\n    var startLoc = this.state.startLoc;\n    var val;\n    this.expect(types.parenL);\n    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    var oldYield = this.state.yieldInPossibleArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    this.state.yieldInPossibleArrowParameters = null;\n    var innerStartPos = this.state.start;\n    var innerStartLoc = this.state.startLoc;\n    var exprList = [];\n    var refShorthandDefaultPos = {\n      start: 0\n    };\n    var refNeedsArrowPos = {\n      start: 0\n    };\n    var first = true;\n    var spreadStart;\n    var optionalCommaStart;\n\n    while (!this.match(types.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma, refNeedsArrowPos.start || null);\n\n        if (this.match(types.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(types.ellipsis)) {\n        var spreadNodeStartPos = this.state.start;\n        var spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));\n\n        if (this.match(types.comma) && this.lookahead().type === types.parenR) {\n          this.raise(this.state.start, \"A trailing comma is not permitted after the rest element\");\n        }\n\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));\n      }\n    }\n\n    var innerEndPos = this.state.start;\n    var innerEndLoc = this.state.startLoc;\n    this.expect(types.parenR);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    var arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n      for (var _i2 = 0; _i2 < exprList.length; _i2++) {\n        var param = exprList[_i2];\n\n        if (param.extra && param.extra.parenthesized) {\n          this.unexpected(param.extra.parenStart);\n        }\n      }\n\n      this.parseArrowExpression(arrowNode, exprList);\n      this.state.yieldInPossibleArrowParameters = oldYield;\n      return arrowNode;\n    }\n\n    this.state.yieldInPossibleArrowParameters = oldYield;\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n\n    if (refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.toReferencedList(val.expressions);\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    this.addExtra(val, \"parenthesized\", true);\n    this.addExtra(val, \"parenStart\", startPos);\n    return val;\n  };\n\n  _proto.shouldParseArrow = function shouldParseArrow() {\n    return !this.canInsertSemicolon();\n  };\n\n  _proto.parseArrow = function parseArrow(node) {\n    if (this.eat(types.arrow)) {\n      return node;\n    }\n  };\n\n  _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {\n    return node;\n  };\n\n  _proto.parseNew = function parseNew() {\n    var node = this.startNode();\n    var meta = this.parseIdentifier(true);\n\n    if (this.eat(types.dot)) {\n      var metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.state.inFunction && !this.state.inClassProperty) {\n        var error = \"new.target can only be used in functions\";\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        this.raise(metaProp.start, error);\n      }\n\n      return metaProp;\n    }\n\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"OptionalMemberExpression\" || node.callee.type === \"OptionalCallExpression\") {\n      this.raise(this.state.lastTokEnd, \"constructors in/after an Optional Chain are not allowed\");\n    }\n\n    if (this.eat(types.questionDot)) {\n      this.raise(this.state.start, \"constructors in/after an Optional Chain are not allowed\");\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  };\n\n  _proto.parseNewArguments = function parseNewArguments(node) {\n    if (this.eat(types.parenL)) {\n      var args = this.parseExprList(types.parenR);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  };\n\n  _proto.parseTemplateElement = function parseTemplateElement(isTagged) {\n    var elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.invalidTemplateEscapePosition || 0, \"Invalid escape sequence in template\");\n      } else {\n        this.state.invalidTemplateEscapePosition = null;\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(types.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  };\n\n  _proto.parseTemplate = function parseTemplate(isTagged) {\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  };\n\n  _proto.parseObj = function parseObj(isPattern, refShorthandDefaultPos) {\n    var decorators = [];\n    var propHash = Object.create(null);\n    var first = true;\n    var node = this.startNode();\n    node.properties = [];\n    this.next();\n    var firstRestLocation = null;\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      if (this.match(types.at)) {\n        if (this.hasPlugin(\"decorators2\")) {\n          this.raise(this.state.start, \"Stage 2 decorators disallow object literal property decorators\");\n        } else {\n          while (this.match(types.at)) {\n            decorators.push(this.parseDecorator());\n          }\n        }\n      }\n\n      var prop = this.startNode(),\n          isGenerator = false,\n          _isAsync = false,\n          startPos = void 0,\n          startLoc = void 0;\n\n      if (decorators.length) {\n        prop.decorators = decorators;\n        decorators = [];\n      }\n\n      if (this.match(types.ellipsis)) {\n        this.expectPlugin(\"objectRestSpread\");\n        prop = this.parseSpread(isPattern ? {\n          start: 0\n        } : undefined);\n\n        if (isPattern) {\n          this.toAssignable(prop, true, \"object pattern\");\n        }\n\n        node.properties.push(prop);\n\n        if (isPattern) {\n          var position = this.state.start;\n\n          if (firstRestLocation !== null) {\n            this.unexpected(firstRestLocation, \"Cannot have multiple rest elements when destructuring\");\n          } else if (this.eat(types.braceR)) {\n            break;\n          } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {\n            this.unexpected(position, \"A trailing comma is not permitted after the rest element\");\n          } else {\n            firstRestLocation = position;\n            continue;\n          }\n        } else {\n          continue;\n        }\n      }\n\n      prop.method = false;\n\n      if (isPattern || refShorthandDefaultPos) {\n        startPos = this.state.start;\n        startLoc = this.state.startLoc;\n      }\n\n      if (!isPattern) {\n        isGenerator = this.eat(types.star);\n      }\n\n      var containsEsc = this.state.containsEsc;\n\n      if (!isPattern && this.isContextual(\"async\")) {\n        if (isGenerator) this.unexpected();\n        var asyncId = this.parseIdentifier();\n\n        if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {\n          prop.key = asyncId;\n          prop.computed = false;\n        } else {\n          _isAsync = true;\n\n          if (this.match(types.star)) {\n            this.expectPlugin(\"asyncGenerators\");\n            this.next();\n            isGenerator = true;\n          }\n\n          this.parsePropertyName(prop);\n        }\n      } else {\n        this.parsePropertyName(prop);\n      }\n\n      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, _isAsync, isPattern, refShorthandDefaultPos, containsEsc);\n      this.checkPropClash(prop, propHash);\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    if (firstRestLocation !== null) {\n      this.unexpected(firstRestLocation, \"The rest element has to be the last element when destructuring\");\n    }\n\n    if (decorators.length) {\n      this.raise(this.state.start, \"You have trailing decorators with no property\");\n    }\n\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n  };\n\n  _proto.isGetterOrSetterMethod = function isGetterOrSetterMethod(prop, isPattern) {\n    return !isPattern && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);\n  };\n\n  _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {\n    var paramCount = method.kind === \"get\" ? 0 : 1;\n    var start = method.start;\n\n    if (method.params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, \"getter must not have any formal parameters\");\n      } else {\n        this.raise(start, \"setter must have exactly one formal parameter\");\n      }\n    }\n\n    if (method.kind === \"set\" && method.params[0].type === \"RestElement\") {\n      this.raise(start, \"setter function argument must not be a rest parameter\");\n    }\n  };\n\n  _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {\n    if (isAsync || isGenerator || this.match(types.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, \"ObjectMethod\");\n    }\n\n    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {\n      if (isGenerator || isAsync) this.unexpected();\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      this.parseMethod(prop, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n  };\n\n  _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {\n    prop.shorthand = false;\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, true);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else if (this.match(types.eq) && refShorthandDefaultPos) {\n        if (!refShorthandDefaultPos.start) {\n          refShorthandDefaultPos.start = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else {\n        prop.value = prop.key.__clone();\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  };\n\n  _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {\n    var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);\n    if (!node) this.unexpected();\n    return node;\n  };\n\n  _proto.parsePropertyName = function parsePropertyName(prop) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n    } else {\n      var oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseMaybePrivateName();\n\n      if (prop.key.type !== \"PrivateName\") {\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  };\n\n  _proto.initFunction = function initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  };\n\n  _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, type) {\n    var oldInFunc = this.state.inFunction;\n    var oldInMethod = this.state.inMethod;\n    var oldInGenerator = this.state.inGenerator;\n    this.state.inFunction = true;\n    this.state.inMethod = node.kind || true;\n    this.state.inGenerator = isGenerator;\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    var allowModifiers = isConstructor;\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type);\n    this.state.inFunction = oldInFunc;\n    this.state.inMethod = oldInMethod;\n    this.state.inGenerator = oldInGenerator;\n    return node;\n  };\n\n  _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync) {\n    if (this.state.yieldInPossibleArrowParameters) {\n      this.raise(this.state.yieldInPossibleArrowParameters.start, \"yield is not allowed in the parameters of an arrow function\" + \" inside a generator\");\n    }\n\n    var oldInFunc = this.state.inFunction;\n    this.state.inFunction = true;\n    this.initFunction(node, isAsync);\n    if (params) this.setArrowFunctionParameters(node, params);\n    var oldInGenerator = this.state.inGenerator;\n    var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.inGenerator = false;\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.state.inGenerator = oldInGenerator;\n    this.state.inFunction = oldInFunc;\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  };\n\n  _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {\n    node.params = this.toAssignableList(params, true, \"arrow function parameters\");\n  };\n\n  _proto.isStrictBody = function isStrictBody(node) {\n    var isBlockStatement = node.body.type === \"BlockStatement\";\n\n    if (isBlockStatement && node.body.directives.length) {\n      for (var _i4 = 0, _node$body$directives2 = node.body.directives; _i4 < _node$body$directives2.length; _i4++) {\n        var directive = _node$body$directives2[_i4];\n\n        if (directive.value.value === \"use strict\") {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {\n    this.parseFunctionBody(node, allowExpressionBody);\n    this.finishNode(node, type);\n  };\n\n  _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression) {\n    var isExpression = allowExpression && !this.match(types.braceL);\n    var oldInParameters = this.state.inParameters;\n    var oldInAsync = this.state.inAsync;\n    this.state.inParameters = false;\n    this.state.inAsync = node.async;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n    } else {\n      var oldInGen = this.state.inGenerator;\n      var oldInFunc = this.state.inFunction;\n      var oldLabels = this.state.labels;\n      this.state.inGenerator = node.generator;\n      this.state.inFunction = true;\n      this.state.labels = [];\n      node.body = this.parseBlock(true);\n      this.state.inFunction = oldInFunc;\n      this.state.inGenerator = oldInGen;\n      this.state.labels = oldLabels;\n    }\n\n    this.state.inAsync = oldInAsync;\n    this.checkFunctionNameAndParams(node, allowExpression);\n    this.state.inParameters = oldInParameters;\n  };\n\n  _proto.checkFunctionNameAndParams = function checkFunctionNameAndParams(node, isArrowFunction) {\n    var isStrict = this.isStrictBody(node);\n    var checkLVal = this.state.strict || isStrict || isArrowFunction;\n    var oldStrict = this.state.strict;\n    if (isStrict) this.state.strict = isStrict;\n\n    if (checkLVal) {\n      var nameHash = Object.create(null);\n\n      if (node.id) {\n        this.checkLVal(node.id, true, undefined, \"function name\");\n      }\n\n      for (var _i6 = 0, _node$params2 = node.params; _i6 < _node$params2.length; _i6++) {\n        var param = _node$params2[_i6];\n\n        if (isStrict && param.type !== \"Identifier\") {\n          this.raise(param.start, \"Non-simple parameter in strict mode\");\n        }\n\n        this.checkLVal(param, true, nameHash, \"function parameter list\");\n      }\n    }\n\n    this.state.strict = oldStrict;\n  };\n\n  _proto.parseExprList = function parseExprList(close, allowEmpty, refShorthandDefaultPos) {\n    var elts = [];\n    var first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(close)) break;\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));\n    }\n\n    return elts;\n  };\n\n  _proto.parseExprListItem = function parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos, refTrailingCommaPos) {\n    var elt;\n\n    if (allowEmpty && this.match(types.comma)) {\n      elt = null;\n    } else if (this.match(types.ellipsis)) {\n      var spreadNodeStartPos = this.state.start;\n      var spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refShorthandDefaultPos, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);\n\n      if (refTrailingCommaPos && this.match(types.comma)) {\n        refTrailingCommaPos.start = this.state.start;\n      }\n    } else {\n      elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);\n    }\n\n    return elt;\n  };\n\n  _proto.parseIdentifier = function parseIdentifier(liberal) {\n    var node = this.startNode();\n    var name = this.parseIdentifierName(node.start, liberal);\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  };\n\n  _proto.parseIdentifierName = function parseIdentifierName(pos, liberal) {\n    if (!liberal) {\n      this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);\n    }\n\n    var name;\n\n    if (this.match(types.name)) {\n      name = this.state.value;\n    } else if (this.state.type.keyword) {\n      name = this.state.type.keyword;\n    } else {\n      throw this.unexpected();\n    }\n\n    if (!liberal && name === \"await\" && this.state.inAsync) {\n      this.raise(pos, \"invalid use of await inside of an async function\");\n    }\n\n    this.next();\n    return name;\n  };\n\n  _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {\n      this.raise(startLoc, word + \" is a reserved word in strict mode\");\n    }\n\n    if (this.state.inGenerator && word === \"yield\") {\n      this.raise(startLoc, \"yield is a reserved word inside generator functions\");\n    }\n\n    if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {\n      this.raise(startLoc, word + \" is a reserved word\");\n    }\n  };\n\n  _proto.parseAwait = function parseAwait(node) {\n    if (!this.state.inAsync) {\n      this.unexpected();\n    }\n\n    if (this.match(types.star)) {\n      this.raise(node.start, \"await* has been removed from the async functions proposal. Use Promise.all() instead.\");\n    }\n\n    node.argument = this.parseMaybeUnary();\n    return this.finishNode(node, \"AwaitExpression\");\n  };\n\n  _proto.parseYield = function parseYield() {\n    var node = this.startNode();\n\n    if (this.state.inParameters) {\n      this.raise(node.start, \"yield is not allowed in generator parameters\");\n    }\n\n    if (this.state.maybeInArrowParameters && !this.state.yieldInPossibleArrowParameters) {\n      this.state.yieldInPossibleArrowParameters = node;\n    }\n\n    this.next();\n\n    if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  };\n\n  return ExpressionParser;\n}(LValParser);\n\nvar empty = [];\nvar loopLabel = {\n  kind: \"loop\"\n};\nvar switchLabel = {\n  kind: \"switch\"\n};\n\nvar StatementParser = function (_ExpressionParser) {\n  _inheritsLoose(StatementParser, _ExpressionParser);\n\n  function StatementParser() {\n    return _ExpressionParser.apply(this, arguments) || this;\n  }\n\n  var _proto = StatementParser.prototype;\n\n  _proto.parseTopLevel = function parseTopLevel(file, program) {\n    program.sourceType = this.options.sourceType;\n    this.parseBlockBody(program, true, true, types.eof);\n    file.program = this.finishNode(program, \"Program\");\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = this.state.tokens;\n    return this.finishNode(file, \"File\");\n  };\n\n  _proto.stmtToDirective = function stmtToDirective(stmt) {\n    var expr = stmt.expression;\n    var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    var directive = this.startNodeAt(stmt.start, stmt.loc.start);\n    var raw = this.input.slice(expr.start, expr.end);\n    var val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  };\n\n  _proto.parseStatement = function parseStatement(declaration, topLevel) {\n    if (this.match(types.at)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(declaration, topLevel);\n  };\n\n  _proto.parseStatementContent = function parseStatementContent(declaration, topLevel) {\n    var starttype = this.state.type;\n    var node = this.startNode();\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (this.lookahead().type === types.dot) break;\n        if (!declaration) this.unexpected();\n        return this.parseFunctionStatement(node);\n\n      case types._class:\n        if (!declaration) this.unexpected();\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types._let:\n      case types._const:\n        if (!declaration) this.unexpected();\n\n      case types._var:\n        return this.parseVarStatement(node, starttype);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._export:\n      case types._import:\n        {\n          var nextToken = this.lookahead();\n\n          if (nextToken.type === types.parenL || nextToken.type === types.dot) {\n            break;\n          }\n\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, \"'import' and 'export' may only appear at the top level\");\n          }\n\n          this.next();\n          var result;\n\n          if (starttype == types._import) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      case types.name:\n        if (this.isContextual(\"async\")) {\n          var state = this.state.clone();\n          this.next();\n\n          if (this.match(types._function) && !this.canInsertSemicolon()) {\n            this.expect(types._function);\n            return this.parseFunction(node, true, false, true);\n          } else {\n            this.state = state;\n          }\n        }\n\n    }\n\n    var maybeName = this.state.value;\n    var expr = this.parseExpression();\n\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n      return this.parseLabeledStatement(node, maybeName, expr);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  };\n\n  _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(node.start, \"'import' and 'export' may appear only with 'sourceType: \\\"module\\\"'\", {\n        code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n      });\n    }\n  };\n\n  _proto.takeDecorators = function takeDecorators(node) {\n    var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  };\n\n  _proto.parseDecorators = function parseDecorators(allowExport) {\n    if (this.hasPlugin(\"decorators2\")) {\n      allowExport = false;\n    }\n\n    var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(types.at)) {\n      var decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(types._export)) {\n      if (allowExport) {\n        return;\n      } else {\n        this.raise(this.state.start, \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead\");\n      }\n    }\n\n    if (!this.match(types._class)) {\n      this.raise(this.state.start, \"Leading decorators must be attached to a class declaration\");\n    }\n  };\n\n  _proto.parseDecorator = function parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators2\"]);\n    var node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators2\")) {\n      var startPos = this.state.start;\n      var startLoc = this.state.startLoc;\n      var expr = this.parseIdentifier(false);\n\n      while (this.eat(types.dot)) {\n        var _node = this.startNodeAt(startPos, startLoc);\n\n        _node.object = expr;\n        _node.property = this.parseIdentifier(true);\n        _node.computed = false;\n        expr = this.finishNode(_node, \"MemberExpression\");\n      }\n\n      if (this.eat(types.parenL)) {\n        var _node2 = this.startNodeAt(startPos, startLoc);\n\n        _node2.callee = expr;\n        this.state.decoratorStack.push([]);\n        _node2.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        this.state.decoratorStack.pop();\n        expr = this.finishNode(_node2, \"CallExpression\");\n        this.toReferencedList(expr.arguments);\n      }\n\n      node.expression = expr;\n    } else {\n      node.expression = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  };\n\n  _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else if (!this.match(types.name)) {\n      this.unexpected();\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    var i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      var lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, \"Unsyntactic \" + keyword);\n    }\n\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  };\n\n  _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  };\n\n  _proto.parseDoStatement = function parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.state.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseParenExpression();\n    this.eat(types.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  };\n\n  _proto.parseForStatement = function parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    var forAwait = false;\n\n    if (this.state.inAsync && this.isContextual(\"await\")) {\n      this.expectPlugin(\"asyncGenerators\");\n      forAwait = true;\n      this.next();\n    }\n\n    this.expect(types.parenL);\n\n    if (this.match(types.semi)) {\n      if (forAwait) {\n        this.unexpected();\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {\n      var _init = this.startNode();\n\n      var varKind = this.state.type;\n      this.next();\n      this.parseVar(_init, true, varKind);\n      this.finishNode(_init, \"VariableDeclaration\");\n\n      if (this.match(types._in) || this.isContextual(\"of\")) {\n        if (_init.declarations.length === 1) {\n          var declaration = _init.declarations[0];\n          var isForInInitializer = varKind === types._var && declaration.init && declaration.id.type != \"ObjectPattern\" && declaration.id.type != \"ArrayPattern\" && !this.isContextual(\"of\");\n\n          if (this.state.strict && isForInInitializer) {\n            this.raise(this.state.start, \"for-in initializer in strict mode\");\n          } else if (isForInInitializer || !declaration.init) {\n            return this.parseForIn(node, _init, forAwait);\n          }\n        }\n      }\n\n      if (forAwait) {\n        this.unexpected();\n      }\n\n      return this.parseFor(node, _init);\n    }\n\n    var refShorthandDefaultPos = {\n      start: 0\n    };\n    var init = this.parseExpression(true, refShorthandDefaultPos);\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      var description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n      this.toAssignable(init, undefined, description);\n      this.checkLVal(init, undefined, undefined, description);\n      return this.parseForIn(node, init, forAwait);\n    } else if (refShorthandDefaultPos.start) {\n      this.unexpected(refShorthandDefaultPos.start);\n    }\n\n    if (forAwait) {\n      this.unexpected();\n    }\n\n    return this.parseFor(node, init);\n  };\n\n  _proto.parseFunctionStatement = function parseFunctionStatement(node) {\n    this.next();\n    return this.parseFunction(node, true);\n  };\n\n  _proto.parseIfStatement = function parseIfStatement(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    node.consequent = this.parseStatement(false);\n    node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;\n    return this.finishNode(node, \"IfStatement\");\n  };\n\n  _proto.parseReturnStatement = function parseReturnStatement(node) {\n    if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, \"'return' outside of function\");\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  };\n\n  _proto.parseSwitchStatement = function parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    var cases = node.cases = [];\n    this.expect(types.braceL);\n    this.state.labels.push(switchLabel);\n    var cur;\n\n    for (var sawDefault; !this.match(types.braceR);) {\n      if (this.match(types._case) || this.match(types._default)) {\n        var isCase = this.match(types._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, \"Multiple default clauses\");\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(types.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(true));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  };\n\n  _proto.parseThrowStatement = function parseThrowStatement(node) {\n    this.next();\n\n    if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {\n      this.raise(this.state.lastTokEnd, \"Illegal newline after throw\");\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  };\n\n  _proto.parseTryStatement = function parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(types._catch)) {\n      var clause = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseBindingAtom();\n        var clashes = Object.create(null);\n        this.checkLVal(clause.param, true, clashes, \"catch clause\");\n        this.expect(types.parenR);\n      } else {\n        this.expectPlugin(\"optionalCatchBinding\");\n        clause.param = null;\n      }\n\n      clause.body = this.parseBlock();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.guardedHandlers = empty;\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, \"Missing catch or finally clause\");\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  };\n\n  _proto.parseVarStatement = function parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  };\n\n  _proto.parseWhileStatement = function parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.parseStatement(false);\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  };\n\n  _proto.parseWithStatement = function parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, \"'with' in strict mode\");\n    }\n\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(false);\n    return this.finishNode(node, \"WithStatement\");\n  };\n\n  _proto.parseEmptyStatement = function parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  };\n\n  _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr) {\n    for (var _i2 = 0, _state$labels2 = this.state.labels; _i2 < _state$labels2.length; _i2++) {\n      var label = _state$labels2[_i2];\n\n      if (label.name === maybeName) {\n        this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n      }\n    }\n\n    var kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n\n    for (var i = this.state.labels.length - 1; i >= 0; i--) {\n      var _label = this.state.labels[i];\n\n      if (_label.statementStart === node.start) {\n        _label.statementStart = this.state.start;\n        _label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(true);\n\n    if (node.body.type == \"ClassDeclaration\" || node.body.type == \"VariableDeclaration\" && node.body.kind !== \"var\" || node.body.type == \"FunctionDeclaration\" && (this.state.strict || node.body.generator || node.body.async)) {\n      this.raise(node.body.start, \"Invalid labeled declaration\");\n    }\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  };\n\n  _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  };\n\n  _proto.parseBlock = function parseBlock(allowDirectives) {\n    var node = this.startNode();\n    this.expect(types.braceL);\n    this.parseBlockBody(node, allowDirectives, false, types.braceR);\n    return this.finishNode(node, \"BlockStatement\");\n  };\n\n  _proto.isValidDirective = function isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  };\n\n  _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end) {\n    var body = node.body = [];\n    var directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end);\n  };\n\n  _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end) {\n    var parsedNonDirective = false;\n    var oldStrict;\n    var octalPosition;\n\n    while (!this.eat(end)) {\n      if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {\n        octalPosition = this.state.octalPosition;\n      }\n\n      var stmt = this.parseStatement(true, topLevel);\n\n      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {\n        var directive = this.stmtToDirective(stmt);\n        directives.push(directive);\n\n        if (oldStrict === undefined && directive.value.value === \"use strict\") {\n          oldStrict = this.state.strict;\n          this.setStrict(true);\n\n          if (octalPosition) {\n            this.raise(octalPosition, \"Octal literal in strict mode\");\n          }\n        }\n\n        continue;\n      }\n\n      parsedNonDirective = true;\n      body.push(stmt);\n    }\n\n    if (oldStrict === false) {\n      this.setStrict(false);\n    }\n  };\n\n  _proto.parseFor = function parseFor(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.match(types.semi) ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.match(types.parenR) ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(false);\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  };\n\n  _proto.parseForIn = function parseForIn(node, init, forAwait) {\n    var type = this.match(types._in) ? \"ForInStatement\" : \"ForOfStatement\";\n\n    if (forAwait) {\n      this.eatContextual(\"of\");\n    } else {\n      this.next();\n    }\n\n    if (type === \"ForOfStatement\") {\n      node.await = !!forAwait;\n    }\n\n    node.left = init;\n    node.right = this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(false);\n    this.state.labels.pop();\n    return this.finishNode(node, type);\n  };\n\n  _proto.parseVar = function parseVar(node, isFor, kind) {\n    var declarations = node.declarations = [];\n    node.kind = kind.keyword;\n\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarHead(decl);\n\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else {\n        if (kind === types._const && !(this.match(types._in) || this.isContextual(\"of\"))) {\n          if (!this.hasPlugin(\"typescript\")) {\n            this.unexpected();\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n          this.raise(this.state.lastTokEnd, \"Complex binding patterns require an initialization value\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) break;\n    }\n\n    return node;\n  };\n\n  _proto.parseVarHead = function parseVarHead(decl) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, true, undefined, \"variable declaration\");\n  };\n\n  _proto.parseFunction = function parseFunction(node, isStatement, allowExpressionBody, isAsync, optionalId) {\n    var oldInFunc = this.state.inFunction;\n    var oldInMethod = this.state.inMethod;\n    var oldInGenerator = this.state.inGenerator;\n    this.state.inFunction = true;\n    this.state.inMethod = false;\n    this.initFunction(node, isAsync);\n\n    if (this.match(types.star)) {\n      if (node.async) {\n        this.expectPlugin(\"asyncGenerators\");\n      }\n\n      node.generator = true;\n      this.next();\n    }\n\n    if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {\n      this.unexpected();\n    }\n\n    if (!isStatement) this.state.inGenerator = node.generator;\n\n    if (this.match(types.name) || this.match(types._yield)) {\n      node.id = this.parseBindingIdentifier();\n    }\n\n    if (isStatement) this.state.inGenerator = node.generator;\n    this.parseFunctionParams(node);\n    this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\", allowExpressionBody);\n    this.state.inFunction = oldInFunc;\n    this.state.inMethod = oldInMethod;\n    this.state.inGenerator = oldInGenerator;\n    return node;\n  };\n\n  _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {\n    var oldInParameters = this.state.inParameters;\n    this.state.inParameters = true;\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, allowModifiers);\n    this.state.inParameters = oldInParameters;\n  };\n\n  _proto.parseClass = function parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    this.parseClassBody(node);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  };\n\n  _proto.isClassProperty = function isClassProperty() {\n    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n  };\n\n  _proto.isClassMethod = function isClassMethod() {\n    return this.match(types.parenL);\n  };\n\n  _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  };\n\n  _proto.parseClassBody = function parseClassBody(node) {\n    var oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.state.classLevel++;\n    var state = {\n      hadConstructor: false\n    };\n    var decorators = [];\n    var classBody = this.startNode();\n    classBody.body = [];\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (this.eat(types.semi)) {\n        if (decorators.length > 0) {\n          this.raise(this.state.lastTokEnd, \"Decorators must not be followed by a semicolon\");\n        }\n\n        continue;\n      }\n\n      if (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n        continue;\n      }\n\n      var member = this.startNode();\n\n      if (decorators.length) {\n        member.decorators = decorators;\n        this.resetStartLocationFromNode(member, decorators[0]);\n        decorators = [];\n      }\n\n      this.parseClassMember(classBody, member, state);\n\n      if (this.hasPlugin(\"decorators2\") && [\"method\", \"get\", \"set\"].indexOf(member.kind) === -1 && member.decorators && member.decorators.length > 0) {\n        this.raise(member.start, \"Stage 2 decorators may only be used with a class or a class method\");\n      }\n    }\n\n    if (decorators.length) {\n      this.raise(this.state.start, \"You have trailing decorators with no method\");\n    }\n\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.state.classLevel--;\n    this.state.strict = oldStrict;\n  };\n\n  _proto.parseClassMember = function parseClassMember(classBody, member, state) {\n    var isStatic = false;\n    var containsEsc = this.state.containsEsc;\n\n    if (this.match(types.name) && this.state.value === \"static\") {\n      var key = this.parseIdentifier(true);\n\n      if (this.isClassMethod()) {\n        var method = member;\n        method.kind = \"method\";\n        method.computed = false;\n        method.key = key;\n        method.static = false;\n        this.pushClassMethod(classBody, method, false, false, false);\n        return;\n      } else if (this.isClassProperty()) {\n        var prop = member;\n        prop.computed = false;\n        prop.key = key;\n        prop.static = false;\n        classBody.body.push(this.parseClassProperty(prop));\n        return;\n      } else if (containsEsc) {\n        throw this.unexpected();\n      }\n\n      isStatic = true;\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  };\n\n  _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    var publicMethod = member;\n    var privateMethod = member;\n    var publicProp = member;\n    var privateProp = member;\n    var method = publicMethod;\n    var publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(types.star)) {\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, \"Constructor can't be a generator\");\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false);\n      return;\n    }\n\n    var key = this.parseClassPropertyName(member);\n    var isPrivate = key.type === \"PrivateName\";\n    var isSimple = key.type === \"Identifier\";\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      var isConstructor = this.isNonstaticConstructor(publicMethod);\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (publicMethod.decorators) {\n          this.raise(publicMethod.start, \"You can't attach decorators to a class constructor\");\n        }\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, \"Duplicate constructor in the same class\");\n        }\n\n        state.hadConstructor = true;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isSimple && key.name === \"async\" && !this.isLineTerminator()) {\n      var isGenerator = this.match(types.star);\n\n      if (isGenerator) {\n        this.expectPlugin(\"asyncGenerators\");\n        this.next();\n      }\n\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, \"Constructor can't be an async function\");\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false);\n      }\n    } else if (isSimple && (key.name === \"get\" || key.name === \"set\") && !(this.isLineTerminator() && this.match(types.star))) {\n      method.kind = key.name;\n      this.parseClassPropertyName(publicMethod);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, \"Constructor can't have get/set modifier\");\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.parseClassPropertyName = function parseClassPropertyName(member) {\n    var key = this.parsePropertyName(member);\n\n    if (!member.computed && member.static && (key.name === \"prototype\" || key.value === \"prototype\")) {\n      this.raise(key.start, \"Classes may not have static property named prototype\");\n    }\n\n    if (key.type === \"PrivateName\" && key.id.name === \"constructor\") {\n      this.raise(key.start, \"Classes may not have a private field named '#constructor'\");\n    }\n\n    return key;\n  };\n\n  _proto.pushClassProperty = function pushClassProperty(classBody, prop) {\n    if (this.isNonstaticConstructor(prop)) {\n      this.raise(prop.key.start, \"Classes may not have a non-static field named 'constructor'\");\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  };\n\n  _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n    classBody.body.push(this.parseClassPrivateProperty(prop));\n  };\n\n  _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, \"ClassMethod\"));\n  };\n\n  _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, false, \"ClassPrivateMethod\"));\n  };\n\n  _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {};\n\n  _proto.parseAccessModifier = function parseAccessModifier() {\n    return undefined;\n  };\n\n  _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {\n    this.state.inClassProperty = true;\n    node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;\n    this.semicolon();\n    this.state.inClassProperty = false;\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  };\n\n  _proto.parseClassProperty = function parseClassProperty(node) {\n    if (!node.typeAnnotation) {\n      this.expectPlugin(\"classProperties\");\n    }\n\n    this.state.inClassProperty = true;\n\n    if (this.match(types.eq)) {\n      this.expectPlugin(\"classProperties\");\n      this.next();\n      node.value = this.parseMaybeAssign();\n    } else {\n      node.value = null;\n    }\n\n    this.semicolon();\n    this.state.inClassProperty = false;\n    return this.finishNode(node, \"ClassProperty\");\n  };\n\n  _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {\n    if (this.match(types.name)) {\n      node.id = this.parseIdentifier();\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    }\n  };\n\n  _proto.parseClassSuper = function parseClassSuper(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  };\n\n  _proto.parseExport = function parseExport(node) {\n    if (this.shouldParseExportStar()) {\n      this.parseExportStar(node);\n      if (node.type === \"ExportAllDeclaration\") return node;\n    } else if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      var specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      var specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      node.specifiers = specifiers;\n\n      if (this.match(types.comma) && this.lookahead().type === types.star) {\n        this.expect(types.comma);\n\n        var _specifier = this.startNode();\n\n        this.expect(types.star);\n        this.expectContextual(\"as\");\n        _specifier.exported = this.parseIdentifier();\n        specifiers.push(this.finishNode(_specifier, \"ExportNamespaceSpecifier\"));\n      } else {\n        this.parseExportSpecifiersMaybe(node);\n      }\n\n      this.parseExportFrom(node, true);\n    } else if (this.eat(types._default)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    } else if (this.shouldParseExportDeclaration()) {\n      if (this.isContextual(\"async\")) {\n        var next = this.lookahead();\n\n        if (next.type !== types._function) {\n          this.unexpected(next.start, \"Unexpected token, expected \\\"function\\\"\");\n        }\n      }\n\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n    } else {\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers();\n      this.parseExportFrom(node);\n    }\n\n    this.checkExport(node, true);\n    return this.finishNode(node, \"ExportNamedDeclaration\");\n  };\n\n  _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {\n    var expr = this.startNode();\n\n    if (this.eat(types._function)) {\n      return this.parseFunction(expr, true, false, false, true);\n    } else if (this.isContextual(\"async\") && this.lookahead().type === types._function) {\n      this.eatContextual(\"async\");\n      this.eat(types._function);\n      return this.parseFunction(expr, true, false, true, true);\n    } else if (this.match(types._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types.at)) {\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else {\n      var res = this.parseMaybeAssign();\n      this.semicolon();\n      return res;\n    }\n  };\n\n  _proto.parseExportDeclaration = function parseExportDeclaration(node) {\n    return this.parseStatement(true);\n  };\n\n  _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {\n    if (this.match(types.name)) {\n      return this.state.value !== \"async\";\n    }\n\n    if (!this.match(types._default)) {\n      return false;\n    }\n\n    var lookahead = this.lookahead();\n    return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === \"from\";\n  };\n\n  _proto.parseExportSpecifiersMaybe = function parseExportSpecifiersMaybe(node) {\n    if (this.eat(types.comma)) {\n      node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());\n    }\n  };\n\n  _proto.parseExportFrom = function parseExportFrom(node, expect) {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();\n      this.checkExport(node);\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  };\n\n  _proto.shouldParseExportStar = function shouldParseExportStar() {\n    return this.match(types.star);\n  };\n\n  _proto.parseExportStar = function parseExportStar(node) {\n    this.expect(types.star);\n\n    if (this.isContextual(\"as\")) {\n      this.parseExportNamespace(node);\n    } else {\n      this.parseExportFrom(node, true);\n      this.finishNode(node, \"ExportAllDeclaration\");\n    }\n  };\n\n  _proto.parseExportNamespace = function parseExportNamespace(node) {\n    this.expectPlugin(\"exportNamespaceFrom\");\n    var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n    this.next();\n    specifier.exported = this.parseIdentifier(true);\n    node.specifiers = [this.finishNode(specifier, \"ExportNamespaceSpecifier\")];\n    this.parseExportSpecifiersMaybe(node);\n    this.parseExportFrom(node, true);\n  };\n\n  _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {\n    return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"let\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isContextual(\"async\") || this.match(types.at) && this.expectPlugin(\"decorators2\");\n  };\n\n  _proto.checkExport = function checkExport(node, checkNames, isDefault) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n      } else if (node.specifiers && node.specifiers.length) {\n        for (var _i4 = 0, _node$specifiers2 = node.specifiers; _i4 < _node$specifiers2.length; _i4++) {\n          var specifier = _node$specifiers2[_i4];\n          this.checkDuplicateExports(specifier, specifier.exported.name);\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          var id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (var _i6 = 0, _node$declaration$dec2 = node.declaration.declarations; _i6 < _node$declaration$dec2.length; _i6++) {\n            var declaration = _node$declaration$dec2[_i6];\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      var isClass = node.declaration && (node.declaration.type === \"ClassDeclaration\" || node.declaration.type === \"ClassExpression\");\n\n      if (!node.declaration || !isClass) {\n        throw this.raise(node.start, \"You can only use decorators on an export when exporting a class\");\n      }\n\n      this.takeDecorators(node.declaration);\n    }\n  };\n\n  _proto.checkDeclaration = function checkDeclaration(node) {\n    if (node.type === \"ObjectPattern\") {\n      for (var _i8 = 0, _node$properties2 = node.properties; _i8 < _node$properties2.length; _i8++) {\n        var prop = _node$properties2[_i8];\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (var _i10 = 0, _node$elements2 = node.elements; _i10 < _node$elements2.length; _i10++) {\n        var elem = _node$elements2[_i10];\n\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    }\n  };\n\n  _proto.checkDuplicateExports = function checkDuplicateExports(node, name) {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raiseDuplicateExportError(node, name);\n    }\n\n    this.state.exportedIdentifiers.push(name);\n  };\n\n  _proto.raiseDuplicateExportError = function raiseDuplicateExportError(node, name) {\n    throw this.raise(node.start, name === \"default\" ? \"Only one default export allowed per module.\" : \"`\" + name + \"` has already been exported. Exported identifiers must be unique.\");\n  };\n\n  _proto.parseExportSpecifiers = function parseExportSpecifiers() {\n    var nodes = [];\n    var first = true;\n    var needsFrom;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      var isDefault = this.match(types._default);\n      if (isDefault && !needsFrom) needsFrom = true;\n      var node = this.startNode();\n      node.local = this.parseIdentifier(isDefault);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdentifier(true) : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    if (needsFrom && !this.isContextual(\"from\")) {\n      this.unexpected();\n    }\n\n    return nodes;\n  };\n\n  _proto.parseImport = function parseImport(node) {\n    if (this.match(types.string)) {\n      node.specifiers = [];\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = [];\n      this.parseImportSpecifiers(node);\n      this.expectContextual(\"from\");\n      node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  };\n\n  _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {\n    return this.match(types.name);\n  };\n\n  _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, true, undefined, contextDescription);\n    node.specifiers.push(this.finishNode(specifier, type));\n  };\n\n  _proto.parseImportSpecifiers = function parseImportSpecifiers(node) {\n    var first = true;\n\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      if (!this.eat(types.comma)) return;\n    }\n\n    if (this.match(types.star)) {\n      var specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return;\n    }\n\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(types.colon)) {\n          this.unexpected(null, \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\");\n        }\n\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  };\n\n  _proto.parseImportSpecifier = function parseImportSpecifier(node) {\n    var specifier = this.startNode();\n    specifier.imported = this.parseIdentifier(true);\n\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      this.checkReservedWord(specifier.imported.name, specifier.start, true, true);\n      specifier.local = specifier.imported.__clone();\n    }\n\n    this.checkLVal(specifier.local, true, undefined, \"import specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  };\n\n  return StatementParser;\n}(ExpressionParser);\n\nvar plugins = {};\n\nvar Parser = function (_StatementParser) {\n  _inheritsLoose(Parser, _StatementParser);\n\n  function Parser(options, input) {\n    var _this;\n\n    options = getOptions(options);\n    _this = _StatementParser.call(this, options, input) || this;\n    _this.options = options;\n    _this.inModule = _this.options.sourceType === \"module\";\n    _this.input = input;\n    _this.plugins = pluginsMap(_this.options.plugins);\n    _this.filename = options.sourceFilename;\n\n    if (_this.state.pos === 0 && _this.input[0] === \"#\" && _this.input[1] === \"!\") {\n      _this.skipLineComment(2);\n    }\n\n    return _this;\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto.parse = function parse() {\n    var file = this.startNode();\n    var program = this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(file, program);\n  };\n\n  return Parser;\n}(StatementParser);\n\nfunction pluginsMap(pluginList) {\n  var pluginMap = {};\n\n  for (var _i2 = 0; _i2 < pluginList.length; _i2++) {\n    var _name = pluginList[_i2];\n    pluginMap[_name] = true;\n  }\n\n  return pluginMap;\n}\n\nfunction isSimpleProperty(node) {\n  return node != null && node.type === \"Property\" && node.kind === \"init\" && node.method === false;\n}\n\nvar estreePlugin = (function (superClass) {\n  return function (_superClass) {\n    _inheritsLoose(_class, _superClass);\n\n    function _class() {\n      return _superClass.apply(this, arguments) || this;\n    }\n\n    var _proto = _class.prototype;\n\n    _proto.estreeParseRegExpLiteral = function estreeParseRegExpLiteral(_ref) {\n      var pattern = _ref.pattern,\n          flags = _ref.flags;\n      var regex = null;\n\n      try {\n        regex = new RegExp(pattern, flags);\n      } catch (e) {}\n\n      var node = this.estreeParseLiteral(regex);\n      node.regex = {\n        pattern: pattern,\n        flags: flags\n      };\n      return node;\n    };\n\n    _proto.estreeParseLiteral = function estreeParseLiteral(value) {\n      return this.parseLiteral(value, \"Literal\");\n    };\n\n    _proto.directiveToStmt = function directiveToStmt(directive) {\n      var directiveLiteral = directive.value;\n      var stmt = this.startNodeAt(directive.start, directive.loc.start);\n      var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n      expression.value = directiveLiteral.value;\n      expression.raw = directiveLiteral.extra.raw;\n      stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n      return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n    };\n\n    _proto.initFunction = function initFunction(node, isAsync) {\n      _superClass.prototype.initFunction.call(this, node, isAsync);\n\n      node.expression = false;\n    };\n\n    _proto.checkDeclaration = function checkDeclaration(node) {\n      if (isSimpleProperty(node)) {\n        this.checkDeclaration(node.value);\n      } else {\n        _superClass.prototype.checkDeclaration.call(this, node);\n      }\n    };\n\n    _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {\n      var prop = method;\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      var start = prop.start;\n\n      if (prop.value.params.length !== paramCount) {\n        if (prop.kind === \"get\") {\n          this.raise(start, \"getter must not have any formal parameters\");\n        } else {\n          this.raise(start, \"setter must have exactly one formal parameter\");\n        }\n      }\n\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n        this.raise(start, \"setter function argument must not be a rest parameter\");\n      }\n    };\n\n    _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {\n      var _this = this;\n\n      switch (expr.type) {\n        case \"ObjectPattern\":\n          expr.properties.forEach(function (prop) {\n            _this.checkLVal(prop.type === \"Property\" ? prop.value : prop, isBinding, checkClashes, \"object destructuring pattern\");\n          });\n          break;\n\n        default:\n          _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);\n\n      }\n    };\n\n    _proto.checkPropClash = function checkPropClash(prop, propHash) {\n      if (prop.computed || !isSimpleProperty(prop)) return;\n      var key = prop.key;\n      var name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n      if (name === \"__proto__\") {\n        if (propHash.proto) {\n          this.raise(key.start, \"Redefinition of __proto__ property\");\n        }\n\n        propHash.proto = true;\n      }\n    };\n\n    _proto.isStrictBody = function isStrictBody(node) {\n      var isBlockStatement = node.body.type === \"BlockStatement\";\n\n      if (isBlockStatement && node.body.body.length > 0) {\n        for (var _i2 = 0, _node$body$body2 = node.body.body; _i2 < _node$body$body2.length; _i2++) {\n          var directive = _node$body$body2[_i2];\n\n          if (directive.type === \"ExpressionStatement\" && directive.expression.type === \"Literal\") {\n            if (directive.expression.value === \"use strict\") return true;\n          } else {\n            break;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    _proto.isValidDirective = function isValidDirective(stmt) {\n      return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);\n    };\n\n    _proto.stmtToDirective = function stmtToDirective(stmt) {\n      var directive = _superClass.prototype.stmtToDirective.call(this, stmt);\n\n      var value = stmt.expression.value;\n      directive.value.value = value;\n      return directive;\n    };\n\n    _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end) {\n      var _this2 = this;\n\n      _superClass.prototype.parseBlockBody.call(this, node, allowDirectives, topLevel, end);\n\n      var directiveStatements = node.directives.map(function (d) {\n        return _this2.directiveToStmt(d);\n      });\n      node.body = directiveStatements.concat(node.body);\n      delete node.directives;\n    };\n\n    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {\n      this.parseMethod(method, isGenerator, isAsync, isConstructor, \"MethodDefinition\");\n\n      if (method.typeParameters) {\n        method.value.typeParameters = method.typeParameters;\n        delete method.typeParameters;\n      }\n\n      classBody.body.push(method);\n    };\n\n    _proto.parseExprAtom = function parseExprAtom(refShorthandDefaultPos) {\n      switch (this.state.type) {\n        case types.regexp:\n          return this.estreeParseRegExpLiteral(this.state.value);\n\n        case types.num:\n        case types.string:\n          return this.estreeParseLiteral(this.state.value);\n\n        case types._null:\n          return this.estreeParseLiteral(null);\n\n        case types._true:\n          return this.estreeParseLiteral(true);\n\n        case types._false:\n          return this.estreeParseLiteral(false);\n\n        default:\n          return _superClass.prototype.parseExprAtom.call(this, refShorthandDefaultPos);\n      }\n    };\n\n    _proto.parseLiteral = function parseLiteral(value, type, startPos, startLoc) {\n      var node = _superClass.prototype.parseLiteral.call(this, value, type, startPos, startLoc);\n\n      node.raw = node.extra.raw;\n      delete node.extra;\n      return node;\n    };\n\n    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression) {\n      _superClass.prototype.parseFunctionBody.call(this, node, allowExpression);\n\n      node.expression = node.body.type !== \"BlockStatement\";\n    };\n\n    _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, type) {\n      var funcNode = this.startNode();\n      funcNode.kind = node.kind;\n      funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, \"FunctionExpression\");\n      delete funcNode.kind;\n      node.value = funcNode;\n      return this.finishNode(node, type);\n    };\n\n    _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {\n      var node = _superClass.prototype.parseObjectMethod.call(this, prop, isGenerator, isAsync, isPattern, containsEsc);\n\n      if (node) {\n        node.type = \"Property\";\n        if (node.kind === \"method\") node.kind = \"init\";\n        node.shorthand = false;\n      }\n\n      return node;\n    };\n\n    _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {\n      var node = _superClass.prototype.parseObjectProperty.call(this, prop, startPos, startLoc, isPattern, refShorthandDefaultPos);\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node;\n    };\n\n    _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {\n      if (isSimpleProperty(node)) {\n        this.toAssignable(node.value, isBinding, contextDescription);\n        return node;\n      }\n\n      return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);\n    };\n\n    _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isBinding, isLast) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        this.raise(prop.key.start, \"Object pattern can't contain getter or setter\");\n      } else if (prop.method) {\n        this.raise(prop.key.start, \"Object pattern can't contain methods\");\n      } else {\n        _superClass.prototype.toAssignableObjectExpressionProp.call(this, prop, isBinding, isLast);\n      }\n    };\n\n    return _class;\n  }(superClass);\n});\n\nvar primitiveTypes = [\"any\", \"bool\", \"boolean\", \"empty\", \"false\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"];\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state) {\n  return (state.type === types.name || !!state.type.keyword) && state.value !== \"from\";\n}\n\nvar exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  var list1 = [];\n  var list2 = [];\n\n  for (var i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nvar flowPlugin = (function (superClass) {\n  return function (_superClass) {\n    _inheritsLoose(_class, _superClass);\n\n    function _class() {\n      return _superClass.apply(this, arguments) || this;\n    }\n\n    var _proto = _class.prototype;\n\n    _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {\n      var oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || types.colon);\n      var type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    };\n\n    _proto.flowParsePredicate = function flowParsePredicate() {\n      var node = this.startNode();\n      var moduloLoc = this.state.startLoc;\n      var moduloPos = this.state.start;\n      this.expect(types.modulo);\n      var checksLoc = this.state.startLoc;\n      this.expectContextual(\"checks\");\n\n      if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n        this.raise(moduloPos, \"Spaces between ´%´ and ´checks´ are not allowed here.\");\n      }\n\n      if (this.eat(types.parenL)) {\n        node.value = this.parseExpression();\n        this.expect(types.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    };\n\n    _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {\n      var oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(types.colon);\n      var type = null;\n      var predicate = null;\n\n      if (this.match(types.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n\n        if (this.match(types.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n\n      return [type, predicate];\n    };\n\n    _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {\n      this.next();\n      this.flowParseInterfaceish(node, true);\n      return this.finishNode(node, \"DeclareClass\");\n    };\n\n    _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {\n      this.next();\n      var id = node.id = this.parseIdentifier();\n      var typeNode = this.startNode();\n      var typeContainer = this.startNode();\n\n      if (this.isRelational(\"<\")) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(types.parenL);\n      var tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      this.expect(types.parenR);\n\n      var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();\n\n      typeNode.returnType = _flowParseTypeAndPred[0];\n      node.predicate = _flowParseTypeAndPred[1];\n      typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n      this.finishNode(id, id.type);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareFunction\");\n    };\n\n    _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {\n      if (this.match(types._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(types._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(types._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.isContextual(\"module\")) {\n        if (this.lookahead().type === types.dot) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.unexpected(null, \"`declare module` cannot be used inside another `declare module`\");\n          }\n\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(\"type\")) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(\"opaque\")) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(\"interface\")) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(types._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        throw this.unexpected();\n      }\n    };\n\n    _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(true);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    };\n\n    _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {\n      var _this = this;\n\n      this.next();\n\n      if (this.match(types.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      var bodyNode = node.body = this.startNode();\n      var body = bodyNode.body = [];\n      this.expect(types.braceL);\n\n      while (!this.match(types.braceR)) {\n        var _bodyNode = this.startNode();\n\n        if (this.match(types._import)) {\n          var lookahead = this.lookahead();\n\n          if (lookahead.value !== \"type\" && lookahead.value !== \"typeof\") {\n            this.unexpected(null, \"Imports within a `declare module` body must always be `import type` or `import typeof`\");\n          }\n\n          this.next();\n          this.parseImport(_bodyNode);\n        } else {\n          this.expectContextual(\"declare\", \"Only declares and type imports are allowed inside declare module\");\n          _bodyNode = this.flowParseDeclare(_bodyNode, true);\n        }\n\n        body.push(_bodyNode);\n      }\n\n      this.expect(types.braceR);\n      this.finishNode(bodyNode, \"BlockStatement\");\n      var kind = null;\n      var hasModuleExport = false;\n      var errorMessage = \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\";\n      body.forEach(function (bodyElement) {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            _this.unexpected(bodyElement.start, errorMessage);\n          }\n\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            _this.unexpected(bodyElement.start, \"Duplicate `declare module.exports` statement\");\n          }\n\n          if (kind === \"ES\") _this.unexpected(bodyElement.start, errorMessage);\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    };\n\n    _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {\n      this.expect(types._export);\n\n      if (this.eat(types._default)) {\n        if (this.match(types._function) || this.match(types._class)) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n\n        node.default = true;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (this.match(types._const) || this.match(types._let) || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !insideModule) {\n          var label = this.state.value;\n          var suggestion = exportSuggestions[label];\n          this.unexpected(this.state.start, \"`declare export \" + label + \"` is not supported. Use `\" + suggestion + \"` instead\");\n        }\n\n        if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual(\"opaque\")) {\n            node.declaration = this.flowParseDeclare(this.startNode());\n            node.default = false;\n            return this.finishNode(node, \"DeclareExportDeclaration\");\n          } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) {\n            node = this.parseExport(node);\n\n            if (node.type === \"ExportNamedDeclaration\") {\n              node.type = \"ExportDeclaration\";\n              node.default = false;\n              delete node.exportKind;\n            }\n\n            node.type = \"Declare\" + node.type;\n            return node;\n          }\n      }\n\n      throw this.unexpected();\n    };\n\n    _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {\n      this.expectContextual(\"module\");\n      this.expect(types.dot);\n      this.expectContextual(\"exports\");\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n      return this.finishNode(node, \"DeclareModuleExports\");\n    };\n\n    _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {\n      this.next();\n      this.flowParseTypeAlias(node);\n      return this.finishNode(node, \"DeclareTypeAlias\");\n    };\n\n    _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {\n      this.next();\n      this.flowParseOpaqueType(node, true);\n      return this.finishNode(node, \"DeclareOpaqueType\");\n    };\n\n    _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {\n      this.next();\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"DeclareInterface\");\n    };\n\n    _proto.flowParseInterfaceish = function flowParseInterfaceish(node, isClass) {\n      node.id = this.flowParseRestrictedIdentifier(!isClass);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n      node.mixins = [];\n\n      if (this.eat(types._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(types.comma));\n      }\n\n      if (this.isContextual(\"mixins\")) {\n        this.next();\n\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(types.comma));\n      }\n\n      node.body = this.flowParseObjectType(true, false, false);\n    };\n\n    _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {\n      var node = this.startNode();\n      node.id = this.flowParseQualifiedTypeIdentifier();\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    };\n\n    _proto.flowParseInterface = function flowParseInterface(node) {\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    };\n\n    _proto.checkReservedType = function checkReservedType(word, startLoc) {\n      if (primitiveTypes.indexOf(word) > -1) {\n        this.raise(startLoc, \"Cannot overwrite primitive type \" + word);\n      }\n    };\n\n    _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal) {\n      this.checkReservedType(this.state.value, this.state.start);\n      return this.parseIdentifier(liberal);\n    };\n\n    _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {\n      node.id = this.flowParseRestrictedIdentifier();\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(types.eq);\n      this.semicolon();\n      return this.finishNode(node, \"TypeAlias\");\n    };\n\n    _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {\n      this.expectContextual(\"type\");\n      node.id = this.flowParseRestrictedIdentifier(true);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.supertype = null;\n\n      if (this.match(types.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(types.colon);\n      }\n\n      node.impltype = null;\n\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(types.eq);\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"OpaqueType\");\n    };\n\n    _proto.flowParseTypeParameter = function flowParseTypeParameter() {\n      var node = this.startNode();\n      var variance = this.flowParseVariance();\n      var ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      node.variance = variance;\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(types.eq)) {\n        this.eat(types.eq);\n        node.default = this.flowParseType();\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    };\n\n    _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration() {\n      var oldInType = this.state.inType;\n      var node = this.startNode();\n      node.params = [];\n      this.state.inType = true;\n\n      if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      do {\n        node.params.push(this.flowParseTypeParameter());\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      } while (!this.isRelational(\">\"));\n\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    };\n\n    _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {\n      var node = this.startNode();\n      var oldInType = this.state.inType;\n      node.params = [];\n      this.state.inType = true;\n      this.expectRelational(\"<\");\n\n      while (!this.isRelational(\">\")) {\n        node.params.push(this.flowParseType());\n\n        if (!this.isRelational(\">\")) {\n          this.expect(types.comma);\n        }\n      }\n\n      this.expectRelational(\">\");\n      this.state.inType = oldInType;\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    };\n\n    _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {\n      return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n    };\n\n    _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {\n      node.static = isStatic;\n      this.expect(types.bracketL);\n\n      if (this.lookahead().type === types.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n\n      this.expect(types.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    };\n\n    _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(types.parenL);\n\n      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam());\n\n        if (!this.match(types.parenR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      if (this.eat(types.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam();\n      }\n\n      this.expect(types.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    };\n\n    _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {\n      var valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    };\n\n    _proto.flowParseObjectType = function flowParseObjectType(allowStatic, allowExact, allowSpread) {\n      var oldInType = this.state.inType;\n      this.state.inType = true;\n      var nodeStart = this.startNode();\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      var endDelim;\n      var exact;\n\n      if (allowExact && this.match(types.braceBarL)) {\n        this.expect(types.braceBarL);\n        endDelim = types.braceBarR;\n        exact = true;\n      } else {\n        this.expect(types.braceL);\n        endDelim = types.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        var isStatic = false;\n        var node = this.startNode();\n\n        if (allowStatic && this.isContextual(\"static\") && this.lookahead().type !== types.colon) {\n          this.next();\n          isStatic = true;\n        }\n\n        var variance = this.flowParseVariance();\n\n        if (this.match(types.bracketL)) {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n        } else {\n          var kind = \"init\";\n\n          if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n            var lookahead = this.lookahead();\n\n            if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          nodeStart.properties.push(this.flowParseObjectTypeProperty(node, isStatic, variance, kind, allowSpread));\n        }\n\n        this.flowObjectTypeSemicolon();\n      }\n\n      this.expect(endDelim);\n      var out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n      this.state.inType = oldInType;\n      return out;\n    };\n\n    _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, variance, kind, allowSpread) {\n      if (this.match(types.ellipsis)) {\n        if (!allowSpread) {\n          this.unexpected(null, \"Spread operator cannot appear in class or interface definitions\");\n        }\n\n        if (variance) {\n          this.unexpected(variance.start, \"Spread properties cannot have variance\");\n        }\n\n        this.expect(types.ellipsis);\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.kind = kind;\n        var optional = false;\n\n        if (this.isRelational(\"<\") || this.match(types.parenL)) {\n          node.method = true;\n\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n          node.method = false;\n\n          if (this.eat(types.question)) {\n            optional = true;\n          }\n\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    };\n\n    _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(property) {\n      var paramCount = property.kind === \"get\" ? 0 : 1;\n      var start = property.start;\n      var length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (length !== paramCount) {\n        if (property.kind === \"get\") {\n          this.raise(start, \"getter must not have any formal parameters\");\n        } else {\n          this.raise(start, \"setter must have exactly one formal parameter\");\n        }\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(start, \"setter function argument must not be a rest parameter\");\n      }\n    };\n\n    _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {\n      if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n        this.unexpected();\n      }\n    };\n\n    _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n      startPos = startPos || this.state.start;\n      startLoc = startLoc || this.state.startLoc;\n      var node = id || this.parseIdentifier();\n\n      while (this.eat(types.dot)) {\n        var node2 = this.startNodeAt(startPos, startLoc);\n        node2.qualification = node;\n        node2.id = this.parseIdentifier();\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    };\n\n    _proto.flowParseGenericType = function flowParseGenericType(startPos, startLoc, id) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    };\n\n    _proto.flowParseTypeofType = function flowParseTypeofType() {\n      var node = this.startNode();\n      this.expect(types._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    };\n\n    _proto.flowParseTupleType = function flowParseTupleType() {\n      var node = this.startNode();\n      node.types = [];\n      this.expect(types.bracketL);\n\n      while (this.state.pos < this.input.length && !this.match(types.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(types.bracketR)) break;\n        this.expect(types.comma);\n      }\n\n      this.expect(types.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    };\n\n    _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam() {\n      var name = null;\n      var optional = false;\n      var typeAnnotation = null;\n      var node = this.startNode();\n      var lh = this.lookahead();\n\n      if (lh.type === types.colon || lh.type === types.question) {\n        name = this.parseIdentifier();\n\n        if (this.eat(types.question)) {\n          optional = true;\n        }\n\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    };\n\n    _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {\n      var node = this.startNodeAt(type.start, type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    };\n\n    _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {\n      if (params === void 0) {\n        params = [];\n      }\n\n      var rest = null;\n\n      while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam());\n\n        if (!this.match(types.parenR)) {\n          this.expect(types.comma);\n        }\n      }\n\n      if (this.eat(types.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam();\n      }\n\n      return {\n        params: params,\n        rest: rest\n      };\n    };\n\n    _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"void\":\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        default:\n          return this.flowParseGenericType(startPos, startLoc, id);\n      }\n    };\n\n    _proto.flowParsePrimaryType = function flowParsePrimaryType() {\n      var startPos = this.state.start;\n      var startLoc = this.state.startLoc;\n      var node = this.startNode();\n      var tmp;\n      var type;\n      var isGroupedType = false;\n      var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case types.name:\n          return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n        case types.braceL:\n          return this.flowParseObjectType(false, false, true);\n\n        case types.braceBarL:\n          return this.flowParseObjectType(false, true, true);\n\n        case types.bracketL:\n          return this.flowParseTupleType();\n\n        case types.relational:\n          if (this.state.value === \"<\") {\n            node.typeParameters = this.flowParseTypeParameterDeclaration();\n            this.expect(types.parenL);\n            tmp = this.flowParseFunctionTypeParams();\n            node.params = tmp.params;\n            node.rest = tmp.rest;\n            this.expect(types.parenR);\n            this.expect(types.arrow);\n            node.returnType = this.flowParseType();\n            return this.finishNode(node, \"FunctionTypeAnnotation\");\n          }\n\n          break;\n\n        case types.parenL:\n          this.next();\n\n          if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n            if (this.match(types.name)) {\n              var token = this.lookahead().type;\n              isGroupedType = token !== types.question && token !== types.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n              this.expect(types.parenR);\n              return type;\n            } else {\n              this.eat(types.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          this.expect(types.parenR);\n          this.expect(types.arrow);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case types.string:\n          return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n        case types._true:\n        case types._false:\n          node.value = this.match(types._true);\n          this.next();\n          return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n        case types.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n\n            if (!this.match(types.num)) {\n              this.unexpected(null, \"Unexpected token, expected \\\"number\\\"\");\n            }\n\n            return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", node.start, node.loc.start);\n          }\n\n          this.unexpected();\n\n        case types.num:\n          return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n        case types._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case types._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case types.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        default:\n          if (this.state.type.keyword === \"typeof\") {\n            return this.flowParseTypeofType();\n          }\n\n      }\n\n      throw this.unexpected();\n    };\n\n    _proto.flowParsePostfixType = function flowParsePostfixType() {\n      var startPos = this.state.start,\n          startLoc = this.state.startLoc;\n      var type = this.flowParsePrimaryType();\n\n      while (!this.canInsertSemicolon() && this.match(types.bracketL)) {\n        var node = this.startNodeAt(startPos, startLoc);\n        node.elementType = type;\n        this.expect(types.bracketL);\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      }\n\n      return type;\n    };\n\n    _proto.flowParsePrefixType = function flowParsePrefixType() {\n      var node = this.startNode();\n\n      if (this.eat(types.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    };\n\n    _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {\n      var param = this.flowParsePrefixType();\n\n      if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n        var node = this.startNodeAt(param.start, param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n\n      return param;\n    };\n\n    _proto.flowParseIntersectionType = function flowParseIntersectionType() {\n      var node = this.startNode();\n      this.eat(types.bitwiseAND);\n      var type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n\n      while (this.eat(types.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n\n      return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    };\n\n    _proto.flowParseUnionType = function flowParseUnionType() {\n      var node = this.startNode();\n      this.eat(types.bitwiseOR);\n      var type = this.flowParseIntersectionType();\n      node.types = [type];\n\n      while (this.eat(types.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n\n      return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n    };\n\n    _proto.flowParseType = function flowParseType() {\n      var oldInType = this.state.inType;\n      this.state.inType = true;\n      var type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;\n      return type;\n    };\n\n    _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {\n      var node = this.startNode();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    };\n\n    _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n      var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n      if (this.match(types.colon)) {\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.finishNode(ident, ident.type);\n      }\n\n      return ident;\n    };\n\n    _proto.typeCastToParameter = function typeCastToParameter(node) {\n      node.expression.typeAnnotation = node.typeAnnotation;\n      return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    };\n\n    _proto.flowParseVariance = function flowParseVariance() {\n      var variance = null;\n\n      if (this.match(types.plusMin)) {\n        variance = this.startNode();\n\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n\n        this.next();\n        this.finishNode(variance, \"Variance\");\n      }\n\n      return variance;\n    };\n\n    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody) {\n      var _this2 = this;\n\n      if (allowExpressionBody) {\n        return this.forwardNoArrowParamsConversionAt(node, function () {\n          return _superClass.prototype.parseFunctionBody.call(_this2, node, true);\n        });\n      }\n\n      return _superClass.prototype.parseFunctionBody.call(this, node, false);\n    };\n\n    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {\n      if (!allowExpressionBody && this.match(types.colon)) {\n        var typeNode = this.startNode();\n\n        var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser();\n\n        typeNode.typeAnnotation = _flowParseTypeAndPred2[0];\n        node.predicate = _flowParseTypeAndPred2[1];\n        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n      }\n\n      _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, allowExpressionBody);\n    };\n\n    _proto.parseStatement = function parseStatement(declaration, topLevel) {\n      if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n        var node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      } else {\n        return _superClass.prototype.parseStatement.call(this, declaration, topLevel);\n      }\n    };\n\n    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n            return this.flowParseDeclare(node);\n          }\n        } else if (this.match(types.name)) {\n          if (expr.name === \"interface\") {\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return _superClass.prototype.parseExpressionStatement.call(this, node, expr);\n    };\n\n    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {\n      return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || _superClass.prototype.shouldParseExportDeclaration.call(this);\n    };\n\n    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {\n      if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value == \"opaque\")) {\n        return false;\n      }\n\n      return _superClass.prototype.isExportDefaultSpecifier.call(this);\n    };\n\n    _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n      var _this3 = this;\n\n      if (!this.match(types.question)) return expr;\n\n      if (refNeedsArrowPos) {\n        var _state = this.state.clone();\n\n        try {\n          return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc);\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = _state;\n            refNeedsArrowPos.start = err.pos || this.state.start;\n            return expr;\n          } else {\n            throw err;\n          }\n        }\n      }\n\n      this.expect(types.question);\n      var state = this.state.clone();\n      var originalNoArrowAt = this.state.noArrowAt;\n      var node = this.startNodeAt(startPos, startLoc);\n\n      var _tryParseConditionalC = this.tryParseConditionalConsequent(),\n          consequent = _tryParseConditionalC.consequent,\n          failed = _tryParseConditionalC.failed;\n\n      var _getArrowLikeExpressi = this.getArrowLikeExpressions(consequent),\n          valid = _getArrowLikeExpressi[0],\n          invalid = _getArrowLikeExpressi[1];\n\n      if (failed || invalid.length > 0) {\n        var noArrowAt = originalNoArrowAt.concat();\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (var i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          var _tryParseConditionalC2 = this.tryParseConditionalConsequent();\n\n          consequent = _tryParseConditionalC2.consequent;\n          failed = _tryParseConditionalC2.failed;\n\n          var _getArrowLikeExpressi2 = this.getArrowLikeExpressions(consequent);\n\n          valid = _getArrowLikeExpressi2[0];\n          invalid = _getArrowLikeExpressi2[1];\n        }\n\n        if (failed && valid.length > 1) {\n          this.raise(state.start, \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\");\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n\n          var _tryParseConditionalC3 = this.tryParseConditionalConsequent();\n\n          consequent = _tryParseConditionalC3.consequent;\n          failed = _tryParseConditionalC3.failed;\n        }\n\n        this.getArrowLikeExpressions(consequent, true);\n      }\n\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(types.colon);\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {\n        return _this3.parseMaybeAssign(noIn, undefined, undefined, undefined);\n      });\n      return this.finishNode(node, \"ConditionalExpression\");\n    };\n\n    _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      var consequent = this.parseMaybeAssign();\n      var failed = !this.match(types.colon);\n      this.state.noArrowParamsConversionAt.pop();\n      return {\n        consequent: consequent,\n        failed: failed\n      };\n    };\n\n    _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {\n      var _this4 = this;\n\n      var stack = [node];\n      var arrows = [];\n\n      while (stack.length !== 0) {\n        var _node = stack.pop();\n\n        if (_node.type === \"ArrowFunctionExpression\") {\n          if (_node.typeParameters || !_node.returnType) {\n            this.toAssignableList(_node.params, true, \"arrow function parameters\");\n\n            _superClass.prototype.checkFunctionNameAndParams.call(this, _node, true);\n          } else {\n            arrows.push(_node);\n          }\n\n          stack.push(_node.body);\n        } else if (_node.type === \"ConditionalExpression\") {\n          stack.push(_node.consequent);\n          stack.push(_node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        for (var i = 0; i < arrows.length; i++) {\n          this.toAssignableList(node.params, true, \"arrow function parameters\");\n        }\n\n        return [arrows, []];\n      }\n\n      return partition(arrows, function (node) {\n        try {\n          _this4.toAssignableList(node.params, true, \"arrow function parameters\");\n\n          return true;\n        } catch (err) {\n          return false;\n        }\n      });\n    };\n\n    _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {\n      var result;\n\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    };\n\n    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {\n      node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n      }\n\n      if (this.match(types.colon)) {\n        var typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    };\n\n    _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {\n      if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n        return;\n      }\n\n      _superClass.prototype.assertModuleNodeAllowed.call(this, node);\n    };\n\n    _proto.parseExport = function parseExport(node) {\n      node = _superClass.prototype.parseExport.call(this, node);\n\n      if (node.type === \"ExportNamedDeclaration\" || node.type === \"ExportAllDeclaration\") {\n        node.exportKind = node.exportKind || \"value\";\n      }\n\n      return node;\n    };\n\n    _proto.parseExportDeclaration = function parseExportDeclaration(node) {\n      if (this.isContextual(\"type\")) {\n        node.exportKind = \"type\";\n        var declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(types.braceL)) {\n          node.specifiers = this.parseExportSpecifiers();\n          this.parseExportFrom(node);\n          return null;\n        } else {\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(\"opaque\")) {\n        node.exportKind = \"type\";\n\n        var _declarationNode = this.startNode();\n\n        this.next();\n        return this.flowParseOpaqueType(_declarationNode, false);\n      } else if (this.isContextual(\"interface\")) {\n        node.exportKind = \"type\";\n\n        var _declarationNode2 = this.startNode();\n\n        this.next();\n        return this.flowParseInterface(_declarationNode2);\n      } else {\n        return _superClass.prototype.parseExportDeclaration.call(this, node);\n      }\n    };\n\n    _proto.shouldParseExportStar = function shouldParseExportStar() {\n      return _superClass.prototype.shouldParseExportStar.call(this) || this.isContextual(\"type\") && this.lookahead().type === types.star;\n    };\n\n    _proto.parseExportStar = function parseExportStar(node) {\n      if (this.eatContextual(\"type\")) {\n        node.exportKind = \"type\";\n      }\n\n      return _superClass.prototype.parseExportStar.call(this, node);\n    };\n\n    _proto.parseExportNamespace = function parseExportNamespace(node) {\n      if (node.exportKind === \"type\") {\n        this.unexpected();\n      }\n\n      return _superClass.prototype.parseExportNamespace.call(this, node);\n    };\n\n    _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {\n      _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    };\n\n    _proto.isKeyword = function isKeyword$$1(name) {\n      if (this.state.inType && name === \"void\") {\n        return false;\n      } else {\n        return _superClass.prototype.isKeyword.call(this, name);\n      }\n    };\n\n    _proto.readToken = function readToken(code) {\n      var next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (this.state.inType && (code === 62 || code === 60)) {\n        return this.finishOp(types.relational, 1);\n      } else if (isIteratorStart(code, next)) {\n        this.state.isIterator = true;\n        return _superClass.prototype.readWord.call(this);\n      } else {\n        return _superClass.prototype.readToken.call(this, code);\n      }\n    };\n\n    _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {\n      if (node.type === \"TypeCastExpression\") {\n        return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isBinding, contextDescription);\n      } else {\n        return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);\n      }\n    };\n\n    _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {\n      for (var i = 0; i < exprList.length; i++) {\n        var expr = exprList[i];\n\n        if (expr && expr.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n\n      return _superClass.prototype.toAssignableList.call(this, exprList, isBinding, contextDescription);\n    };\n\n    _proto.toReferencedList = function toReferencedList(exprList) {\n      for (var i = 0; i < exprList.length; i++) {\n        var expr = exprList[i];\n\n        if (expr && expr._exprListItem && expr.type === \"TypeCastExpression\") {\n          this.raise(expr.start, \"Unexpected type cast\");\n        }\n      }\n\n      return exprList;\n    };\n\n    _proto.parseExprListItem = function parseExprListItem(allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {\n      var container = this.startNode();\n\n      var node = _superClass.prototype.parseExprListItem.call(this, allowEmpty, refShorthandDefaultPos, refNeedsArrowPos);\n\n      if (this.match(types.colon)) {\n        container._exprListItem = true;\n        container.expression = node;\n        container.typeAnnotation = this.flowParseTypeAnnotation();\n        return this.finishNode(container, \"TypeCastExpression\");\n      } else {\n        return node;\n      }\n    };\n\n    _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {\n      if (expr.type !== \"TypeCastExpression\") {\n        return _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);\n      }\n    };\n\n    _proto.parseClassProperty = function parseClassProperty(node) {\n      if (this.match(types.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      return _superClass.prototype.parseClassProperty.call(this, node);\n    };\n\n    _proto.isClassMethod = function isClassMethod() {\n      return this.isRelational(\"<\") || _superClass.prototype.isClassMethod.call(this);\n    };\n\n    _proto.isClassProperty = function isClassProperty() {\n      return this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);\n    };\n\n    _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {\n      return !this.match(types.colon) && _superClass.prototype.isNonstaticConstructor.call(this, method);\n    };\n\n    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {\n      if (method.variance) {\n        this.unexpected(method.variance.start);\n      }\n\n      delete method.variance;\n\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor);\n    };\n\n    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n      if (method.variance) {\n        this.unexpected(method.variance.start);\n      }\n\n      delete method.variance;\n\n      if (this.isRelational(\"<\")) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);\n    };\n\n    _proto.parseClassSuper = function parseClassSuper(node) {\n      _superClass.prototype.parseClassSuper.call(this, node);\n\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      if (this.isContextual(\"implements\")) {\n        this.next();\n        var implemented = node.implements = [];\n\n        do {\n          var _node2 = this.startNode();\n\n          _node2.id = this.flowParseRestrictedIdentifier(true);\n\n          if (this.isRelational(\"<\")) {\n            _node2.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            _node2.typeParameters = null;\n          }\n\n          implemented.push(this.finishNode(_node2, \"ClassImplements\"));\n        } while (this.eat(types.comma));\n      }\n    };\n\n    _proto.parsePropertyName = function parsePropertyName(node) {\n      var variance = this.flowParseVariance();\n\n      var key = _superClass.prototype.parsePropertyName.call(this, node);\n\n      node.variance = variance;\n      return key;\n    };\n\n    _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc) {\n      if (prop.variance) {\n        this.unexpected(prop.variance.start);\n      }\n\n      delete prop.variance;\n      var typeParameters;\n\n      if (this.isRelational(\"<\")) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(types.parenL)) this.unexpected();\n      }\n\n      _superClass.prototype.parseObjPropValue.call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos, containsEsc);\n\n      if (typeParameters) {\n        (prop.value || prop).typeParameters = typeParameters;\n      }\n    };\n\n    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {\n      if (this.eat(types.question)) {\n        if (param.type !== \"Identifier\") {\n          throw this.raise(param.start, \"A binding pattern parameter cannot be optional in an implementation signature.\");\n        }\n\n        param.optional = true;\n      }\n\n      if (this.match(types.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n\n      this.finishNode(param, param.type);\n      return param;\n    };\n\n    _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {\n      var node = _superClass.prototype.parseMaybeDefault.call(this, startPos, startLoc, left);\n\n      if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n        this.raise(node.typeAnnotation.start, \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\");\n      }\n\n      return node;\n    };\n\n    _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {\n      if (!hasTypeImportKind(node)) {\n        return _superClass.prototype.shouldParseDefaultImport.call(this, node);\n      }\n\n      return isMaybeDefaultImport(this.state);\n    };\n\n    _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n      specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true) : this.parseIdentifier();\n      this.checkLVal(specifier.local, true, undefined, contextDescription);\n      node.specifiers.push(this.finishNode(specifier, type));\n    };\n\n    _proto.parseImportSpecifiers = function parseImportSpecifiers(node) {\n      node.importKind = \"value\";\n      var kind = null;\n\n      if (this.match(types._typeof)) {\n        kind = \"typeof\";\n      } else if (this.isContextual(\"type\")) {\n        kind = \"type\";\n      }\n\n      if (kind) {\n        var lh = this.lookahead();\n\n        if (kind === \"type\" && lh.type === types.star) {\n          this.unexpected(lh.start);\n        }\n\n        if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      _superClass.prototype.parseImportSpecifiers.call(this, node);\n    };\n\n    _proto.parseImportSpecifier = function parseImportSpecifier(node) {\n      var specifier = this.startNode();\n      var firstIdentLoc = this.state.start;\n      var firstIdent = this.parseIdentifier(true);\n      var specifierTypeKind = null;\n\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n\n      var isBinding = false;\n\n      if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n        var as_ident = this.parseIdentifier(true);\n\n        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = as_ident.__clone();\n        } else {\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n\n        if (this.eatContextual(\"as\")) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = specifier.imported.__clone();\n        }\n      } else {\n        isBinding = true;\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = specifier.imported.__clone();\n      }\n\n      var nodeIsTypeImport = hasTypeImportKind(node);\n      var specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (nodeIsTypeImport && specifierIsTypeImport) {\n        this.raise(firstIdentLoc, \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\");\n      }\n\n      if (nodeIsTypeImport || specifierIsTypeImport) {\n        this.checkReservedType(specifier.local.name, specifier.local.start);\n      }\n\n      if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n        this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n      }\n\n      this.checkLVal(specifier.local, true, undefined, \"import specifier\");\n      node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n    };\n\n    _proto.parseFunctionParams = function parseFunctionParams(node) {\n      var kind = node.kind;\n\n      if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      _superClass.prototype.parseFunctionParams.call(this, node);\n    };\n\n    _proto.parseVarHead = function parseVarHead(decl) {\n      _superClass.prototype.parseVarHead.call(this, decl);\n\n      if (this.match(types.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.finishNode(decl.id, decl.id.type);\n      }\n    };\n\n    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {\n      if (this.match(types.colon)) {\n        var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);\n    };\n\n    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {\n      return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);\n    };\n\n    _proto.parseMaybeAssign = function parseMaybeAssign(noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {\n      var _this5 = this;\n\n      var jsxError = null;\n\n      if (types.jsxTagStart && this.match(types.jsxTagStart)) {\n        var state = this.state.clone();\n\n        try {\n          return _superClass.prototype.parseMaybeAssign.call(this, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n            this.state.context.length -= 2;\n            jsxError = err;\n          } else {\n            throw err;\n          }\n        }\n      }\n\n      if (jsxError != null || this.isRelational(\"<\")) {\n        var arrowExpression;\n        var typeParameters;\n\n        try {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n          arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, function () {\n            return _superClass.prototype.parseMaybeAssign.call(_this5, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);\n          });\n          arrowExpression.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(arrowExpression, typeParameters);\n        } catch (err) {\n          throw jsxError || err;\n        }\n\n        if (arrowExpression.type === \"ArrowFunctionExpression\") {\n          return arrowExpression;\n        } else if (jsxError != null) {\n          throw jsxError;\n        } else {\n          this.raise(typeParameters.start, \"Expected an arrow function after this type parameter declaration\");\n        }\n      }\n\n      return _superClass.prototype.parseMaybeAssign.call(this, noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos);\n    };\n\n    _proto.parseArrow = function parseArrow(node) {\n      if (this.match(types.colon)) {\n        var state = this.state.clone();\n\n        try {\n          var oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n          var typeNode = this.startNode();\n\n          var _flowParseTypeAndPred3 = this.flowParseTypeAndPredicateInitialiser();\n\n          typeNode.typeAnnotation = _flowParseTypeAndPred3[0];\n          node.predicate = _flowParseTypeAndPred3[1];\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(types.arrow)) this.unexpected();\n          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n          } else {\n            throw err;\n          }\n        }\n      }\n\n      return _superClass.prototype.parseArrow.call(this, node);\n    };\n\n    _proto.shouldParseArrow = function shouldParseArrow() {\n      return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);\n    };\n\n    _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        _superClass.prototype.setArrowFunctionParameters.call(this, node, params);\n      }\n    };\n\n    _proto.checkFunctionNameAndParams = function checkFunctionNameAndParams(node, isArrowFunction) {\n      if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        return;\n      }\n\n      return _superClass.prototype.checkFunctionNameAndParams.call(this, node, isArrowFunction);\n    };\n\n    _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {\n      return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n    };\n\n    _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {\n      if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n        this.next();\n        var node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (base.type === \"Identifier\" && base.name === \"async\" && this.isRelational(\"<\")) {\n        var state = this.state.clone();\n        var error;\n\n        try {\n          var _node3 = this.parseAsyncArrowWithTypeParameters(startPos, startLoc);\n\n          if (_node3) return _node3;\n        } catch (e) {\n          error = e;\n        }\n\n        this.state = state;\n\n        try {\n          return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);\n        } catch (e) {\n          throw error || e;\n        }\n      }\n\n      return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);\n    };\n\n    _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n      var node = this.startNodeAt(startPos, startLoc);\n      this.parseFunctionParams(node);\n      if (!this.parseArrow(node)) return;\n      return this.parseArrowExpression(node, undefined, true);\n    };\n\n    _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {\n      var next = this.input.charCodeAt(this.state.pos + 1);\n\n      if (code === 42 && next === 47 && this.state.hasFlowComment) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      _superClass.prototype.readToken_mult_modulo.call(this, code);\n    };\n\n    _proto.skipBlockComment = function skipBlockComment() {\n      if (this.hasPlugin(\"flow\") && this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        this.hasFlowCommentCompletion();\n        this.state.pos += this.skipFlowComment();\n        this.state.hasFlowComment = true;\n        return;\n      }\n\n      var end;\n\n      if (this.hasPlugin(\"flow\") && this.state.hasFlowComment) {\n        end = this.input.indexOf(\"*-/\", this.state.pos += 2);\n        if (end === -1) this.raise(this.state.pos - 2, \"Unterminated comment\");\n        this.state.pos = end + 3;\n        return;\n      }\n\n      _superClass.prototype.skipBlockComment.call(this);\n    };\n\n    _proto.skipFlowComment = function skipFlowComment() {\n      var ch2 = this.input.charCodeAt(this.state.pos + 2);\n      var ch3 = this.input.charCodeAt(this.state.pos + 3);\n\n      if (ch2 === 58 && ch3 === 58) {\n        return 4;\n      }\n\n      if (this.input.slice(this.state.pos + 2, 14) === \"flow-include\") {\n        return 14;\n      }\n\n      if (ch2 === 58 && ch3 !== 58 && 2) {\n        return 2;\n      }\n\n      return false;\n    };\n\n    _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {\n      var end = this.input.indexOf(\"*/\", this.state.pos);\n\n      if (end === -1) {\n        this.raise(this.state.pos, \"Unterminated comment\");\n      }\n    };\n\n    return _class;\n  }(superClass);\n});\n\nvar entities = {\n  quot: \"\\\"\",\n  amp: \"&\",\n  apos: \"'\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\xA0\",\n  iexcl: \"\\xA1\",\n  cent: \"\\xA2\",\n  pound: \"\\xA3\",\n  curren: \"\\xA4\",\n  yen: \"\\xA5\",\n  brvbar: \"\\xA6\",\n  sect: \"\\xA7\",\n  uml: \"\\xA8\",\n  copy: \"\\xA9\",\n  ordf: \"\\xAA\",\n  laquo: \"\\xAB\",\n  not: \"\\xAC\",\n  shy: \"\\xAD\",\n  reg: \"\\xAE\",\n  macr: \"\\xAF\",\n  deg: \"\\xB0\",\n  plusmn: \"\\xB1\",\n  sup2: \"\\xB2\",\n  sup3: \"\\xB3\",\n  acute: \"\\xB4\",\n  micro: \"\\xB5\",\n  para: \"\\xB6\",\n  middot: \"\\xB7\",\n  cedil: \"\\xB8\",\n  sup1: \"\\xB9\",\n  ordm: \"\\xBA\",\n  raquo: \"\\xBB\",\n  frac14: \"\\xBC\",\n  frac12: \"\\xBD\",\n  frac34: \"\\xBE\",\n  iquest: \"\\xBF\",\n  Agrave: \"\\xC0\",\n  Aacute: \"\\xC1\",\n  Acirc: \"\\xC2\",\n  Atilde: \"\\xC3\",\n  Auml: \"\\xC4\",\n  Aring: \"\\xC5\",\n  AElig: \"\\xC6\",\n  Ccedil: \"\\xC7\",\n  Egrave: \"\\xC8\",\n  Eacute: \"\\xC9\",\n  Ecirc: \"\\xCA\",\n  Euml: \"\\xCB\",\n  Igrave: \"\\xCC\",\n  Iacute: \"\\xCD\",\n  Icirc: \"\\xCE\",\n  Iuml: \"\\xCF\",\n  ETH: \"\\xD0\",\n  Ntilde: \"\\xD1\",\n  Ograve: \"\\xD2\",\n  Oacute: \"\\xD3\",\n  Ocirc: \"\\xD4\",\n  Otilde: \"\\xD5\",\n  Ouml: \"\\xD6\",\n  times: \"\\xD7\",\n  Oslash: \"\\xD8\",\n  Ugrave: \"\\xD9\",\n  Uacute: \"\\xDA\",\n  Ucirc: \"\\xDB\",\n  Uuml: \"\\xDC\",\n  Yacute: \"\\xDD\",\n  THORN: \"\\xDE\",\n  szlig: \"\\xDF\",\n  agrave: \"\\xE0\",\n  aacute: \"\\xE1\",\n  acirc: \"\\xE2\",\n  atilde: \"\\xE3\",\n  auml: \"\\xE4\",\n  aring: \"\\xE5\",\n  aelig: \"\\xE6\",\n  ccedil: \"\\xE7\",\n  egrave: \"\\xE8\",\n  eacute: \"\\xE9\",\n  ecirc: \"\\xEA\",\n  euml: \"\\xEB\",\n  igrave: \"\\xEC\",\n  iacute: \"\\xED\",\n  icirc: \"\\xEE\",\n  iuml: \"\\xEF\",\n  eth: \"\\xF0\",\n  ntilde: \"\\xF1\",\n  ograve: \"\\xF2\",\n  oacute: \"\\xF3\",\n  ocirc: \"\\xF4\",\n  otilde: \"\\xF5\",\n  ouml: \"\\xF6\",\n  divide: \"\\xF7\",\n  oslash: \"\\xF8\",\n  ugrave: \"\\xF9\",\n  uacute: \"\\xFA\",\n  ucirc: \"\\xFB\",\n  uuml: \"\\xFC\",\n  yacute: \"\\xFD\",\n  thorn: \"\\xFE\",\n  yuml: \"\\xFF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nvar HEX_NUMBER = /^[\\da-fA-F]+$/;\nvar DECIMAL_NUMBER = /^\\d+$/;\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", {\n  beforeExpr: true\n});\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", {\n  startsExpr: true\n});\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr);\n  this.state.context.push(types$1.j_oTag);\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  var out = this.state.context.pop();\n\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsxPlugin = (function (superClass) {\n  return function (_superClass) {\n    _inheritsLoose(_class, _superClass);\n\n    function _class() {\n      return _superClass.apply(this, arguments) || this;\n    }\n\n    var _proto = _class.prototype;\n\n    _proto.jsxReadToken = function jsxReadToken() {\n      var out = \"\";\n      var chunkStart = this.state.pos;\n\n      for (;;) {\n        if (this.state.pos >= this.input.length) {\n          this.raise(this.state.start, \"Unterminated JSX contents\");\n        }\n\n        var ch = this.input.charCodeAt(this.state.pos);\n\n        switch (ch) {\n          case 60:\n          case 123:\n            if (this.state.pos === this.state.start) {\n              if (ch === 60 && this.state.exprAllowed) {\n                ++this.state.pos;\n                return this.finishToken(types.jsxTagStart);\n              }\n\n              return this.getTokenFromCode(ch);\n            }\n\n            out += this.input.slice(chunkStart, this.state.pos);\n            return this.finishToken(types.jsxText, out);\n\n          case 38:\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadEntity();\n            chunkStart = this.state.pos;\n            break;\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.state.pos);\n              out += this.jsxReadNewLine(true);\n              chunkStart = this.state.pos;\n            } else {\n              ++this.state.pos;\n            }\n\n        }\n      }\n    };\n\n    _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {\n      var ch = this.input.charCodeAt(this.state.pos);\n      var out;\n      ++this.state.pos;\n\n      if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n        ++this.state.pos;\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n      } else {\n        out = String.fromCharCode(ch);\n      }\n\n      ++this.state.curLine;\n      this.state.lineStart = this.state.pos;\n      return out;\n    };\n\n    _proto.jsxReadString = function jsxReadString(quote) {\n      var out = \"\";\n      var chunkStart = ++this.state.pos;\n\n      for (;;) {\n        if (this.state.pos >= this.input.length) {\n          this.raise(this.state.start, \"Unterminated string constant\");\n        }\n\n        var ch = this.input.charCodeAt(this.state.pos);\n        if (ch === quote) break;\n\n        if (ch === 38) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(false);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n      }\n\n      out += this.input.slice(chunkStart, this.state.pos++);\n      return this.finishToken(types.string, out);\n    };\n\n    _proto.jsxReadEntity = function jsxReadEntity() {\n      var str = \"\";\n      var count = 0;\n      var entity;\n      var ch = this.input[this.state.pos];\n      var startPos = ++this.state.pos;\n\n      while (this.state.pos < this.input.length && count++ < 10) {\n        ch = this.input[this.state.pos++];\n\n        if (ch === \";\") {\n          if (str[0] === \"#\") {\n            if (str[1] === \"x\") {\n              str = str.substr(2);\n\n              if (HEX_NUMBER.test(str)) {\n                entity = String.fromCodePoint(parseInt(str, 16));\n              }\n            } else {\n              str = str.substr(1);\n\n              if (DECIMAL_NUMBER.test(str)) {\n                entity = String.fromCodePoint(parseInt(str, 10));\n              }\n            }\n          } else {\n            entity = entities[str];\n          }\n\n          break;\n        }\n\n        str += ch;\n      }\n\n      if (!entity) {\n        this.state.pos = startPos;\n        return \"&\";\n      }\n\n      return entity;\n    };\n\n    _proto.jsxReadWord = function jsxReadWord() {\n      var ch;\n      var start = this.state.pos;\n\n      do {\n        ch = this.input.charCodeAt(++this.state.pos);\n      } while (isIdentifierChar(ch) || ch === 45);\n\n      return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n    };\n\n    _proto.jsxParseIdentifier = function jsxParseIdentifier() {\n      var node = this.startNode();\n\n      if (this.match(types.jsxName)) {\n        node.name = this.state.value;\n      } else if (this.state.type.keyword) {\n        node.name = this.state.type.keyword;\n      } else {\n        this.unexpected();\n      }\n\n      this.next();\n      return this.finishNode(node, \"JSXIdentifier\");\n    };\n\n    _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {\n      var startPos = this.state.start;\n      var startLoc = this.state.startLoc;\n      var name = this.jsxParseIdentifier();\n      if (!this.eat(types.colon)) return name;\n      var node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsxParseIdentifier();\n      return this.finishNode(node, \"JSXNamespacedName\");\n    };\n\n    _proto.jsxParseElementName = function jsxParseElementName() {\n      var startPos = this.state.start;\n      var startLoc = this.state.startLoc;\n      var node = this.jsxParseNamespacedName();\n\n      while (this.eat(types.dot)) {\n        var newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsxParseIdentifier();\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\n      }\n\n      return node;\n    };\n\n    _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {\n      var node;\n\n      switch (this.state.type) {\n        case types.braceL:\n          node = this.jsxParseExpressionContainer();\n\n          if (node.expression.type === \"JSXEmptyExpression\") {\n            throw this.raise(node.start, \"JSX attributes must only be assigned a non-empty expression\");\n          } else {\n            return node;\n          }\n\n        case types.jsxTagStart:\n        case types.string:\n          return this.parseExprAtom();\n\n        default:\n          throw this.raise(this.state.start, \"JSX value should be either an expression or a quoted JSX text\");\n      }\n    };\n\n    _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {\n      var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n      return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n    };\n\n    _proto.jsxParseSpreadChild = function jsxParseSpreadChild() {\n      var node = this.startNode();\n      this.expect(types.braceL);\n      this.expect(types.ellipsis);\n      node.expression = this.parseExpression();\n      this.expect(types.braceR);\n      return this.finishNode(node, \"JSXSpreadChild\");\n    };\n\n    _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer() {\n      var node = this.startNode();\n      this.next();\n\n      if (this.match(types.braceR)) {\n        node.expression = this.jsxParseEmptyExpression();\n      } else {\n        node.expression = this.parseExpression();\n      }\n\n      this.expect(types.braceR);\n      return this.finishNode(node, \"JSXExpressionContainer\");\n    };\n\n    _proto.jsxParseAttribute = function jsxParseAttribute() {\n      var node = this.startNode();\n\n      if (this.eat(types.braceL)) {\n        this.expect(types.ellipsis);\n        node.argument = this.parseMaybeAssign();\n        this.expect(types.braceR);\n        return this.finishNode(node, \"JSXSpreadAttribute\");\n      }\n\n      node.name = this.jsxParseNamespacedName();\n      node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n      return this.finishNode(node, \"JSXAttribute\");\n    };\n\n    _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startPos, startLoc) {\n      var node = this.startNodeAt(startPos, startLoc);\n\n      if (this.match(types.jsxTagEnd)) {\n        this.expect(types.jsxTagEnd);\n        return this.finishNode(node, \"JSXOpeningFragment\");\n      }\n\n      node.attributes = [];\n      node.name = this.jsxParseElementName();\n\n      while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n        node.attributes.push(this.jsxParseAttribute());\n      }\n\n      node.selfClosing = this.eat(types.slash);\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningElement\");\n    };\n\n    _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startPos, startLoc) {\n      var node = this.startNodeAt(startPos, startLoc);\n\n      if (this.match(types.jsxTagEnd)) {\n        this.expect(types.jsxTagEnd);\n        return this.finishNode(node, \"JSXClosingFragment\");\n      }\n\n      node.name = this.jsxParseElementName();\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingElement\");\n    };\n\n    _proto.jsxParseElementAt = function jsxParseElementAt(startPos, startLoc) {\n      var node = this.startNodeAt(startPos, startLoc);\n      var children = [];\n      var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n      var closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.state.type) {\n            case types.jsxTagStart:\n              startPos = this.state.start;\n              startLoc = this.state.startLoc;\n              this.next();\n\n              if (this.eat(types.slash)) {\n                closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n                break contents;\n              }\n\n              children.push(this.jsxParseElementAt(startPos, startLoc));\n              break;\n\n            case types.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n\n            case types.braceL:\n              if (this.lookahead().type === types.ellipsis) {\n                children.push(this.jsxParseSpreadChild());\n              } else {\n                children.push(this.jsxParseExpressionContainer());\n              }\n\n              break;\n\n            default:\n              throw this.unexpected();\n          }\n        }\n\n        if (isFragment(openingElement) && !isFragment(closingElement)) {\n          this.raise(closingElement.start, \"Expected corresponding JSX closing tag for <>\");\n        } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n          this.raise(closingElement.start, \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\");\n        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n          if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n            this.raise(closingElement.start, \"Expected corresponding JSX closing tag for <\" + getQualifiedJSXName(openingElement.name) + \">\");\n          }\n        }\n      }\n\n      if (isFragment(openingElement)) {\n        node.openingFragment = openingElement;\n        node.closingFragment = closingElement;\n      } else {\n        node.openingElement = openingElement;\n        node.closingElement = closingElement;\n      }\n\n      node.children = children;\n\n      if (this.match(types.relational) && this.state.value === \"<\") {\n        this.raise(this.state.start, \"Adjacent JSX elements must be wrapped in an enclosing tag. \" + \"Did you want a JSX fragment <>...</>?\");\n      }\n\n      return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n    };\n\n    _proto.jsxParseElement = function jsxParseElement() {\n      var startPos = this.state.start;\n      var startLoc = this.state.startLoc;\n      this.next();\n      return this.jsxParseElementAt(startPos, startLoc);\n    };\n\n    _proto.parseExprAtom = function parseExprAtom(refShortHandDefaultPos) {\n      if (this.match(types.jsxText)) {\n        return this.parseLiteral(this.state.value, \"JSXText\");\n      } else if (this.match(types.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else {\n        return _superClass.prototype.parseExprAtom.call(this, refShortHandDefaultPos);\n      }\n    };\n\n    _proto.readToken = function readToken(code) {\n      if (this.state.inPropertyName) return _superClass.prototype.readToken.call(this, code);\n      var context = this.curContext();\n\n      if (context === types$1.j_expr) {\n        return this.jsxReadToken();\n      }\n\n      if (context === types$1.j_oTag || context === types$1.j_cTag) {\n        if (isIdentifierStart(code)) {\n          return this.jsxReadWord();\n        }\n\n        if (code === 62) {\n          ++this.state.pos;\n          return this.finishToken(types.jsxTagEnd);\n        }\n\n        if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n          return this.jsxReadString(code);\n        }\n      }\n\n      if (code === 60 && this.state.exprAllowed) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagStart);\n      }\n\n      return _superClass.prototype.readToken.call(this, code);\n    };\n\n    _proto.updateContext = function updateContext(prevType) {\n      if (this.match(types.braceL)) {\n        var curContext = this.curContext();\n\n        if (curContext === types$1.j_oTag) {\n          this.state.context.push(types$1.braceExpression);\n        } else if (curContext === types$1.j_expr) {\n          this.state.context.push(types$1.templateQuasi);\n        } else {\n          _superClass.prototype.updateContext.call(this, prevType);\n        }\n\n        this.state.exprAllowed = true;\n      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n        this.state.context.length -= 2;\n        this.state.context.push(types$1.j_cTag);\n        this.state.exprAllowed = false;\n      } else {\n        return _superClass.prototype.updateContext.call(this, prevType);\n      }\n    };\n\n    return _class;\n  }(superClass);\n});\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(\"Unexpected \" + x + \" value.\");\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nvar typescriptPlugin = (function (superClass) {\n  return function (_superClass) {\n    _inheritsLoose(_class, _superClass);\n\n    function _class() {\n      return _superClass.apply(this, arguments) || this;\n    }\n\n    var _proto = _class.prototype;\n\n    _proto.tsIsIdentifier = function tsIsIdentifier() {\n      return this.match(types.name);\n    };\n\n    _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {\n      this.next();\n      return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question);\n    };\n\n    _proto.tsParseModifier = function tsParseModifier(allowedModifiers) {\n      if (!this.match(types.name)) {\n        return undefined;\n      }\n\n      var modifier = this.state.value;\n\n      if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n\n      return undefined;\n    };\n\n    _proto.tsIsListTerminator = function tsIsListTerminator(kind) {\n      switch (kind) {\n        case \"EnumMembers\":\n        case \"TypeMembers\":\n          return this.match(types.braceR);\n\n        case \"HeritageClauseElement\":\n          return this.match(types.braceL);\n\n        case \"TupleElementTypes\":\n          return this.match(types.bracketR);\n\n        case \"TypeParametersOrArguments\":\n          return this.isRelational(\">\");\n      }\n\n      throw new Error(\"Unreachable\");\n    };\n\n    _proto.tsParseList = function tsParseList(kind, parseElement) {\n      var result = [];\n\n      while (!this.tsIsListTerminator(kind)) {\n        result.push(parseElement());\n      }\n\n      return result;\n    };\n\n    _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement) {\n      return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));\n    };\n\n    _proto.tsTryParseDelimitedList = function tsTryParseDelimitedList(kind, parseElement) {\n      return this.tsParseDelimitedListWorker(kind, parseElement, false);\n    };\n\n    _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n      var result = [];\n\n      while (true) {\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        var element = parseElement();\n\n        if (element == null) {\n          return undefined;\n        }\n\n        result.push(element);\n\n        if (this.eat(types.comma)) {\n          continue;\n        }\n\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        if (expectSuccess) {\n          this.expect(types.comma);\n        }\n\n        return undefined;\n      }\n\n      return result;\n    };\n\n    _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n      if (!skipFirstToken) {\n        if (bracket) {\n          this.expect(types.bracketL);\n        } else {\n          this.expectRelational(\"<\");\n        }\n      }\n\n      var result = this.tsParseDelimitedList(kind, parseElement);\n\n      if (bracket) {\n        this.expect(types.bracketR);\n      } else {\n        this.expectRelational(\">\");\n      }\n\n      return result;\n    };\n\n    _proto.tsParseEntityName = function tsParseEntityName(allowReservedWords) {\n      var entity = this.parseIdentifier();\n\n      while (this.eat(types.dot)) {\n        var node = this.startNodeAtNode(entity);\n        node.left = entity;\n        node.right = this.parseIdentifier(allowReservedWords);\n        entity = this.finishNode(node, \"TSQualifiedName\");\n      }\n\n      return entity;\n    };\n\n    _proto.tsParseTypeReference = function tsParseTypeReference() {\n      var node = this.startNode();\n      node.typeName = this.tsParseEntityName(false);\n\n      if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n\n      return this.finishNode(node, \"TSTypeReference\");\n    };\n\n    _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {\n      this.next();\n      var node = this.startNode();\n      node.parameterName = lhs;\n      node.typeAnnotation = this.tsParseTypeAnnotation(false);\n      return this.finishNode(node, \"TSTypePredicate\");\n    };\n\n    _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {\n      var node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"TSThisType\");\n    };\n\n    _proto.tsParseTypeQuery = function tsParseTypeQuery() {\n      var node = this.startNode();\n      this.expect(types._typeof);\n      node.exprName = this.tsParseEntityName(true);\n      return this.finishNode(node, \"TSTypeQuery\");\n    };\n\n    _proto.tsParseTypeParameter = function tsParseTypeParameter() {\n      var node = this.startNode();\n      node.name = this.parseIdentifierName(node.start);\n      node.constraint = this.tsEatThenParseType(types._extends);\n      node.default = this.tsEatThenParseType(types.eq);\n      return this.finishNode(node, \"TSTypeParameter\");\n    };\n\n    _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {\n      if (this.isRelational(\"<\")) {\n        return this.tsParseTypeParameters();\n      }\n    };\n\n    _proto.tsParseTypeParameters = function tsParseTypeParameters() {\n      var node = this.startNode();\n\n      if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), false, true);\n      return this.finishNode(node, \"TSTypeParameterDeclaration\");\n    };\n\n    _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {\n      var returnTokenRequired = returnToken === types.arrow;\n      signature.typeParameters = this.tsTryParseTypeParameters();\n      this.expect(types.parenL);\n      signature.parameters = this.tsParseBindingListForSignature();\n\n      if (returnTokenRequired) {\n        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      } else if (this.match(returnToken)) {\n        signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      }\n    };\n\n    _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {\n      var _this = this;\n\n      return this.parseBindingList(types.parenR).map(function (pattern) {\n        if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\") {\n          throw _this.unexpected(pattern.start, \"Name in a signature must be an Identifier.\");\n        }\n\n        return pattern;\n      });\n    };\n\n    _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {\n      if (!this.eat(types.comma)) {\n        this.semicolon();\n      }\n    };\n\n    _proto.tsParseSignatureMember = function tsParseSignatureMember(kind) {\n      var node = this.startNode();\n\n      if (kind === \"TSConstructSignatureDeclaration\") {\n        this.expect(types._new);\n      }\n\n      this.tsFillSignature(types.colon, node);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, kind);\n    };\n\n    _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {\n      this.next();\n      return this.eat(types.name) && this.match(types.colon);\n    };\n\n    _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {\n      if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n        return undefined;\n      }\n\n      this.expect(types.bracketL);\n      var id = this.parseIdentifier();\n      this.expect(types.colon);\n      id.typeAnnotation = this.tsParseTypeAnnotation(false);\n      this.expect(types.bracketR);\n      node.parameters = [id];\n      var type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, \"TSIndexSignature\");\n    };\n\n    _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {\n      this.parsePropertyName(node);\n      if (this.eat(types.question)) node.optional = true;\n      var nodeAny = node;\n\n      if (!readonly && (this.match(types.parenL) || this.isRelational(\"<\"))) {\n        var method = nodeAny;\n        this.tsFillSignature(types.colon, method);\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(method, \"TSMethodSignature\");\n      } else {\n        var property = nodeAny;\n        if (readonly) property.readonly = true;\n        var type = this.tsTryParseTypeAnnotation();\n        if (type) property.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(property, \"TSPropertySignature\");\n      }\n    };\n\n    _proto.tsParseTypeMember = function tsParseTypeMember() {\n      if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\");\n      }\n\n      if (this.match(types._new) && this.tsLookAhead(this.tsIsStartOfConstructSignature.bind(this))) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\");\n      }\n\n      var node = this.startNode();\n      var readonly = !!this.tsParseModifier([\"readonly\"]);\n      var idx = this.tsTryParseIndexSignature(node);\n\n      if (idx) {\n        if (readonly) node.readonly = true;\n        return idx;\n      }\n\n      return this.tsParsePropertyOrMethodSignature(node, readonly);\n    };\n\n    _proto.tsIsStartOfConstructSignature = function tsIsStartOfConstructSignature() {\n      this.next();\n      return this.match(types.parenL) || this.isRelational(\"<\");\n    };\n\n    _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {\n      var node = this.startNode();\n      node.members = this.tsParseObjectTypeMembers();\n      return this.finishNode(node, \"TSTypeLiteral\");\n    };\n\n    _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {\n      this.expect(types.braceL);\n      var members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n      this.expect(types.braceR);\n      return members;\n    };\n\n    _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {\n      this.next();\n\n      if (this.isContextual(\"readonly\")) {\n        this.next();\n      }\n\n      if (!this.match(types.bracketL)) {\n        return false;\n      }\n\n      this.next();\n\n      if (!this.tsIsIdentifier()) {\n        return false;\n      }\n\n      this.next();\n      return this.match(types._in);\n    };\n\n    _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {\n      var node = this.startNode();\n      node.name = this.parseIdentifierName(node.start);\n      node.constraint = this.tsExpectThenParseType(types._in);\n      return this.finishNode(node, \"TSTypeParameter\");\n    };\n\n    _proto.tsParseMappedType = function tsParseMappedType() {\n      var node = this.startNode();\n      this.expect(types.braceL);\n\n      if (this.eatContextual(\"readonly\")) {\n        node.readonly = true;\n      }\n\n      this.expect(types.bracketL);\n      node.typeParameter = this.tsParseMappedTypeParameter();\n      this.expect(types.bracketR);\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n      }\n\n      node.typeAnnotation = this.tsTryParseType();\n      this.semicolon();\n      this.expect(types.braceR);\n      return this.finishNode(node, \"TSMappedType\");\n    };\n\n    _proto.tsParseTupleType = function tsParseTupleType() {\n      var node = this.startNode();\n      node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseType.bind(this), true, false);\n      return this.finishNode(node, \"TSTupleType\");\n    };\n\n    _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {\n      var node = this.startNode();\n      this.expect(types.parenL);\n      node.typeAnnotation = this.tsParseType();\n      this.expect(types.parenR);\n      return this.finishNode(node, \"TSParenthesizedType\");\n    };\n\n    _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type) {\n      var node = this.startNode();\n\n      if (type === \"TSConstructorType\") {\n        this.expect(types._new);\n      }\n\n      this.tsFillSignature(types.arrow, node);\n      return this.finishNode(node, type);\n    };\n\n    _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {\n      var _this2 = this;\n\n      var node = this.startNode();\n\n      node.literal = function () {\n        switch (_this2.state.type) {\n          case types.num:\n            return _this2.parseLiteral(_this2.state.value, \"NumericLiteral\");\n\n          case types.string:\n            return _this2.parseLiteral(_this2.state.value, \"StringLiteral\");\n\n          case types._true:\n          case types._false:\n            return _this2.parseBooleanLiteral();\n\n          default:\n            throw _this2.unexpected();\n        }\n      }();\n\n      return this.finishNode(node, \"TSLiteralType\");\n    };\n\n    _proto.tsParseNonArrayType = function tsParseNonArrayType() {\n      switch (this.state.type) {\n        case types.name:\n        case types._void:\n        case types._null:\n          {\n            var type = this.match(types._void) ? \"TSVoidKeyword\" : this.match(types._null) ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n            if (type !== undefined && this.lookahead().type !== types.dot) {\n              var node = this.startNode();\n              this.next();\n              return this.finishNode(node, type);\n            }\n\n            return this.tsParseTypeReference();\n          }\n\n        case types.string:\n        case types.num:\n        case types._true:\n        case types._false:\n          return this.tsParseLiteralTypeNode();\n\n        case types.plusMin:\n          if (this.state.value === \"-\") {\n            var _node = this.startNode();\n\n            this.next();\n\n            if (!this.match(types.num)) {\n              throw this.unexpected();\n            }\n\n            _node.literal = this.parseLiteral(-this.state.value, \"NumericLiteral\", _node.start, _node.loc.start);\n            return this.finishNode(_node, \"TSLiteralType\");\n          }\n\n          break;\n\n        case types._this:\n          {\n            var thisKeyword = this.tsParseThisTypeNode();\n\n            if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n              return this.tsParseThisTypePredicate(thisKeyword);\n            } else {\n              return thisKeyword;\n            }\n          }\n\n        case types._typeof:\n          return this.tsParseTypeQuery();\n\n        case types.braceL:\n          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n        case types.bracketL:\n          return this.tsParseTupleType();\n\n        case types.parenL:\n          return this.tsParseParenthesizedType();\n      }\n\n      throw this.unexpected();\n    };\n\n    _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {\n      var type = this.tsParseNonArrayType();\n\n      while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {\n        if (this.match(types.bracketR)) {\n          var node = this.startNodeAtNode(type);\n          node.elementType = type;\n          this.expect(types.bracketR);\n          type = this.finishNode(node, \"TSArrayType\");\n        } else {\n          var _node2 = this.startNodeAtNode(type);\n\n          _node2.objectType = type;\n          _node2.indexType = this.tsParseType();\n          this.expect(types.bracketR);\n          type = this.finishNode(_node2, \"TSIndexedAccessType\");\n        }\n      }\n\n      return type;\n    };\n\n    _proto.tsParseTypeOperator = function tsParseTypeOperator(operator) {\n      var node = this.startNode();\n      this.expectContextual(operator);\n      node.operator = operator;\n      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n      return this.finishNode(node, \"TSTypeOperator\");\n    };\n\n    _proto.tsParseInferType = function tsParseInferType() {\n      var node = this.startNode();\n      this.expectContextual(\"infer\");\n      var typeParameter = this.startNode();\n      typeParameter.name = this.parseIdentifierName(typeParameter.start);\n      node.typeParameter = this.finishNode(typeParameter, \"TypeParameter\");\n      return this.finishNode(node, \"TSInferType\");\n    };\n\n    _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {\n      var _this3 = this;\n\n      var operator = [\"keyof\", \"unique\"].find(function (kw) {\n        return _this3.isContextual(kw);\n      });\n      return operator ? this.tsParseTypeOperator(operator) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n    };\n\n    _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n      this.eat(operator);\n      var type = parseConstituentType();\n\n      if (this.match(operator)) {\n        var types$$1 = [type];\n\n        while (this.eat(operator)) {\n          types$$1.push(parseConstituentType());\n        }\n\n        var node = this.startNodeAtNode(type);\n        node.types = types$$1;\n        type = this.finishNode(node, kind);\n      }\n\n      return type;\n    };\n\n    _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {\n      return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);\n    };\n\n    _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {\n      return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);\n    };\n\n    _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {\n      if (this.isRelational(\"<\")) {\n        return true;\n      }\n\n      return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n    };\n\n    _proto.tsSkipParameterStart = function tsSkipParameterStart() {\n      if (this.match(types.name) || this.match(types._this)) {\n        this.next();\n        return true;\n      }\n\n      return false;\n    };\n\n    _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {\n      this.next();\n\n      if (this.match(types.parenR) || this.match(types.ellipsis)) {\n        return true;\n      }\n\n      if (this.tsSkipParameterStart()) {\n        if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {\n          return true;\n        }\n\n        if (this.match(types.parenR)) {\n          this.next();\n\n          if (this.match(types.arrow)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    };\n\n    _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {\n      var _this4 = this;\n\n      return this.tsInType(function () {\n        var t = _this4.startNode();\n\n        _this4.expect(returnToken);\n\n        var typePredicateVariable = _this4.tsIsIdentifier() && _this4.tsTryParse(_this4.tsParseTypePredicatePrefix.bind(_this4));\n\n        if (!typePredicateVariable) {\n          return _this4.tsParseTypeAnnotation(false, t);\n        }\n\n        var type = _this4.tsParseTypeAnnotation(false);\n\n        var node = _this4.startNodeAtNode(typePredicateVariable);\n\n        node.parameterName = typePredicateVariable;\n        node.typeAnnotation = type;\n        t.typeAnnotation = _this4.finishNode(node, \"TSTypePredicate\");\n        return _this4.finishNode(t, \"TSTypeAnnotation\");\n      });\n    };\n\n    _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {\n      return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;\n    };\n\n    _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {\n      return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;\n    };\n\n    _proto.tsTryParseType = function tsTryParseType() {\n      return this.tsEatThenParseType(types.colon);\n    };\n\n    _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {\n      var id = this.parseIdentifier();\n\n      if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n        this.next();\n        return id;\n      }\n    };\n\n    _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {\n      var _this5 = this;\n\n      if (eatColon === void 0) {\n        eatColon = true;\n      }\n\n      if (t === void 0) {\n        t = this.startNode();\n      }\n\n      this.tsInType(function () {\n        if (eatColon) _this5.expect(types.colon);\n        t.typeAnnotation = _this5.tsParseType();\n      });\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    };\n\n    _proto.tsParseType = function tsParseType() {\n      assert(this.state.inType);\n      var type = this.tsParseNonConditionalType();\n\n      if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {\n        return type;\n      }\n\n      var node = this.startNodeAtNode(type);\n      node.checkType = type;\n      node.extendsType = this.tsParseNonConditionalType();\n      this.expect(types.question);\n      node.trueType = this.tsParseType();\n      this.expect(types.colon);\n      node.falseType = this.tsParseType();\n      return this.finishNode(node, \"TSConditionalType\");\n    };\n\n    _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {\n      if (this.tsIsStartOfFunctionType()) {\n        return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n      }\n\n      if (this.match(types._new)) {\n        return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n      }\n\n      return this.tsParseUnionTypeOrHigher();\n    };\n\n    _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {\n      var _this6 = this;\n\n      var node = this.startNode();\n      node.typeAnnotation = this.tsInType(function () {\n        return _this6.tsParseType();\n      });\n      this.expectRelational(\">\");\n      node.expression = this.parseMaybeUnary();\n      return this.finishNode(node, \"TSTypeAssertion\");\n    };\n\n    _proto.tsTryParseTypeArgumentsInExpression = function tsTryParseTypeArgumentsInExpression() {\n      var _this7 = this;\n\n      return this.tsTryParseAndCatch(function () {\n        var res = _this7.tsParseTypeArguments();\n\n        _this7.expect(types.parenL);\n\n        return res;\n      });\n    };\n\n    _proto.tsParseHeritageClause = function tsParseHeritageClause() {\n      return this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n    };\n\n    _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {\n      var node = this.startNode();\n      node.expression = this.tsParseEntityName(false);\n\n      if (this.isRelational(\"<\")) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    };\n\n    _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node) {\n      node.id = this.parseIdentifier();\n      node.typeParameters = this.tsTryParseTypeParameters();\n\n      if (this.eat(types._extends)) {\n        node.extends = this.tsParseHeritageClause();\n      }\n\n      var body = this.startNode();\n      body.body = this.tsParseObjectTypeMembers();\n      node.body = this.finishNode(body, \"TSInterfaceBody\");\n      return this.finishNode(node, \"TSInterfaceDeclaration\");\n    };\n\n    _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {\n      node.id = this.parseIdentifier();\n      node.typeParameters = this.tsTryParseTypeParameters();\n      node.typeAnnotation = this.tsExpectThenParseType(types.eq);\n      this.semicolon();\n      return this.finishNode(node, \"TSTypeAliasDeclaration\");\n    };\n\n    _proto.tsInType = function tsInType(cb) {\n      var oldInType = this.state.inType;\n      this.state.inType = true;\n\n      try {\n        return cb();\n      } finally {\n        this.state.inType = oldInType;\n      }\n    };\n\n    _proto.tsEatThenParseType = function tsEatThenParseType(token) {\n      return !this.match(token) ? undefined : this.tsNextThenParseType();\n    };\n\n    _proto.tsExpectThenParseType = function tsExpectThenParseType(token) {\n      var _this8 = this;\n\n      return this.tsDoThenParseType(function () {\n        return _this8.expect(token);\n      });\n    };\n\n    _proto.tsNextThenParseType = function tsNextThenParseType() {\n      var _this9 = this;\n\n      return this.tsDoThenParseType(function () {\n        return _this9.next();\n      });\n    };\n\n    _proto.tsDoThenParseType = function tsDoThenParseType(cb) {\n      var _this10 = this;\n\n      return this.tsInType(function () {\n        cb();\n        return _this10.tsParseType();\n      });\n    };\n\n    _proto.tsParseEnumMember = function tsParseEnumMember() {\n      var node = this.startNode();\n      node.id = this.match(types.string) ? this.parseLiteral(this.state.value, \"StringLiteral\") : this.parseIdentifier(true);\n\n      if (this.eat(types.eq)) {\n        node.initializer = this.parseMaybeAssign();\n      }\n\n      return this.finishNode(node, \"TSEnumMember\");\n    };\n\n    _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, isConst) {\n      if (isConst) node.const = true;\n      node.id = this.parseIdentifier();\n      this.expect(types.braceL);\n      node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n      this.expect(types.braceR);\n      return this.finishNode(node, \"TSEnumDeclaration\");\n    };\n\n    _proto.tsParseModuleBlock = function tsParseModuleBlock() {\n      var node = this.startNode();\n      this.expect(types.braceL);\n      this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);\n      return this.finishNode(node, \"TSModuleBlock\");\n    };\n\n    _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node) {\n      node.id = this.parseIdentifier();\n\n      if (this.eat(types.dot)) {\n        var inner = this.startNode();\n        this.tsParseModuleOrNamespaceDeclaration(inner);\n        node.body = inner;\n      } else {\n        node.body = this.tsParseModuleBlock();\n      }\n\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    };\n\n    _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {\n      if (this.isContextual(\"global\")) {\n        node.global = true;\n        node.id = this.parseIdentifier();\n      } else if (this.match(types.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        this.unexpected();\n      }\n\n      if (this.match(types.braceL)) {\n        node.body = this.tsParseModuleBlock();\n      } else {\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    };\n\n    _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, isExport) {\n      node.isExport = isExport || false;\n      node.id = this.parseIdentifier();\n      this.expect(types.eq);\n      node.moduleReference = this.tsParseModuleReference();\n      this.semicolon();\n      return this.finishNode(node, \"TSImportEqualsDeclaration\");\n    };\n\n    _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {\n      return this.isContextual(\"require\") && this.lookahead().type === types.parenL;\n    };\n\n    _proto.tsParseModuleReference = function tsParseModuleReference() {\n      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n    };\n\n    _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {\n      var node = this.startNode();\n      this.expectContextual(\"require\");\n      this.expect(types.parenL);\n\n      if (!this.match(types.string)) {\n        throw this.unexpected();\n      }\n\n      node.expression = this.parseLiteral(this.state.value, \"StringLiteral\");\n      this.expect(types.parenR);\n      return this.finishNode(node, \"TSExternalModuleReference\");\n    };\n\n    _proto.tsLookAhead = function tsLookAhead(f) {\n      var state = this.state.clone();\n      var res = f();\n      this.state = state;\n      return res;\n    };\n\n    _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {\n      var state = this.state.clone();\n\n      try {\n        return f();\n      } catch (e) {\n        if (e instanceof SyntaxError) {\n          this.state = state;\n          return undefined;\n        }\n\n        throw e;\n      }\n    };\n\n    _proto.tsTryParse = function tsTryParse(f) {\n      var state = this.state.clone();\n      var result = f();\n\n      if (result !== undefined && result !== false) {\n        return result;\n      } else {\n        this.state = state;\n        return undefined;\n      }\n    };\n\n    _proto.nodeWithSamePosition = function nodeWithSamePosition(original, type) {\n      var node = this.startNodeAtNode(original);\n      node.type = type;\n      node.end = original.end;\n      node.loc.end = original.loc.end;\n\n      if (original.leadingComments) {\n        node.leadingComments = original.leadingComments;\n      }\n\n      if (original.trailingComments) {\n        node.trailingComments = original.trailingComments;\n      }\n\n      if (original.innerComments) node.innerComments = original.innerComments;\n      return node;\n    };\n\n    _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {\n      switch (this.state.type) {\n        case types._function:\n          this.next();\n          return this.parseFunction(nany, true);\n\n        case types._class:\n          return this.parseClass(nany, true, false);\n\n        case types._const:\n          if (this.match(types._const) && this.isLookaheadContextual(\"enum\")) {\n            this.expect(types._const);\n            this.expectContextual(\"enum\");\n            return this.tsParseEnumDeclaration(nany, true);\n          }\n\n        case types._var:\n        case types._let:\n          return this.parseVarStatement(nany, this.state.type);\n\n        case types.name:\n          {\n            var value = this.state.value;\n\n            if (value === \"global\") {\n              return this.tsParseAmbientExternalModuleDeclaration(nany);\n            } else {\n              return this.tsParseDeclaration(nany, value, true);\n            }\n          }\n      }\n    };\n\n    _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {\n      return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n    };\n\n    _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr) {\n      switch (expr.name) {\n        case \"declare\":\n          {\n            var declaration = this.tsTryParseDeclare(node);\n\n            if (declaration) {\n              declaration.declare = true;\n              return declaration;\n            }\n\n            break;\n          }\n\n        case \"global\":\n          if (this.match(types.braceL)) {\n            var mod = node;\n            mod.global = true;\n            mod.id = expr;\n            mod.body = this.tsParseModuleBlock();\n            return this.finishNode(mod, \"TSModuleDeclaration\");\n          }\n\n          break;\n\n        default:\n          return this.tsParseDeclaration(node, expr.name, false);\n      }\n    };\n\n    _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next) {\n      switch (value) {\n        case \"abstract\":\n          if (next || this.match(types._class)) {\n            var cls = node;\n            cls.abstract = true;\n            if (next) this.next();\n            return this.parseClass(cls, true, false);\n          }\n\n          break;\n\n        case \"enum\":\n          if (next || this.match(types.name)) {\n            if (next) this.next();\n            return this.tsParseEnumDeclaration(node, false);\n          }\n\n          break;\n\n        case \"interface\":\n          if (next || this.match(types.name)) {\n            if (next) this.next();\n            return this.tsParseInterfaceDeclaration(node);\n          }\n\n          break;\n\n        case \"module\":\n          if (next) this.next();\n\n          if (this.match(types.string)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (next || this.match(types.name)) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n\n          break;\n\n        case \"namespace\":\n          if (next || this.match(types.name)) {\n            if (next) this.next();\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n\n          break;\n\n        case \"type\":\n          if (next || this.match(types.name)) {\n            if (next) this.next();\n            return this.tsParseTypeAliasDeclaration(node);\n          }\n\n          break;\n      }\n    };\n\n    _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n      var _this11 = this;\n\n      var res = this.tsTryParseAndCatch(function () {\n        var node = _this11.startNodeAt(startPos, startLoc);\n\n        node.typeParameters = _this11.tsParseTypeParameters();\n\n        _superClass.prototype.parseFunctionParams.call(_this11, node);\n\n        node.returnType = _this11.tsTryParseTypeOrTypePredicateAnnotation();\n\n        _this11.expect(types.arrow);\n\n        return node;\n      });\n\n      if (!res) {\n        return undefined;\n      }\n\n      res.id = null;\n      res.generator = false;\n      res.expression = true;\n      res.async = true;\n      this.parseFunctionBody(res, true);\n      return this.finishNode(res, \"ArrowFunctionExpression\");\n    };\n\n    _proto.tsParseTypeArguments = function tsParseTypeArguments() {\n      var _this12 = this;\n\n      var node = this.startNode();\n      node.params = this.tsInType(function () {\n        _this12.expectRelational(\"<\");\n\n        return _this12.tsParseDelimitedList(\"TypeParametersOrArguments\", _this12.tsParseType.bind(_this12));\n      });\n      this.expectRelational(\">\");\n      return this.finishNode(node, \"TSTypeParameterInstantiation\");\n    };\n\n    _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {\n      if (this.match(types.name)) {\n        switch (this.state.value) {\n          case \"abstract\":\n          case \"declare\":\n          case \"enum\":\n          case \"interface\":\n          case \"module\":\n          case \"namespace\":\n          case \"type\":\n            return true;\n        }\n      }\n\n      return false;\n    };\n\n    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {\n      if (this.tsIsDeclarationStart()) return false;\n      return _superClass.prototype.isExportDefaultSpecifier.call(this);\n    };\n\n    _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {\n      var accessibility;\n      var readonly = false;\n\n      if (allowModifiers) {\n        accessibility = this.parseAccessModifier();\n        readonly = !!this.tsParseModifier([\"readonly\"]);\n      }\n\n      var left = this.parseMaybeDefault();\n      this.parseAssignableListItemTypes(left);\n      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n      if (accessibility || readonly) {\n        var pp = this.startNodeAtNode(elt);\n\n        if (decorators.length) {\n          pp.decorators = decorators;\n        }\n\n        if (accessibility) pp.accessibility = accessibility;\n        if (readonly) pp.readonly = readonly;\n\n        if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n          throw this.raise(pp.start, \"A parameter property may not be declared using a binding pattern.\");\n        }\n\n        pp.parameter = elt;\n        return this.finishNode(pp, \"TSParameterProperty\");\n      } else {\n        if (decorators.length) {\n          left.decorators = decorators;\n        }\n\n        return elt;\n      }\n    };\n\n    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, allowExpressionBody) {\n      if (!allowExpressionBody && this.match(types.colon)) {\n        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n      }\n\n      var bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n      if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {\n        this.finishNode(node, bodilessType);\n        return;\n      }\n\n      _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, allowExpressionBody);\n    };\n\n    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {\n      if (!this.hasPrecedingLineBreak() && this.eat(types.bang)) {\n        var nonNullExpression = this.startNodeAt(startPos, startLoc);\n        nonNullExpression.expression = base;\n        return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n      }\n\n      if (!noCalls && this.isRelational(\"<\")) {\n        if (this.atPossibleAsync(base)) {\n          var asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        var node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        var typeArguments = this.tsTryParseTypeArgumentsInExpression();\n\n        if (typeArguments) {\n          node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n          node.typeParameters = typeArguments;\n          return this.finishCallExpression(node);\n        }\n      }\n\n      return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);\n    };\n\n    _proto.parseNewArguments = function parseNewArguments(node) {\n      var _this13 = this;\n\n      if (this.isRelational(\"<\")) {\n        var typeParameters = this.tsTryParseAndCatch(function () {\n          var args = _this13.tsParseTypeArguments();\n\n          if (!_this13.match(types.parenL)) _this13.unexpected();\n          return args;\n        });\n\n        if (typeParameters) {\n          node.typeParameters = typeParameters;\n        }\n      }\n\n      _superClass.prototype.parseNewArguments.call(this, node);\n    };\n\n    _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n      if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n        var node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.expression = left;\n        node.typeAnnotation = this.tsNextThenParseType();\n        this.finishNode(node, \"TSAsExpression\");\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n\n      return _superClass.prototype.parseExprOp.call(this, left, leftStartPos, leftStartLoc, minPrec, noIn);\n    };\n\n    _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {};\n\n    _proto.checkDuplicateExports = function checkDuplicateExports() {};\n\n    _proto.parseImport = function parseImport(node) {\n      if (this.match(types.name) && this.lookahead().type === types.eq) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n\n      return _superClass.prototype.parseImport.call(this, node);\n    };\n\n    _proto.parseExport = function parseExport(node) {\n      if (this.match(types._import)) {\n        this.expect(types._import);\n        return this.tsParseImportEqualsDeclaration(node, true);\n      } else if (this.eat(types.eq)) {\n        var assign = node;\n        assign.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(assign, \"TSExportAssignment\");\n      } else if (this.eatContextual(\"as\")) {\n        var decl = node;\n        this.expectContextual(\"namespace\");\n        decl.id = this.parseIdentifier();\n        this.semicolon();\n        return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n      } else {\n        return _superClass.prototype.parseExport.call(this, node);\n      }\n    };\n\n    _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {\n      if (this.isContextual(\"abstract\") && this.lookahead().type === types._class) {\n        var cls = this.startNode();\n        this.next();\n        this.parseClass(cls, true, true);\n        cls.abstract = true;\n        return cls;\n      }\n\n      return _superClass.prototype.parseExportDefaultExpression.call(this);\n    };\n\n    _proto.parseStatementContent = function parseStatementContent(declaration, topLevel) {\n      if (this.state.type === types._const) {\n        var ahead = this.lookahead();\n\n        if (ahead.type === types.name && ahead.value === \"enum\") {\n          var node = this.startNode();\n          this.expect(types._const);\n          this.expectContextual(\"enum\");\n          return this.tsParseEnumDeclaration(node, true);\n        }\n      }\n\n      return _superClass.prototype.parseStatementContent.call(this, declaration, topLevel);\n    };\n\n    _proto.parseAccessModifier = function parseAccessModifier() {\n      return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n    };\n\n    _proto.parseClassMember = function parseClassMember(classBody, member, state) {\n      var accessibility = this.parseAccessModifier();\n      if (accessibility) member.accessibility = accessibility;\n\n      _superClass.prototype.parseClassMember.call(this, classBody, member, state);\n    };\n\n    _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n      var methodOrProp = member;\n      var prop = member;\n      var propOrIdx = member;\n      var abstract = false,\n          readonly = false;\n      var mod = this.tsParseModifier([\"abstract\", \"readonly\"]);\n\n      switch (mod) {\n        case \"readonly\":\n          readonly = true;\n          abstract = !!this.tsParseModifier([\"abstract\"]);\n          break;\n\n        case \"abstract\":\n          abstract = true;\n          readonly = !!this.tsParseModifier([\"readonly\"]);\n          break;\n      }\n\n      if (abstract) methodOrProp.abstract = true;\n      if (readonly) propOrIdx.readonly = true;\n\n      if (!abstract && !isStatic && !methodOrProp.accessibility) {\n        var idx = this.tsTryParseIndexSignature(member);\n\n        if (idx) {\n          classBody.body.push(idx);\n          return;\n        }\n      }\n\n      if (readonly) {\n        methodOrProp.static = isStatic;\n        this.parseClassPropertyName(prop);\n        this.parsePostMemberNameModifiers(methodOrProp);\n        this.pushClassProperty(classBody, prop);\n        return;\n      }\n\n      _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic);\n    };\n\n    _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {\n      var optional = this.eat(types.question);\n      if (optional) methodOrProp.optional = true;\n    };\n\n    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {\n      var decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n      return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr);\n    };\n\n    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {\n      if (this.tsIsDeclarationStart()) return true;\n      return _superClass.prototype.shouldParseExportDeclaration.call(this);\n    };\n\n    _proto.parseConditional = function parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n      if (!refNeedsArrowPos || !this.match(types.question)) {\n        return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc, refNeedsArrowPos);\n      }\n\n      var state = this.state.clone();\n\n      try {\n        return _superClass.prototype.parseConditional.call(this, expr, noIn, startPos, startLoc);\n      } catch (err) {\n        if (!(err instanceof SyntaxError)) {\n          throw err;\n        }\n\n        this.state = state;\n        refNeedsArrowPos.start = err.pos || this.state.start;\n        return expr;\n      }\n    };\n\n    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {\n      node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n      }\n\n      if (this.match(types.colon)) {\n        var typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n        return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n      }\n\n      return node;\n    };\n\n    _proto.parseExportDeclaration = function parseExportDeclaration(node) {\n      var isDeclare = this.eatContextual(\"declare\");\n      var declaration;\n\n      if (this.match(types.name)) {\n        declaration = this.tsTryParseExportDeclaration();\n      }\n\n      if (!declaration) {\n        declaration = _superClass.prototype.parseExportDeclaration.call(this, node);\n      }\n\n      if (declaration && isDeclare) {\n        declaration.declare = true;\n      }\n\n      return declaration;\n    };\n\n    _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {\n      var _superClass$prototype;\n\n      if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n        return;\n      }\n\n      (_superClass$prototype = _superClass.prototype.parseClassId).call.apply(_superClass$prototype, [this].concat(Array.prototype.slice.call(arguments)));\n\n      var typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) node.typeParameters = typeParameters;\n    };\n\n    _proto.parseClassProperty = function parseClassProperty(node) {\n      if (!node.optional && this.eat(types.bang)) {\n        node.definite = true;\n      }\n\n      var type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n      return _superClass.prototype.parseClassProperty.call(this, node);\n    };\n\n    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor) {\n      var typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) method.typeParameters = typeParameters;\n\n      _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor);\n    };\n\n    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n      var typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) method.typeParameters = typeParameters;\n\n      _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);\n    };\n\n    _proto.parseClassSuper = function parseClassSuper(node) {\n      _superClass.prototype.parseClassSuper.call(this, node);\n\n      if (node.superClass && this.isRelational(\"<\")) {\n        node.superTypeParameters = this.tsParseTypeArguments();\n      }\n\n      if (this.eatContextual(\"implements\")) {\n        node.implements = this.tsParseHeritageClause();\n      }\n    };\n\n    _proto.parseObjPropValue = function parseObjPropValue(prop) {\n      var _superClass$prototype2;\n\n      if (this.isRelational(\"<\")) {\n        throw new Error(\"TODO\");\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      (_superClass$prototype2 = _superClass.prototype.parseObjPropValue).call.apply(_superClass$prototype2, [this, prop].concat(args));\n    };\n\n    _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {\n      var typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) node.typeParameters = typeParameters;\n\n      _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);\n    };\n\n    _proto.parseVarHead = function parseVarHead(decl) {\n      _superClass.prototype.parseVarHead.call(this, decl);\n\n      if (decl.id.type === \"Identifier\" && this.eat(types.bang)) {\n        decl.definite = true;\n      }\n\n      var type = this.tsTryParseTypeAnnotation();\n\n      if (type) {\n        decl.id.typeAnnotation = type;\n        this.finishNode(decl.id, decl.id.type);\n      }\n    };\n\n    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {\n      if (this.match(types.colon)) {\n        node.returnType = this.tsParseTypeAnnotation();\n      }\n\n      return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);\n    };\n\n    _proto.parseMaybeAssign = function parseMaybeAssign() {\n      var jsxError;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      if (this.match(types.jsxTagStart)) {\n        var context = this.curContext();\n        assert(context === types$1.j_oTag);\n        assert(this.state.context[this.state.context.length - 2] === types$1.j_expr);\n\n        var _state = this.state.clone();\n\n        try {\n          var _superClass$prototype3;\n\n          return (_superClass$prototype3 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype3, [this].concat(args));\n        } catch (err) {\n          if (!(err instanceof SyntaxError)) {\n            throw err;\n          }\n\n          this.state = _state;\n          assert(this.curContext() === types$1.j_oTag);\n          this.state.context.pop();\n          assert(this.curContext() === types$1.j_expr);\n          this.state.context.pop();\n          jsxError = err;\n        }\n      }\n\n      if (jsxError === undefined && !this.isRelational(\"<\")) {\n        var _superClass$prototype4;\n\n        return (_superClass$prototype4 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype4, [this].concat(args));\n      }\n\n      var arrowExpression;\n      var typeParameters;\n      var state = this.state.clone();\n\n      try {\n        var _superClass$prototype5;\n\n        typeParameters = this.tsParseTypeParameters();\n        arrowExpression = (_superClass$prototype5 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype5, [this].concat(args));\n\n        if (arrowExpression.type !== \"ArrowFunctionExpression\") {\n          this.unexpected();\n        }\n      } catch (err) {\n        var _superClass$prototype6;\n\n        if (!(err instanceof SyntaxError)) {\n          throw err;\n        }\n\n        if (jsxError) {\n          throw jsxError;\n        }\n\n        assert(!this.hasPlugin(\"jsx\"));\n        this.state = state;\n        return (_superClass$prototype6 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype6, [this].concat(args));\n      }\n\n      if (typeParameters && typeParameters.params.length !== 0) {\n        this.resetStartLocationFromNode(arrowExpression, typeParameters.params[0]);\n      }\n\n      arrowExpression.typeParameters = typeParameters;\n      return arrowExpression;\n    };\n\n    _proto.parseMaybeUnary = function parseMaybeUnary(refShorthandDefaultPos) {\n      if (!this.hasPlugin(\"jsx\") && this.eatRelational(\"<\")) {\n        return this.tsParseTypeAssertion();\n      } else {\n        return _superClass.prototype.parseMaybeUnary.call(this, refShorthandDefaultPos);\n      }\n    };\n\n    _proto.parseArrow = function parseArrow(node) {\n      if (this.match(types.colon)) {\n        var state = this.state.clone();\n\n        try {\n          var returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(types.arrow)) this.unexpected();\n          node.returnType = returnType;\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            this.state = state;\n          } else {\n            throw err;\n          }\n        }\n      }\n\n      return _superClass.prototype.parseArrow.call(this, node);\n    };\n\n    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {\n      if (this.eat(types.question)) {\n        if (param.type !== \"Identifier\") {\n          throw this.raise(param.start, \"A binding pattern parameter cannot be optional in an implementation signature.\");\n        }\n\n        param.optional = true;\n      }\n\n      var type = this.tsTryParseTypeAnnotation();\n      if (type) param.typeAnnotation = type;\n      return this.finishNode(param, param.type);\n    };\n\n    _proto.toAssignable = function toAssignable(node, isBinding, contextDescription) {\n      switch (node.type) {\n        case \"TSTypeCastExpression\":\n          return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isBinding, contextDescription);\n\n        case \"TSParameterProperty\":\n          return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);\n\n        case \"TSAsExpression\":\n          node.expression = this.toAssignable(node.expression, isBinding, contextDescription);\n          return node;\n\n        default:\n          return _superClass.prototype.toAssignable.call(this, node, isBinding, contextDescription);\n      }\n    };\n\n    _proto.checkLVal = function checkLVal(expr, isBinding, checkClashes, contextDescription) {\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          return;\n\n        case \"TSParameterProperty\":\n          this.checkLVal(expr.parameter, isBinding, checkClashes, \"parameter property\");\n          return;\n\n        case \"TSAsExpression\":\n          this.checkLVal(expr.expression, isBinding, checkClashes, contextDescription);\n          return;\n\n        default:\n          _superClass.prototype.checkLVal.call(this, expr, isBinding, checkClashes, contextDescription);\n\n          return;\n      }\n    };\n\n    _proto.parseBindingAtom = function parseBindingAtom() {\n      switch (this.state.type) {\n        case types._this:\n          return this.parseIdentifier(true);\n\n        default:\n          return _superClass.prototype.parseBindingAtom.call(this);\n      }\n    };\n\n    _proto.isClassMethod = function isClassMethod() {\n      return this.isRelational(\"<\") || _superClass.prototype.isClassMethod.call(this);\n    };\n\n    _proto.isClassProperty = function isClassProperty() {\n      return this.match(types.bang) || this.match(types.colon) || _superClass.prototype.isClassProperty.call(this);\n    };\n\n    _proto.parseMaybeDefault = function parseMaybeDefault() {\n      var _superClass$prototype7;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      var node = (_superClass$prototype7 = _superClass.prototype.parseMaybeDefault).call.apply(_superClass$prototype7, [this].concat(args));\n\n      if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n        this.raise(node.typeAnnotation.start, \"Type annotations must come before default assignments, \" + \"e.g. instead of `age = 25: number` use `age: number = 25`\");\n      }\n\n      return node;\n    };\n\n    _proto.readToken = function readToken(code) {\n      if (this.state.inType && (code === 62 || code === 60)) {\n        return this.finishOp(types.relational, 1);\n      } else {\n        return _superClass.prototype.readToken.call(this, code);\n      }\n    };\n\n    _proto.toAssignableList = function toAssignableList(exprList, isBinding, contextDescription) {\n      for (var i = 0; i < exprList.length; i++) {\n        var expr = exprList[i];\n\n        if (expr && expr.type === \"TSTypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n\n      return _superClass.prototype.toAssignableList.call(this, exprList, isBinding, contextDescription);\n    };\n\n    _proto.typeCastToParameter = function typeCastToParameter(node) {\n      node.expression.typeAnnotation = node.typeAnnotation;\n      return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    };\n\n    _proto.toReferencedList = function toReferencedList(exprList) {\n      for (var i = 0; i < exprList.length; i++) {\n        var expr = exprList[i];\n\n        if (expr && expr._exprListItem && expr.type === \"TsTypeCastExpression\") {\n          this.raise(expr.start, \"Did not expect a type annotation here.\");\n        }\n      }\n\n      return exprList;\n    };\n\n    _proto.shouldParseArrow = function shouldParseArrow() {\n      return this.match(types.colon) || _superClass.prototype.shouldParseArrow.call(this);\n    };\n\n    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {\n      return this.match(types.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);\n    };\n\n    return _class;\n  }(superClass);\n});\n\nplugins.estree = estreePlugin;\nplugins.flow = flowPlugin;\nplugins.jsx = jsxPlugin;\nplugins.typescript = typescriptPlugin;\nfunction parse(input, options) {\n  if (options && options.sourceType === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      var parser = getParser(options, input);\n      var ast = parser.parse();\n      if (!parser.sawUnambiguousESM) ast.program.sourceType = \"script\";\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (scriptError) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  var parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\nfunction getParser(options, input) {\n  var cls = options && options.plugins ? getParserClass(options.plugins) : Parser;\n  return new cls(options, input);\n}\n\nvar parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  if (pluginsFromOptions.indexOf(\"decorators\") >= 0 && pluginsFromOptions.indexOf(\"decorators2\") >= 0) {\n    throw new Error(\"Cannot use decorators and decorators2 plugin together\");\n  }\n\n  var pluginList = pluginsFromOptions.filter(function (p) {\n    return p === \"estree\" || p === \"flow\" || p === \"jsx\" || p === \"typescript\";\n  });\n\n  if (pluginList.indexOf(\"flow\") >= 0) {\n    pluginList = pluginList.filter(function (plugin) {\n      return plugin !== \"flow\";\n    });\n    pluginList.push(\"flow\");\n  }\n\n  if (pluginList.indexOf(\"flow\") >= 0 && pluginList.indexOf(\"typescript\") >= 0) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (pluginList.indexOf(\"typescript\") >= 0) {\n    pluginList = pluginList.filter(function (plugin) {\n      return plugin !== \"typescript\";\n    });\n    pluginList.push(\"typescript\");\n  }\n\n  if (pluginList.indexOf(\"estree\") >= 0) {\n    pluginList = pluginList.filter(function (plugin) {\n      return plugin !== \"estree\";\n    });\n    pluginList.unshift(\"estree\");\n  }\n\n  var key = pluginList.join(\"/\");\n  var cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (var _i2 = 0, _pluginList2 = pluginList; _i2 < _pluginList2.length; _i2++) {\n      var plugin = _pluginList2[_i2];\n      cls = plugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n","'use strict';\nvar escapeStringRegexp = require('escape-string-regexp');\nvar ansiStyles = require('ansi-styles');\nvar stripAnsi = require('strip-ansi');\nvar hasAnsi = require('has-ansi');\nvar supportsColor = require('supports-color');\nvar defineProps = Object.defineProperties;\nvar isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);\n\nfunction Chalk(options) {\n\t// detect mode if not set manually\n\tthis.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;\n}\n\n// use bright blue on Windows as the normal blue color is illegible\nif (isSimpleWindowsTerm) {\n\tansiStyles.blue.open = '\\u001b[94m';\n}\n\nvar styles = (function () {\n\tvar ret = {};\n\n\tObject.keys(ansiStyles).forEach(function (key) {\n\t\tansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n\n\t\tret[key] = {\n\t\t\tget: function () {\n\t\t\t\treturn build.call(this, this._styles.concat(key));\n\t\t\t}\n\t\t};\n\t});\n\n\treturn ret;\n})();\n\nvar proto = defineProps(function chalk() {}, styles);\n\nfunction build(_styles) {\n\tvar builder = function () {\n\t\treturn applyStyle.apply(builder, arguments);\n\t};\n\n\tbuilder._styles = _styles;\n\tbuilder.enabled = this.enabled;\n\t// __proto__ is used because we must return a function, but there is\n\t// no way to create a function with a different prototype.\n\t/* eslint-disable no-proto */\n\tbuilder.__proto__ = proto;\n\n\treturn builder;\n}\n\nfunction applyStyle() {\n\t// support varags, but simply cast to string in case there's only one arg\n\tvar args = arguments;\n\tvar argsLen = args.length;\n\tvar str = argsLen !== 0 && String(arguments[0]);\n\n\tif (argsLen > 1) {\n\t\t// don't slice `arguments`, it prevents v8 optimizations\n\t\tfor (var a = 1; a < argsLen; a++) {\n\t\t\tstr += ' ' + args[a];\n\t\t}\n\t}\n\n\tif (!this.enabled || !str) {\n\t\treturn str;\n\t}\n\n\tvar nestedStyles = this._styles;\n\tvar i = nestedStyles.length;\n\n\t// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n\t// see https://github.com/chalk/chalk/issues/58\n\t// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\n\tvar originalDim = ansiStyles.dim.open;\n\tif (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {\n\t\tansiStyles.dim.open = '';\n\t}\n\n\twhile (i--) {\n\t\tvar code = ansiStyles[nestedStyles[i]];\n\n\t\t// Replace any instances already present with a re-opening code\n\t\t// otherwise only the part of the string until said closing code\n\t\t// will be colored, and the rest will simply be 'plain'.\n\t\tstr = code.open + str.replace(code.closeRe, code.open) + code.close;\n\t}\n\n\t// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.\n\tansiStyles.dim.open = originalDim;\n\n\treturn str;\n}\n\nfunction init() {\n\tvar ret = {};\n\n\tObject.keys(styles).forEach(function (name) {\n\t\tret[name] = {\n\t\t\tget: function () {\n\t\t\t\treturn build.call(this, [name]);\n\t\t\t}\n\t\t};\n\t});\n\n\treturn ret;\n}\n\ndefineProps(Chalk.prototype, init());\n\nmodule.exports = new Chalk();\nmodule.exports.styles = ansiStyles;\nmodule.exports.hasColor = hasAnsi;\nmodule.exports.stripColor = stripAnsi;\nmodule.exports.supportsColor = supportsColor;\n","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.get-iterator');\n","var core = require('../../modules/_core');\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n","require('../../modules/es6.number.max-safe-integer');\nmodule.exports = 0x1fffffffffffff;\n","require('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n","require('../../modules/es6.symbol');\nmodule.exports = require('../../modules/_core').Object.getOwnPropertySymbols;\n","require('../../modules/es6.object.keys');\nmodule.exports = require('../../modules/_core').Object.keys;\n","require('../../modules/es6.symbol');\nmodule.exports = require('../../modules/_core').Symbol['for'];\n","require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n","require('../../modules/es6.string.iterator');\nrequire('../../modules/web.dom.iterable');\nmodule.exports = require('../../modules/_wks-ext').f('iterator');\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","module.exports = function () { /* empty */ };\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var core = module.exports = { version: '2.5.3' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar ctx = require('./_ctx');\nvar hide = require('./_hide');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && key in exports) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = (!BUGGY && $native) || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","module.exports = {};\n","module.exports = true;\n","var META = require('./_uid')('meta');\nvar isObject = require('./_is-object');\nvar has = require('./_has');\nvar setDesc = require('./_object-dp').f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !require('./_fails')(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","var pIE = require('./_object-pie');\nvar createDesc = require('./_property-desc');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar has = require('./_has');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject');\nvar gOPN = require('./_object-gopn').f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = require('./_object-keys-internal');\nvar hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n","exports.f = Object.getOwnPropertySymbols;\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","exports.f = {}.propertyIsEnumerable;\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","module.exports = require('./_hide');\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar LIBRARY = require('./_library');\nvar wksExt = require('./_wks-ext');\nvar defineProperty = require('./_object-dp').f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n","exports.f = require('./_wks');\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","var anObject = require('./_an-object');\nvar get = require('./core.get-iterator-method');\nmodule.exports = require('./_core').getIterator = function (it) {\n  var iterFn = get(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });\n","var $export = require('./_export');\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: require('./_object-create') });\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","'use strict';\nvar $at = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n","'use strict';\n// ECMAScript 6 symbols shim\nvar global = require('./_global');\nvar has = require('./_has');\nvar DESCRIPTORS = require('./_descriptors');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar META = require('./_meta').KEY;\nvar $fails = require('./_fails');\nvar shared = require('./_shared');\nvar setToStringTag = require('./_set-to-string-tag');\nvar uid = require('./_uid');\nvar wks = require('./_wks');\nvar wksExt = require('./_wks-ext');\nvar wksDefine = require('./_wks-define');\nvar enumKeys = require('./_enum-keys');\nvar isArray = require('./_is-array');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar createDesc = require('./_property-desc');\nvar _create = require('./_object-create');\nvar gOPNExt = require('./_object-gopn-ext');\nvar $GOPD = require('./_object-gopd');\nvar $DP = require('./_object-dp');\nvar $keys = require('./_object-keys');\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !require('./_library')) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n","require('./_wks-define')('asyncIterator');\n","require('./_wks-define')('observable');\n","require('./es6.array.iterator');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar TO_STRING_TAG = require('./_wks')('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n    return Array.isArray(val) ? [] : {}\n}\n\nfunction cloneIfNecessary(value, optionsArgument) {\n    var clone = optionsArgument && optionsArgument.clone === true;\n    return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value\n}\n\nfunction defaultArrayMerge(target, source, optionsArgument) {\n    var destination = target.slice();\n    source.forEach(function(e, i) {\n        if (typeof destination[i] === 'undefined') {\n            destination[i] = cloneIfNecessary(e, optionsArgument);\n        } else if (isMergeableObject(e)) {\n            destination[i] = deepmerge(target[i], e, optionsArgument);\n        } else if (target.indexOf(e) === -1) {\n            destination.push(cloneIfNecessary(e, optionsArgument));\n        }\n    });\n    return destination\n}\n\nfunction mergeObject(target, source, optionsArgument) {\n    var destination = {};\n    if (isMergeableObject(target)) {\n        Object.keys(target).forEach(function(key) {\n            destination[key] = cloneIfNecessary(target[key], optionsArgument);\n        });\n    }\n    Object.keys(source).forEach(function(key) {\n        if (!isMergeableObject(source[key]) || !target[key]) {\n            destination[key] = cloneIfNecessary(source[key], optionsArgument);\n        } else {\n            destination[key] = deepmerge(target[key], source[key], optionsArgument);\n        }\n    });\n    return destination\n}\n\nfunction deepmerge(target, source, optionsArgument) {\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var options = optionsArgument || { arrayMerge: defaultArrayMerge };\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n    if (!sourceAndTargetTypesMatch) {\n        return cloneIfNecessary(source, optionsArgument)\n    } else if (sourceIsArray) {\n        var arrayMerge = options.arrayMerge || defaultArrayMerge;\n        return arrayMerge(target, source, optionsArgument)\n    } else {\n        return mergeObject(target, source, optionsArgument)\n    }\n}\n\ndeepmerge.all = function deepmergeAll(array, optionsArgument) {\n    if (!Array.isArray(array) || array.length < 2) {\n        throw new Error('first argument should be an array with at least two elements')\n    }\n\n    // we are sure there are at least 2 values, so it is safe to have no initial value\n    return array.reduce(function(prev, next) {\n        return deepmerge(prev, next, optionsArgument)\n    })\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n","/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    function isExpression(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'ArrayExpression':\n            case 'AssignmentExpression':\n            case 'BinaryExpression':\n            case 'CallExpression':\n            case 'ConditionalExpression':\n            case 'FunctionExpression':\n            case 'Identifier':\n            case 'Literal':\n            case 'LogicalExpression':\n            case 'MemberExpression':\n            case 'NewExpression':\n            case 'ObjectExpression':\n            case 'SequenceExpression':\n            case 'ThisExpression':\n            case 'UnaryExpression':\n            case 'UpdateExpression':\n                return true;\n        }\n        return false;\n    }\n\n    function isIterationStatement(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'DoWhileStatement':\n            case 'ForInStatement':\n            case 'ForStatement':\n            case 'WhileStatement':\n                return true;\n        }\n        return false;\n    }\n\n    function isStatement(node) {\n        if (node == null) { return false; }\n        switch (node.type) {\n            case 'BlockStatement':\n            case 'BreakStatement':\n            case 'ContinueStatement':\n            case 'DebuggerStatement':\n            case 'DoWhileStatement':\n            case 'EmptyStatement':\n            case 'ExpressionStatement':\n            case 'ForInStatement':\n            case 'ForStatement':\n            case 'IfStatement':\n            case 'LabeledStatement':\n            case 'ReturnStatement':\n            case 'SwitchStatement':\n            case 'ThrowStatement':\n            case 'TryStatement':\n            case 'VariableDeclaration':\n            case 'WhileStatement':\n            case 'WithStatement':\n                return true;\n        }\n        return false;\n    }\n\n    function isSourceElement(node) {\n      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';\n    }\n\n    function trailingStatement(node) {\n        switch (node.type) {\n        case 'IfStatement':\n            if (node.alternate != null) {\n                return node.alternate;\n            }\n            return node.consequent;\n\n        case 'LabeledStatement':\n        case 'ForStatement':\n        case 'ForInStatement':\n        case 'WhileStatement':\n        case 'WithStatement':\n            return node.body;\n        }\n        return null;\n    }\n\n    function isProblematicIfStatement(node) {\n        var current;\n\n        if (node.type !== 'IfStatement') {\n            return false;\n        }\n        if (node.alternate == null) {\n            return false;\n        }\n        current = node.consequent;\n        do {\n            if (current.type === 'IfStatement') {\n                if (current.alternate == null)  {\n                    return true;\n                }\n            }\n            current = trailingStatement(current);\n        } while (current);\n\n        return false;\n    }\n\n    module.exports = {\n        isExpression: isExpression,\n        isStatement: isStatement,\n        isIterationStatement: isIterationStatement,\n        isSourceElement: isSourceElement,\n        isProblematicIfStatement: isProblematicIfStatement,\n\n        trailingStatement: trailingStatement\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;\n\n    // See `tools/generate-identifier-regex.js`.\n    ES5Regex = {\n        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/\n    };\n\n    ES6Regex = {\n        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/,\n        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDD0-\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF01-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n    };\n\n    function isDecimalDigit(ch) {\n        return 0x30 <= ch && ch <= 0x39;  // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return 0x30 <= ch && ch <= 0x39 ||  // 0..9\n            0x61 <= ch && ch <= 0x66 ||     // a..f\n            0x41 <= ch && ch <= 0x46;       // A..F\n    }\n\n    function isOctalDigit(ch) {\n        return ch >= 0x30 && ch <= 0x37;  // 0..7\n    }\n\n    // 7.2 White Space\n\n    NON_ASCII_WHITESPACES = [\n        0x1680, 0x180E,\n        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,\n        0x202F, 0x205F,\n        0x3000,\n        0xFEFF\n    ];\n\n    function isWhiteSpace(ch) {\n        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||\n            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function fromCodePoint(cp) {\n        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }\n        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);\n        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);\n        return cu1 + cu2;\n    }\n\n    IDENTIFIER_START = new Array(0x80);\n    for(ch = 0; ch < 0x80; ++ch) {\n        IDENTIFIER_START[ch] =\n            ch >= 0x61 && ch <= 0x7A ||  // a..z\n            ch >= 0x41 && ch <= 0x5A ||  // A..Z\n            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)\n    }\n\n    IDENTIFIER_PART = new Array(0x80);\n    for(ch = 0; ch < 0x80; ++ch) {\n        IDENTIFIER_PART[ch] =\n            ch >= 0x61 && ch <= 0x7A ||  // a..z\n            ch >= 0x41 && ch <= 0x5A ||  // A..Z\n            ch >= 0x30 && ch <= 0x39 ||  // 0..9\n            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)\n    }\n\n    function isIdentifierStartES5(ch) {\n        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n    }\n\n    function isIdentifierPartES5(ch) {\n        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n    }\n\n    function isIdentifierStartES6(ch) {\n        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n    }\n\n    function isIdentifierPartES6(ch) {\n        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n    }\n\n    module.exports = {\n        isDecimalDigit: isDecimalDigit,\n        isHexDigit: isHexDigit,\n        isOctalDigit: isOctalDigit,\n        isWhiteSpace: isWhiteSpace,\n        isLineTerminator: isLineTerminator,\n        isIdentifierStartES5: isIdentifierStartES5,\n        isIdentifierPartES5: isIdentifierPartES5,\n        isIdentifierStartES6: isIdentifierStartES6,\n        isIdentifierPartES6: isIdentifierPartES6\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function () {\n    'use strict';\n\n    var code = require('./code');\n\n    function isStrictModeReservedWordES6(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isKeywordES5(id, strict) {\n        // yield should not be treated as keyword under non-strict mode.\n        if (!strict && id === 'yield') {\n            return false;\n        }\n        return isKeywordES6(id, strict);\n    }\n\n    function isKeywordES6(id, strict) {\n        if (strict && isStrictModeReservedWordES6(id)) {\n            return true;\n        }\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    function isReservedWordES5(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);\n    }\n\n    function isReservedWordES6(id, strict) {\n        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    function isIdentifierNameES5(id) {\n        var i, iz, ch;\n\n        if (id.length === 0) { return false; }\n\n        ch = id.charCodeAt(0);\n        if (!code.isIdentifierStartES5(ch)) {\n            return false;\n        }\n\n        for (i = 1, iz = id.length; i < iz; ++i) {\n            ch = id.charCodeAt(i);\n            if (!code.isIdentifierPartES5(ch)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function decodeUtf16(lead, trail) {\n        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n    }\n\n    function isIdentifierNameES6(id) {\n        var i, iz, ch, lowCh, check;\n\n        if (id.length === 0) { return false; }\n\n        check = code.isIdentifierStartES6;\n        for (i = 0, iz = id.length; i < iz; ++i) {\n            ch = id.charCodeAt(i);\n            if (0xD800 <= ch && ch <= 0xDBFF) {\n                ++i;\n                if (i >= iz) { return false; }\n                lowCh = id.charCodeAt(i);\n                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {\n                    return false;\n                }\n                ch = decodeUtf16(ch, lowCh);\n            }\n            if (!check(ch)) {\n                return false;\n            }\n            check = code.isIdentifierPartES6;\n        }\n        return true;\n    }\n\n    function isIdentifierES5(id, strict) {\n        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);\n    }\n\n    function isIdentifierES6(id, strict) {\n        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);\n    }\n\n    module.exports = {\n        isKeywordES5: isKeywordES5,\n        isKeywordES6: isKeywordES6,\n        isReservedWordES5: isReservedWordES5,\n        isReservedWordES6: isReservedWordES6,\n        isRestrictedWord: isRestrictedWord,\n        isIdentifierNameES5: isIdentifierNameES5,\n        isIdentifierNameES6: isIdentifierNameES6,\n        isIdentifierES5: isIdentifierES5,\n        isIdentifierES6: isIdentifierES6\n    };\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n","/*\n  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n(function () {\n    'use strict';\n\n    exports.ast = require('./ast');\n    exports.code = require('./code');\n    exports.keyword = require('./keyword');\n}());\n/* vim: set sw=4 ts=4 et tw=80 : */\n","module.exports = require('./globals.json');\n","'use strict';\nvar ansiRegex = require('ansi-regex');\nvar re = new RegExp(ansiRegex().source); // remove the `g` flag\nmodule.exports = re.test.bind(re);\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","'use strict';\n/* eslint-disable yoda */\nmodule.exports = x => {\n\tif (Number.isNaN(x)) {\n\t\treturn false;\n\t}\n\n\t// code points are derived from:\n\t// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n\tif (\n\t\tx >= 0x1100 && (\n\t\t\tx <= 0x115f ||  // Hangul Jamo\n\t\t\tx === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n\t\t\tx === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n\t\t\t// CJK Radicals Supplement .. Enclosed CJK Letters and Months\n\t\t\t(0x2e80 <= x && x <= 0x3247 && x !== 0x303f) ||\n\t\t\t// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n\t\t\t(0x3250 <= x && x <= 0x4dbf) ||\n\t\t\t// CJK Unified Ideographs .. Yi Radicals\n\t\t\t(0x4e00 <= x && x <= 0xa4c6) ||\n\t\t\t// Hangul Jamo Extended-A\n\t\t\t(0xa960 <= x && x <= 0xa97c) ||\n\t\t\t// Hangul Syllables\n\t\t\t(0xac00 <= x && x <= 0xd7a3) ||\n\t\t\t// CJK Compatibility Ideographs\n\t\t\t(0xf900 <= x && x <= 0xfaff) ||\n\t\t\t// Vertical Forms\n\t\t\t(0xfe10 <= x && x <= 0xfe19) ||\n\t\t\t// CJK Compatibility Forms .. Small Form Variants\n\t\t\t(0xfe30 <= x && x <= 0xfe6b) ||\n\t\t\t// Halfwidth and Fullwidth Forms\n\t\t\t(0xff01 <= x && x <= 0xff60) ||\n\t\t\t(0xffe0 <= x && x <= 0xffe6) ||\n\t\t\t// Kana Supplement\n\t\t\t(0x1b000 <= x && x <= 0x1b001) ||\n\t\t\t// Enclosed Ideographic Supplement\n\t\t\t(0x1f200 <= x && x <= 0x1f251) ||\n\t\t\t// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n\t\t\t(0x20000 <= x && x <= 0x3fffd)\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n","// Copyright 2014, 2015, 2016, 2017 Simon Lydell\n// License: MIT. (See LICENSE.)\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n})\n\n// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nexports.default = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyu]{1,5}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g\n\nexports.matchToToken = function(match) {\n  var token = {type: \"invalid\", value: match[0]}\n       if (match[ 1]) token.type = \"string\" , token.closed = !!(match[3] || match[4])\n  else if (match[ 5]) token.type = \"comment\"\n  else if (match[ 6]) token.type = \"comment\", token.closed = !!match[7]\n  else if (match[ 8]) token.type = \"regex\"\n  else if (match[ 9]) token.type = \"number\"\n  else if (match[10]) token.type = \"name\"\n  else if (match[11]) token.type = \"punctuator\"\n  else if (match[12]) token.type = \"whitespace\"\n  return token\n}\n","/*! https://mths.be/jsesc v1.3.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar forOwn = function(object, callback) {\n\t\tvar key;\n\t\tfor (key in object) {\n\t\t\tif (hasOwnProperty.call(object, key)) {\n\t\t\t\tcallback(key, object[key]);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar extend = function(destination, source) {\n\t\tif (!source) {\n\t\t\treturn destination;\n\t\t}\n\t\tforOwn(source, function(key, value) {\n\t\t\tdestination[key] = value;\n\t\t});\n\t\treturn destination;\n\t};\n\n\tvar forEach = function(array, callback) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\twhile (++index < length) {\n\t\t\tcallback(array[index]);\n\t\t}\n\t};\n\n\tvar toString = object.toString;\n\tvar isArray = function(value) {\n\t\treturn toString.call(value) == '[object Array]';\n\t};\n\tvar isObject = function(value) {\n\t\t// This is a very simple check, but it’s good enough for what we need.\n\t\treturn toString.call(value) == '[object Object]';\n\t};\n\tvar isString = function(value) {\n\t\treturn typeof value == 'string' ||\n\t\t\ttoString.call(value) == '[object String]';\n\t};\n\tvar isNumber = function(value) {\n\t\treturn typeof value == 'number' ||\n\t\t\ttoString.call(value) == '[object Number]';\n\t};\n\tvar isFunction = function(value) {\n\t\t// In a perfect world, the `typeof` check would be sufficient. However,\n\t\t// in Chrome 1–12, `typeof /x/ == 'object'`, and in IE 6–8\n\t\t// `typeof alert == 'object'` and similar for other host objects.\n\t\treturn typeof value == 'function' ||\n\t\t\ttoString.call(value) == '[object Function]';\n\t};\n\tvar isMap = function(value) {\n\t\treturn toString.call(value) == '[object Map]';\n\t};\n\tvar isSet = function(value) {\n\t\treturn toString.call(value) == '[object Set]';\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// https://mathiasbynens.be/notes/javascript-escapes#single\n\tvar singleEscapes = {\n\t\t'\"': '\\\\\"',\n\t\t'\\'': '\\\\\\'',\n\t\t'\\\\': '\\\\\\\\',\n\t\t'\\b': '\\\\b',\n\t\t'\\f': '\\\\f',\n\t\t'\\n': '\\\\n',\n\t\t'\\r': '\\\\r',\n\t\t'\\t': '\\\\t'\n\t\t// `\\v` is omitted intentionally, because in IE < 9, '\\v' == 'v'.\n\t\t// '\\v': '\\\\x0B'\n\t};\n\tvar regexSingleEscape = /[\"'\\\\\\b\\f\\n\\r\\t]/;\n\n\tvar regexDigit = /[0-9]/;\n\tvar regexWhitelist = /[ !#-&\\(-\\[\\]-~]/;\n\n\tvar jsesc = function(argument, options) {\n\t\t// Handle options\n\t\tvar defaults = {\n\t\t\t'escapeEverything': false,\n\t\t\t'escapeEtago': false,\n\t\t\t'quotes': 'single',\n\t\t\t'wrap': false,\n\t\t\t'es6': false,\n\t\t\t'json': false,\n\t\t\t'compact': true,\n\t\t\t'lowercaseHex': false,\n\t\t\t'numbers': 'decimal',\n\t\t\t'indent': '\\t',\n\t\t\t'__indent__': '',\n\t\t\t'__inline1__': false,\n\t\t\t'__inline2__': false\n\t\t};\n\t\tvar json = options && options.json;\n\t\tif (json) {\n\t\t\tdefaults.quotes = 'double';\n\t\t\tdefaults.wrap = true;\n\t\t}\n\t\toptions = extend(defaults, options);\n\t\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\t\toptions.quotes = 'single';\n\t\t}\n\t\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\t\tvar compact = options.compact;\n\t\tvar indent = options.indent;\n\t\tvar lowercaseHex = options.lowercaseHex;\n\t\tvar oldIndent = '';\n\t\tvar inline1 = options.__inline1__;\n\t\tvar inline2 = options.__inline2__;\n\t\tvar newLine = compact ? '' : '\\n';\n\t\tvar result;\n\t\tvar isEmpty = true;\n\t\tvar useBinNumbers = options.numbers == 'binary';\n\t\tvar useOctNumbers = options.numbers == 'octal';\n\t\tvar useDecNumbers = options.numbers == 'decimal';\n\t\tvar useHexNumbers = options.numbers == 'hexadecimal';\n\n\t\tif (json && argument && isFunction(argument.toJSON)) {\n\t\t\targument = argument.toJSON();\n\t\t}\n\n\t\tif (!isString(argument)) {\n\t\t\tif (isMap(argument)) {\n\t\t\t\tif (argument.size == 0) {\n\t\t\t\t\treturn 'new Map()';\n\t\t\t\t}\n\t\t\t\tif (!compact) {\n\t\t\t\t\toptions.__inline1__ = true;\n\t\t\t\t}\n\t\t\t\treturn 'new Map(' + jsesc(Array.from(argument), options) + ')';\n\t\t\t}\n\t\t\tif (isSet(argument)) {\n\t\t\t\tif (argument.size == 0) {\n\t\t\t\t\treturn 'new Set()';\n\t\t\t\t}\n\t\t\t\treturn 'new Set(' + jsesc(Array.from(argument), options) + ')';\n\t\t\t}\n\t\t\tif (isArray(argument)) {\n\t\t\t\tresult = [];\n\t\t\t\toptions.wrap = true;\n\t\t\t\tif (inline1) {\n\t\t\t\t\toptions.__inline1__ = false;\n\t\t\t\t\toptions.__inline2__ = true;\n\t\t\t\t} else {\n\t\t\t\t\toldIndent = options.__indent__;\n\t\t\t\t\tindent += oldIndent;\n\t\t\t\t\toptions.__indent__ = indent;\n\t\t\t\t}\n\t\t\t\tforEach(argument, function(value) {\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tif (inline2) {\n\t\t\t\t\t\toptions.__inline2__ = false;\n\t\t\t\t\t}\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\t(compact || inline2 ? '' : indent) +\n\t\t\t\t\t\tjsesc(value, options)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tif (isEmpty) {\n\t\t\t\t\treturn '[]';\n\t\t\t\t}\n\t\t\t\tif (inline2) {\n\t\t\t\t\treturn '[' + result.join(', ') + ']';\n\t\t\t\t}\n\t\t\t\treturn '[' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t\t(compact ? '' : oldIndent) + ']';\n\t\t\t} else if (isNumber(argument)) {\n\t\t\t\tif (json) {\n\t\t\t\t\t// Some number values (e.g. `Infinity`) cannot be represented in JSON.\n\t\t\t\t\treturn JSON.stringify(argument);\n\t\t\t\t}\n\t\t\t\tif (useDecNumbers) {\n\t\t\t\t\treturn String(argument);\n\t\t\t\t}\n\t\t\t\tif (useHexNumbers) {\n\t\t\t\t\tvar tmp = argument.toString(16);\n\t\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\t\ttmp = tmp.toUpperCase();\n\t\t\t\t\t}\n\t\t\t\t\treturn '0x' + tmp;\n\t\t\t\t}\n\t\t\t\tif (useBinNumbers) {\n\t\t\t\t\treturn '0b' + argument.toString(2);\n\t\t\t\t}\n\t\t\t\tif (useOctNumbers) {\n\t\t\t\t\treturn '0o' + argument.toString(8);\n\t\t\t\t}\n\t\t\t} else if (!isObject(argument)) {\n\t\t\t\tif (json) {\n\t\t\t\t\t// For some values (e.g. `undefined`, `function` objects),\n\t\t\t\t\t// `JSON.stringify(value)` returns `undefined` (which isn’t valid\n\t\t\t\t\t// JSON) instead of `'null'`.\n\t\t\t\t\treturn JSON.stringify(argument) || 'null';\n\t\t\t\t}\n\t\t\t\treturn String(argument);\n\t\t\t} else { // it’s an object\n\t\t\t\tresult = [];\n\t\t\t\toptions.wrap = true;\n\t\t\t\toldIndent = options.__indent__;\n\t\t\t\tindent += oldIndent;\n\t\t\t\toptions.__indent__ = indent;\n\t\t\t\tforOwn(argument, function(key, value) {\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\t(compact ? '' : indent) +\n\t\t\t\t\t\tjsesc(key, options) + ':' +\n\t\t\t\t\t\t(compact ? '' : ' ') +\n\t\t\t\t\t\tjsesc(value, options)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tif (isEmpty) {\n\t\t\t\t\treturn '{}';\n\t\t\t\t}\n\t\t\t\treturn '{' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t\t(compact ? '' : oldIndent) + '}';\n\t\t\t}\n\t\t}\n\n\t\tvar string = argument;\n\t\t// Loop over each code unit in the string and escape it\n\t\tvar index = -1;\n\t\tvar length = string.length;\n\t\tvar first;\n\t\tvar second;\n\t\tvar codePoint;\n\t\tresult = '';\n\t\twhile (++index < length) {\n\t\t\tvar character = string.charAt(index);\n\t\t\tif (options.es6) {\n\t\t\t\tfirst = string.charCodeAt(index);\n\t\t\t\tif ( // check if it’s the start of a surrogate pair\n\t\t\t\t\tfirst >= 0xD800 && first <= 0xDBFF && // high surrogate\n\t\t\t\t\tlength > index + 1 // there is a next code unit\n\t\t\t\t) {\n\t\t\t\t\tsecond = string.charCodeAt(index + 1);\n\t\t\t\t\tif (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate\n\t\t\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\t\tcodePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\t\t\tvar hexadecimal = codePoint.toString(16);\n\t\t\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult += '\\\\u{' + hexadecimal + '}';\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!options.escapeEverything) {\n\t\t\t\tif (regexWhitelist.test(character)) {\n\t\t\t\t\t// It’s a printable ASCII character that is not `\"`, `'` or `\\`,\n\t\t\t\t\t// so don’t escape it.\n\t\t\t\t\tresult += character;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (character == '\"') {\n\t\t\t\t\tresult += quote == character ? '\\\\\"' : character;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (character == '\\'') {\n\t\t\t\t\tresult += quote == character ? '\\\\\\'' : character;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (\n\t\t\t\tcharacter == '\\0' &&\n\t\t\t\t!json &&\n\t\t\t\t!regexDigit.test(string.charAt(index + 1))\n\t\t\t) {\n\t\t\t\tresult += '\\\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (regexSingleEscape.test(character)) {\n\t\t\t\t// no need for a `hasOwnProperty` check here\n\t\t\t\tresult += singleEscapes[character];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar charCode = character.charCodeAt(0);\n\t\t\tvar hexadecimal = charCode.toString(16);\n\t\t\tif (!lowercaseHex) {\n\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t}\n\t\t\tvar longhand = hexadecimal.length > 2 || json;\n\t\t\tvar escaped = '\\\\' + (longhand ? 'u' : 'x') +\n\t\t\t\t('0000' + hexadecimal).slice(longhand ? -4 : -2);\n\t\t\tresult += escaped;\n\t\t\tcontinue;\n\t\t}\n\t\tif (options.wrap) {\n\t\t\tresult = quote + result + quote;\n\t\t}\n\t\tif (options.escapeEtago) {\n\t\t\t// https://mathiasbynens.be/notes/etago\n\t\t\treturn result.replace(/<\\/(script|style)/gi, '<\\\\/$1');\n\t\t}\n\t\treturn result;\n\t};\n\n\tjsesc.version = '1.3.0';\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn jsesc;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = jsesc;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfreeExports.jsesc = jsesc;\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.jsesc = jsesc;\n\t}\n\n}(this));\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","var baseIndexOf = require('./_baseIndexOf');\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n","/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var copyObject = require('./_copyObject'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var Stack = require('./_Stack'),\n    arrayEach = require('./_arrayEach'),\n    assignValue = require('./_assignValue'),\n    baseAssign = require('./_baseAssign'),\n    baseAssignIn = require('./_baseAssignIn'),\n    cloneBuffer = require('./_cloneBuffer'),\n    copyArray = require('./_copyArray'),\n    copySymbols = require('./_copySymbols'),\n    copySymbolsIn = require('./_copySymbolsIn'),\n    getAllKeys = require('./_getAllKeys'),\n    getAllKeysIn = require('./_getAllKeysIn'),\n    getTag = require('./_getTag'),\n    initCloneArray = require('./_initCloneArray'),\n    initCloneByTag = require('./_initCloneByTag'),\n    initCloneObject = require('./_initCloneObject'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isMap = require('./isMap'),\n    isObject = require('./isObject'),\n    isSet = require('./isSet'),\n    keys = require('./keys');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n\n    return result;\n  }\n\n  if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n\n    return result;\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n","var isObject = require('./isObject');\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nmodule.exports = baseHas;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIsNaN = require('./_baseIsNaN'),\n    strictIndexOf = require('./_strictIndexOf');\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar regexpTag = '[object RegExp]';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\n}\n\nmodule.exports = baseIsRegExp;\n","var getTag = require('./_getTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeFloor = Math.floor;\n\n/**\n * The base implementation of `_.repeat` which doesn't coerce arguments.\n *\n * @private\n * @param {string} string The string to repeat.\n * @param {number} n The number of times to repeat the string.\n * @returns {string} Returns the repeated string.\n */\nfunction baseRepeat(string, n) {\n  var result = '';\n  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n    return result;\n  }\n  // Leverage the exponentiation by squaring algorithm for a faster repeat.\n  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n  do {\n    if (n % 2) {\n      result += string;\n    }\n    n = nativeFloor(n / 2);\n    if (n) {\n      string += string;\n    }\n  } while (n);\n\n  return result;\n}\n\nmodule.exports = baseRepeat;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    cacheHas = require('./_cacheHas'),\n    createSet = require('./_createSet'),\n    setToArray = require('./_setToArray');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n","var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var Uint8Array = require('./_Uint8Array');\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n","var root = require('./_root');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n","/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n","var Symbol = require('./_Symbol');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer');\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n","/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var copyObject = require('./_copyObject'),\n    getSymbols = require('./_getSymbols');\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n","var copyObject = require('./_copyObject'),\n    getSymbolsIn = require('./_getSymbolsIn');\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var Set = require('./_Set'),\n    noop = require('./noop'),\n    setToArray = require('./_setToArray');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbolsIn = require('./_getSymbolsIn'),\n    keysIn = require('./keysIn');\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var arrayPush = require('./_arrayPush'),\n    getPrototype = require('./_getPrototype'),\n    getSymbols = require('./_getSymbols'),\n    stubArray = require('./stubArray');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n","var cloneArrayBuffer = require('./_cloneArrayBuffer'),\n    cloneDataView = require('./_cloneDataView'),\n    cloneRegExp = require('./_cloneRegExp'),\n    cloneSymbol = require('./_cloneSymbol'),\n    cloneTypedArray = require('./_cloneTypedArray');\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n","var baseCreate = require('./_baseCreate'),\n    getPrototype = require('./_getPrototype'),\n    isPrototype = require('./_isPrototype');\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","var assignValue = require('./_assignValue'),\n    copyObject = require('./_copyObject'),\n    createAssigner = require('./_createAssigner'),\n    isArrayLike = require('./isArrayLike'),\n    isPrototype = require('./_isPrototype'),\n    keys = require('./keys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own enumerable string keyed properties of source objects to the\n * destination object. Source objects are applied from left to right.\n * Subsequent sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object` and is loosely based on\n * [`Object.assign`](https://mdn.io/Object/assign).\n *\n * @static\n * @memberOf _\n * @since 0.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assignIn\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assign({ 'a': 0 }, new Foo, new Bar);\n * // => { 'a': 1, 'c': 3 }\n */\nvar assign = createAssigner(function(object, source) {\n  if (isPrototype(source) || isArrayLike(source)) {\n    copyObject(source, keys(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (hasOwnProperty.call(source, key)) {\n      assignValue(object, key, source[key]);\n    }\n  }\n});\n\nmodule.exports = assign;\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n","var baseClone = require('./_baseClone');\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = cloneDeep;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","var baseRest = require('./_baseRest'),\n    eq = require('./eq'),\n    isIterateeCall = require('./_isIterateeCall'),\n    keysIn = require('./keysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nmodule.exports = defaults;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var baseHas = require('./_baseHas'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nmodule.exports = has;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var baseIndexOf = require('./_baseIndexOf'),\n    isArrayLike = require('./isArrayLike'),\n    isString = require('./isString'),\n    toInteger = require('./toInteger'),\n    values = require('./values');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it's\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ 'a': 1, 'b': 2 }, 1);\n * // => true\n *\n * _.includes('abcd', 'bc');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = isArrayLike(collection) ? collection : values(collection);\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return isString(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n}\n\nmodule.exports = includes;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var toInteger = require('./toInteger');\n\n/**\n * Checks if `value` is an integer.\n *\n * **Note:** This method is based on\n * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n * @example\n *\n * _.isInteger(3);\n * // => true\n *\n * _.isInteger(Number.MIN_VALUE);\n * // => false\n *\n * _.isInteger(Infinity);\n * // => false\n *\n * _.isInteger('3');\n * // => false\n */\nfunction isInteger(value) {\n  return typeof value == 'number' && value == toInteger(value);\n}\n\nmodule.exports = isInteger;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var baseIsMap = require('./_baseIsMap'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var baseIsRegExp = require('./_baseIsRegExp'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp('/abc/');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\nmodule.exports = isRegExp;\n","var baseIsSet = require('./_baseIsSet'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n","var baseGetTag = require('./_baseGetTag'),\n    isArray = require('./isArray'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","var baseRepeat = require('./_baseRepeat'),\n    isIterateeCall = require('./_isIterateeCall'),\n    toInteger = require('./toInteger'),\n    toString = require('./toString');\n\n/**\n * Repeats the given string `n` times.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to repeat.\n * @param {number} [n=1] The number of times to repeat the string.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the repeated string.\n * @example\n *\n * _.repeat('*', 3);\n * // => '***'\n *\n * _.repeat('abc', 2);\n * // => 'abcabc'\n *\n * _.repeat('abc', 0);\n * // => ''\n */\nfunction repeat(string, n, guard) {\n  if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n    n = 1;\n  } else {\n    n = toInteger(n);\n  }\n  return baseRepeat(toString(string), n);\n}\n\nmodule.exports = repeat;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var baseUniq = require('./_baseUniq');\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nmodule.exports = uniq;\n","var baseValues = require('./_baseValues'),\n    keys = require('./keys');\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n","'use strict';\nconst stripAnsi = require('strip-ansi');\nconst isFullwidthCodePoint = require('is-fullwidth-code-point');\n\nmodule.exports = str => {\n\tif (typeof str !== 'string' || str.length === 0) {\n\t\treturn 0;\n\t}\n\n\tstr = stripAnsi(str);\n\n\tlet width = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst code = str.codePointAt(i);\n\n\t\t// Ignore control characters\n\t\tif (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore combining characters\n\t\tif (code >= 0x300 && code <= 0x36F) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Surrogates\n\t\tif (code > 0xFFFF) {\n\t\t\ti++;\n\t\t}\n\n\t\twidth += isFullwidthCodePoint(code) ? 2 : 1;\n\t}\n\n\treturn width;\n};\n","'use strict';\nvar ansiRegex = require('ansi-regex')();\n\nmodule.exports = function (str) {\n\treturn typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n};\n","'use strict';\nvar argv = process.argv;\n\nvar terminator = argv.indexOf('--');\nvar hasFlag = function (flag) {\n\tflag = '--' + flag;\n\tvar pos = argv.indexOf(flag);\n\treturn pos !== -1 && (terminator !== -1 ? pos < terminator : true);\n};\n\nmodule.exports = (function () {\n\tif ('FORCE_COLOR' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (hasFlag('no-color') ||\n\t\thasFlag('no-colors') ||\n\t\thasFlag('color=false')) {\n\t\treturn false;\n\t}\n\n\tif (hasFlag('color') ||\n\t\thasFlag('colors') ||\n\t\thasFlag('color=true') ||\n\t\thasFlag('color=always')) {\n\t\treturn true;\n\t}\n\n\tif (process.stdout && !process.stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn true;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n})();\n","'use strict';\nmodule.exports = function toFastproperties(o) {\n\tfunction Sub() {}\n\tSub.prototype = o;\n\tvar receiver = new Sub(); // create an instance\n\tfunction ic() { return typeof receiver.foo; } // perform access\n\tic(); \n\tic();\n\treturn o;\n\teval(\"o\" + o); // ensure no dead code elimination\n}\n","'use strict';\nmodule.exports = function (str) {\n\tvar tail = str.length;\n\n\twhile (/[\\s\\uFEFF\\u00A0]/.test(str[tail - 1])) {\n\t\ttail--;\n\t}\n\n\treturn str.slice(0, tail);\n};\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n","\n\nvar escape = module.exports = function escape(string, ignore) {\n  var pattern;\n\n  if (string === null || string === undefined) return;\n\n  ignore = (ignore || '').replace(/[^&\"<>\\']/g, '');\n  pattern = '([&\"<>\\'])'.replace(new RegExp('[' + ignore + ']', 'g'), '');\n\n  return string.replace(new RegExp(pattern, 'g'), function(str, item) {\n            return escape.map[item];\n          })\n}\n\nvar map = escape.map = {\n    '>': '&gt;'\n  , '<': '&lt;'\n  , \"'\": '&apos;'\n  , '\"': '&quot;'\n  , '&': '&amp;'\n}","import traverse from 'babel-traverse';\n\nimport { DefinitionsList } from './entryDefinitionsMap';\nimport { parseCodeToAST, buildVisitor } from './astBuilder';\nimport {\n    ABSTRACTION_LEVELS,\n    rebuildConfigForAbstractionLevel\n} from './abstractionLevelsConfigurator';\nimport FlowTreeModifier from './FlowTreeModifier';\nimport {\n    DEFINED_MODIFIERS,\n    MODIFIER_PRESETS,\n    destructionModifier,\n    expressionCallbacksModifier,\n    arrowFunctionReturnModifier\n} from './modifiers/modifiersFactory';\nimport { TOKEN_TYPES } from 'shared/constants';\nimport { logError } from 'shared/utils/logger';\n\nconst buildFlowTree = (astTree, astVisitorConfig) => {\n    const treeNodes = [];\n\n    traverse(astTree, buildVisitor(astVisitorConfig, treeNodes));\n\n    const root = (treeNodes.length && treeNodes[0]) || {};\n    return root.type === TOKEN_TYPES.PROGRAM\n        ? root\n        : { name: 'Root', type: TOKEN_TYPES.PROGRAM, body: treeNodes };\n};\n\n//TODO: seems redundant abstraction, refactor\nexport const createFlowTreeModifier = () => {\n    const modifiers = FlowTreeModifier();\n\n    return {\n        setModifier(modifier) {\n            modifiers.addModifier(modifier);\n        },\n\n        registerNewModifier(test, updates) {\n            modifiers.create(test, updates);\n        },\n\n        destructNodeTree(test, newNameFn) {\n            this.setModifier(destructionModifier(test, newNameFn));\n        },\n\n        applyToFlowTree(flowTree) {\n            modifiers.applyTo(flowTree);\n            return flowTree;\n        }\n    };\n};\n\nexport default ({ astParser = {}, astVisitor = {} } = {}) => {\n    const astParserConfig = {\n        ...astParser\n    };\n\n    const astVisitorConfig = {\n        definitionsMap: [...DefinitionsList],\n        globalIgnore: null,\n        ...astVisitor\n    };\n\n    const defaultModifier = createFlowTreeModifier();\n    defaultModifier.setModifier(expressionCallbacksModifier());\n    defaultModifier.setModifier(arrowFunctionReturnModifier());\n\n    return {\n        setAbstractionLevel(level) {\n            astVisitorConfig.definitionsMap = rebuildConfigForAbstractionLevel(level);\n        },\n\n        resetAbstractionLevelToNormal() {\n            astVisitorConfig.definitionsMap = [...DefinitionsList];\n        },\n\n        setIgnoreFilter(fn) {\n            astVisitorConfig.globalIgnore = fn;\n        },\n\n        build(code) {\n            const ast = this.buildAst(code);\n            return this.buildFlowTreeFromAst(ast);\n        },\n\n        buildAst(code) {\n            return parseCodeToAST(code, astParserConfig);\n        },\n\n        buildFlowTreeFromAst(ast) {\n            let flowTree = [];\n\n            try {\n                flowTree = buildFlowTree(ast, astVisitorConfig);\n                defaultModifier.applyToFlowTree(flowTree);\n            } catch (e) {\n                logError('Error at buildFlowTreeFromAst' + e.message, e.stack);\n                throw e;\n            }\n\n            return flowTree;\n        }\n    };\n};\n\nexport { DEFINED_MODIFIERS, MODIFIER_PRESETS, ABSTRACTION_LEVELS };\n","import { traversalSearch } from 'shared/utils/traversal';\n\nconst executeApplyFn = (apply, node) => (typeof apply === 'function' ? apply(node) : apply);\n\nconst UpdatesMap = {\n    name(node, apply) {\n        node.name = executeApplyFn(apply, node);\n    },\n\n    prefixName(node, apply) {\n        node.prefixName = executeApplyFn(apply, node);\n    },\n\n    type(node, apply) {\n        node.type = executeApplyFn(apply, node);\n    },\n\n    body(node, apply) {\n        node.body = executeApplyFn(apply, node);\n    },\n\n    parent(node, apply) {\n        node.parent = executeApplyFn(apply, node);\n    }\n};\n\nconst applyModifierUpdates = (tree, modifier) => {\n    const nodes = traversalSearch(tree, modifier.test);\n\n    if (!nodes.length) return;\n\n    const updates = Object.keys(modifier.updates || {});\n\n    updates.filter(i => i !== 'subTreeUpdate').forEach(updateName => {\n        nodes.forEach(node => {\n            UpdatesMap[updateName](node, modifier.updates[updateName]);\n        });\n    });\n\n    if (updates.includes('subTreeUpdate')) {\n        modifier.updates.subTreeUpdate(nodes, tree);\n    }\n};\n\nexport default () => {\n    const modifiersList = [];\n\n    return {\n        addModifier(modifier) {\n            [].concat(modifier).forEach(item => modifiersList.push(item));\n        },\n\n        create(test, updates) {\n            this.addModifier({ test, updates });\n        },\n\n        runModifier(tree, modifier) {\n            applyModifierUpdates(tree, modifier);\n        },\n\n        applyTo(tree) {\n            modifiersList.forEach(modifier => this.runModifier(tree, modifier));\n        }\n    };\n};\n","import { TOKEN_TYPES } from 'shared/constants';\nimport { callExpressionConverter } from 'builder/converters/core';\nimport { DefinitionsMap } from 'builder/entryDefinitionsMap';\nimport { getCustomFunctionDeclaration } from 'builder/abstraction-levels/functions';\n\nconst isNodeContainsFunctionCall = node => {\n    return node && node.type === TOKEN_TYPES.CALL_EXPRESSION;\n};\n\nconst getCustomAssignmentExpression = () => {\n    const assignmentExpression = DefinitionsMap[TOKEN_TYPES.ASSIGNMENT_EXPRESSION];\n\n    return {\n        ...assignmentExpression,\n        getName: ({ node }) => callExpressionConverter({ node: node.right }),\n        ignore: path =>\n            assignmentExpression.ignore(path) || !isNodeContainsFunctionCall(path.node.right)\n    };\n};\n\nconst getCustomVariableDeclarator = () => {\n    const variableDeclarator = DefinitionsMap[TOKEN_TYPES.VARIABLE_DECLARATOR];\n\n    return {\n        ...variableDeclarator,\n        getName: ({ node }) => callExpressionConverter({ node: node.init }),\n        ignore: path =>\n            variableDeclarator.ignore(path) || !isNodeContainsFunctionCall(path.node.init)\n    };\n};\n\nexport const getFunctionDependenciesLevel = () => ({\n    defined: [TOKEN_TYPES.CALL_EXPRESSION],\n    custom: [\n        getCustomFunctionDeclaration(),\n        getCustomAssignmentExpression(),\n        getCustomVariableDeclarator()\n    ]\n});\n","import { TOKEN_TYPES } from 'shared/constants';\nimport { DefinitionsMap } from 'builder/entryDefinitionsMap';\n\nexport const getCustomFunctionDeclaration = () => {\n    const functionDeclaration = DefinitionsMap[TOKEN_TYPES.FUNCTION];\n\n    return {\n        ...functionDeclaration,\n        getName: path => {\n            let nameConfig = functionDeclaration.getName(path);\n\n            if (path.parent.type === TOKEN_TYPES.OBJECT_PROPERTY && path.parent.key) {\n                nameConfig = {\n                    ...nameConfig,\n                    name: path.parent.key.name + ': ' + nameConfig.name\n                };\n            }\n\n            return nameConfig;\n        },\n        ignore: path =>\n            (functionDeclaration.ignore && functionDeclaration.ignore(path)) ||\n            path.parent.type === TOKEN_TYPES.CALL_EXPRESSION\n    };\n};\n\nexport const getFunctionsLevel = () => {\n    return {\n        defined: [],\n        custom: [getCustomFunctionDeclaration()]\n    };\n};\n","import { TOKEN_TYPES } from 'shared/constants';\nimport { DefinitionsList } from './entryDefinitionsMap';\nimport { getFunctionDependenciesLevel } from './abstraction-levels/functionDependencies';\nimport { getFunctionsLevel } from './abstraction-levels/functions';\n\nexport const ABSTRACTION_LEVELS = {\n    FUNCTION: getFunctionsLevel(),\n    FUNCTION_DEPENDENCIES: getFunctionDependenciesLevel(),\n    CLASS: [TOKEN_TYPES.CLASS_DECLARATION],\n    IMPORT: [\n        TOKEN_TYPES.IMPORT_DECLARATION,\n        TOKEN_TYPES.IMPORT_SPECIFIER,\n        TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER\n    ],\n    EXPORT: [TOKEN_TYPES.EXPORT_NAMED_DECLARATION, TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION]\n};\n\nexport const rebuildConfigForAbstractionLevel = level => {\n    let definedLevels = [TOKEN_TYPES.PROGRAM],\n        customLevels = [];\n\n    [].concat(level).forEach(item => {\n        if (typeof item === 'string') {\n            return definedLevels.push(item);\n        }\n\n        if (Array.isArray(item)) {\n            return (definedLevels = definedLevels.concat([...item]));\n        }\n\n        if (typeof item === 'object') {\n            definedLevels = definedLevels.concat([...(item.defined || [])]);\n            customLevels = customLevels.concat([...(item.custom || [])]);\n        }\n    });\n\n    return DefinitionsList.filter(item => definedLevels.indexOf(item.type) !== -1).concat(\n        customLevels\n    );\n};\n","import * as babylon from 'babylon';\nimport { mergeObjectStructures } from 'shared/utils/composition';\n\nimport { TOKEN_KEYS } from 'shared/constants';\nimport { setupPointer } from 'shared/utils/treeLevelsPointer';\nimport { logError } from 'shared/utils/logger';\nimport defaultAstConfig from './astParserConfig';\n\nimport traverse from 'babel-traverse';\n\nexport const parseCodeToAST = (code, config = {}) => {\n    let ast = [];\n\n    try {\n        ast = babylon.parse(code, mergeObjectStructures(defaultAstConfig, config));\n    } catch (e) {\n        logError('Error at parseCodeToAST: ' + e.message, e.loc, e.stack);\n        throw e;\n    }\n\n    return ast;\n};\n\nexport const buildVisitor = ({ definitionsMap, globalIgnore }, treeNodesDestination) => {\n    const pointer = setupPointer(treeNodesDestination),\n        wrapByGlobalIgnore = visit => path => visit(path, globalIgnore);\n\n    return definitionsMap.reduce((acc, item) => {\n        if (!item.body) {\n            acc[item.type] = item.reversed\n                ? { exit: wrapByGlobalIgnore(visitSimpleEntry(item, pointer)) }\n                : wrapByGlobalIgnore(visitSimpleEntry(item, pointer));\n        } else {\n            acc[item.type] = {\n                enter: wrapByGlobalIgnore(enterComplexEntry(item, pointer)),\n                exit: wrapByGlobalIgnore(exitComplexEntry(item, pointer))\n            };\n        }\n\n        return acc;\n    }, {});\n};\n\n//TODO: refactor, looks a bit duplicated\nconst visitSimpleEntry = (item, pointer) => (path, globalIgnore) => {\n    if (item.ignore && item.ignore(path)) return;\n\n    const entryConfig = {\n        ...getBasicEntryConfig(item, path)\n    };\n\n    if (globalIgnore && globalIgnore(entryConfig)) return;\n\n    pushEntry(pointer, entryConfig);\n};\n\nconst enterComplexEntry = (item, pointer) => (path, globalIgnore) => {\n    if (item.ignore && item.ignore(path)) return;\n\n    const entryConfig = pushComplexEntry(item, pointer, path, globalIgnore);\n\n    pointer.stepIn(entryConfig);\n};\n\nconst pushComplexEntry = (item, pointer, path, globalIgnore) => {\n    const entryConfig = {\n        ...getBasicEntryConfig(item, path),\n        body: []\n    };\n\n    if (!(globalIgnore && globalIgnore(entryConfig))) {\n        pushEntry(pointer, entryConfig);\n    }\n\n    return entryConfig;\n};\n\nconst pushEntry = (pointer, entry) => {\n    const parent = pointer.getCurrent();\n    entry.parent = parent;\n\n    (parent.body || parent).push(entry);\n};\n\nconst getStatementParentKey = path => {\n    const statementParent =\n        path.find(path => path.parentKey === TOKEN_KEYS.PROGRAM || path.isStatementOrBlock()) || {};\n    return statementParent.key;\n};\n\nconst exitComplexEntry = (item, pointer) => path => {\n    if (item.ignore && item.ignore(path)) return;\n\n    pointer.stepOut();\n};\n\nconst getBasicEntryConfig = (item, path) => {\n    const name = item.getName(path),\n        nameOptions = typeof name === 'string' ? { name } : name;\n\n    const config = {\n        ...nameOptions,\n        type: item.type,\n        key: getStatementParentKey(path),\n        isBodyEntry: path.key === TOKEN_KEYS.BODY\n    };\n\n    if (!config.name) {\n        config.name = '';\n    }\n\n    if (item.type !== path.node.type) {\n        config.subType = path.node.type;\n    }\n\n    return config;\n};\n","export default {\n    sourceType: 'module',\n    plugins: ['objectRestSpread', 'jsx', 'typescript']\n};\n","import generate from 'babel-generator';\nimport { TOKEN_TYPES } from 'shared/constants';\n\nexport const importDeclarationConverter = ({ node }) => 'import from' + generate(node.source).code;\n\nexport const exportNamedDeclarationConverter = ({ node }) => `export${getExportedTokenName(node)}`;\n\nexport const exportDefaultDeclarationConverter = ({ node }) =>\n    `export default ${getExportedTokenName(node)}`;\n\nconst getExportedTokenName = path => {\n    const { declaration, specifiers } = path;\n\n    if (declaration) {\n        return ' ' + getExportDeclarations(declaration);\n    }\n\n    if (specifiers) {\n        return '';\n    }\n\n    return generate(specifiers).code;\n};\n\nconst getExportDeclarations = declaration => {\n    if (\n        [TOKEN_TYPES.FUNCTION_DECLARATION, TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION].indexOf(\n            declaration.type\n        ) !== -1\n    ) {\n        return declaration.id ? declaration.id.name : 'function';\n    }\n\n    if (declaration.type === TOKEN_TYPES.VARIABLE_DECLARATION) {\n        return declaration.declarations[0].id.name;\n    }\n\n    if (declaration.type === TOKEN_TYPES.IDENTIFIER) {\n        return declaration.name;\n    }\n\n    if (declaration.type === TOKEN_TYPES.ASSIGNMENT_EXPRESSION) {\n        return declaration.left.name;\n    }\n};\n\nexport const classDeclarationConverter = ({ node }) => {\n    return `class ${generate(node.id).code} ${\n        node.superClass ? ` extends ${generate(node.superClass).code}` : ''\n    }`;\n};\n\nexport const objectPatternConverter = () => '{...}';\n\nexport const arrayPatternConverter = () => '[...]';\n","import generate from 'babel-generator';\nimport { TOKEN_TYPES, CLASS_FUNCTION_KINDS } from 'shared/constants';\n\nexport const idleConverter = path => {\n    return generate(path.node).code;\n};\n\nexport const identifierConverter = path => {\n    if (path.parent.type === TOKEN_TYPES.SPREAD_PROPERTY) {\n        return '...' + idleConverter(path);\n    }\n\n    return idleConverter(path);\n};\n\n/* function */\nexport const functionConverter = path => {\n    const node = path.node,\n        paramsCode = getFunctionParametersCode(node.params);\n\n    let name = '';\n\n    if (node.id) {\n        name = getAnonymousFunctionName(path) + 'function ' + node.id.name + paramsCode;\n    } else if (node.type === TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION) {\n        name = getAnonymousFunctionName(path) + paramsCode + ' =>';\n    } else if (node.type === TOKEN_TYPES.CLASS_METHOD || node.type === TOKEN_TYPES.OBJECT_METHOD) {\n        name =\n            node.kind === CLASS_FUNCTION_KINDS.CONSTRUCTOR\n                ? 'constructor' + paramsCode\n                : node.key.name + paramsCode;\n    } else {\n        name = getAnonymousFunctionName(path) + 'function' + paramsCode;\n    }\n\n    return { name, pathParentType: path.parent.type };\n};\n\nexport const getAnonymousFunctionName = path => {\n    const parent = path.parent;\n\n    if (\n        !parent ||\n        (parent.type !== TOKEN_TYPES.VARIABLE_DECLARATOR &&\n            parent.type !== TOKEN_TYPES.ASSIGNMENT_EXPRESSION &&\n            parent.type !== TOKEN_TYPES.OBJECT_PROPERTY)\n    ) {\n        return '';\n    }\n\n    if (parent.left) {\n        return generate(parent.left).code + ' = ';\n    }\n\n    const parentId = parent.id;\n    return parentId ? parentId.name + ' = ' : '';\n};\n\nexport const getFunctionParametersCode = params => {\n    return `(${params\n        .map(p => {\n            if (p.name) {\n                return p.name;\n            }\n\n            return generate(p).code;\n        })\n        .join(', ')})`;\n};\n\nexport const returnConverter = path => {\n    const node = path.node;\n    if (\n        node.argument &&\n        ([TOKEN_TYPES.CONDITIONAL_EXPRESSION, TOKEN_TYPES.OBJECT_EXPRESSION].includes(\n            node.argument.type\n        ) ||\n            isFunctionType(node.argument.type))\n    ) {\n        return 'return';\n    }\n\n    return path.node.argument ? `return ${generate(path.node.argument).code}` : 'return';\n};\n/* end function */\n\n/* loop */\nexport const loopConverter = ({ node }) => {\n    if (node.test) {\n        return generate(node.test).code;\n    }\n\n    if (node.left && node.right) {\n        const innerPart = node.type === TOKEN_TYPES.FOR_OF_STATEMENT ? 'of' : 'in';\n        const leftPart =\n            node.left.type === TOKEN_TYPES.VARIABLE_DECLARATION\n                ? getVariableDeclarations(node.left.declarations)\n                : generate(node.left).code;\n\n        return `${leftPart} ${innerPart} ${generate(node.right).code}`;\n    }\n};\n\nexport const continueConverter = path => {\n    return path.node.label ? `continue ${generate(path.node.label).code}` : 'continue';\n};\n/* end loop */\n\nexport const conditionalConverter = path => {\n    return `(${generate(path.node.test).code})`;\n};\n\n/* try-catch */\nexport const tryConverter = path => {\n    return `try`;\n};\n\nexport const catchConverter = path => {\n    return path.node.param ? `catch (${generate(path.node.param).code})` : '*catchConverter*';\n};\n\nexport const finallyConverter = path => {\n    //TODO: fix `finally`, not implemented yet because it presents only as a part of parent,\n    //there is no `finally` visitor as it exist for `catch`\n    //seems like to do that each try-catch block should be handled in a different way\n\n    return '*finallyConverter*';\n};\n/* end try-catch */\n\n/* switch-case */\nexport const switchStatementConverter = path => {\n    return `switch (${generate(path.node.discriminant).code})`;\n};\n\nexport const caseConverter = path => {\n    return path.node.test ? `case ${generate(path.node.test).code}:` : 'default:';\n};\n\nexport const breakConverter = path => {\n    return path.node.label ? `break ${generate(path.node.label).code}:` : 'break';\n};\n/* end switch - case */\n\nexport const withStatementConverter = path => {\n    return `with (${generate(path.node.object).code})`;\n};\n\nexport const programConverter = path => {\n    return `${path.node.type}: source ${path.node.sourceType}`;\n};\n\nexport const throwStatementConverter = path => {\n    return `throw ${generate(path.node.argument).code}`;\n};\n\nexport const debuggerConverter = path => {\n    return `debugger`;\n};\n\nexport const getVariableDeclarations = variables =>\n    variables.map(v => variableDeclaratorConverter({ node: v })).join(', ');\n\nexport const variableDeclaratorConverter = path => {\n    const node = path.node,\n        parentKind = (path.parent && path.parent.kind) || '';\n\n    if (\n        node.init &&\n        (isNodeContainsFunc(node.init) || node.init.type === TOKEN_TYPES.CONDITIONAL_EXPRESSION)\n    ) {\n        return `${parentKind} ${node.id.name} = `;\n    }\n\n    let variableName = '';\n    if (node.id.type === TOKEN_TYPES.OBJECT_PATTERN) {\n        variableName = '{...}';\n    } else if (node.id.type === TOKEN_TYPES.ARRAY_PATTERN) {\n        variableName = '[...]';\n    } else {\n        variableName = node.id.name;\n    }\n\n    if (\n        node.init &&\n        [TOKEN_TYPES.CALL_EXPRESSION, TOKEN_TYPES.NEW_EXPRESSION].includes(node.init.type)\n    ) {\n        return `${parentKind} ${variableName} = ` + callExpressionConverter({ node: node.init });\n    }\n\n    if (node.init && node.init.type === TOKEN_TYPES.OBJECT_EXPRESSION) {\n        return `${parentKind} ${variableName} = ${objectExpressionConverter()}`;\n    }\n\n    if (node.id && node.id.type === TOKEN_TYPES.OBJECT_PATTERN) {\n        return `${parentKind} {...} = ${node.init.name}`;\n    }\n\n    if (node.id && node.id.type === TOKEN_TYPES.ARRAY_PATTERN) {\n        return `${parentKind} [...] = ${node.init.name}`;\n    }\n\n    return parentKind + ' ' + generate(node).code;\n};\n\nexport const assignmentExpressionConverter = ({ node }) => {\n    if (isNodeContainsFunc(node.right) || node.right.type === TOKEN_TYPES.CONDITIONAL_EXPRESSION) {\n        return `${getLeftAssignmentName(node.left)} ${node.operator} `;\n    }\n\n    if (node.right.type === TOKEN_TYPES.OBJECT_EXPRESSION) {\n        return `${getLeftAssignmentName(node.left)} ${\n            node.operator\n        } ${objectExpressionConverter()}`;\n    }\n\n    if ([TOKEN_TYPES.CALL_EXPRESSION, TOKEN_TYPES.NEW_EXPRESSION].includes(node.right.type)) {\n        return `${getLeftAssignmentName(node.left)} ${node.operator} ${callExpressionConverter({\n            node: node.right\n        })}`;\n    }\n\n    return generate(node).code;\n};\n\nconst getLeftAssignmentName = node => {\n    if (node.name) {\n        return node.name;\n    }\n\n    return generate(node).code;\n};\n\nexport const callExpressionConverter = ({ node }) => {\n    let argumentsCode = '';\n\n    if (node.arguments && node.arguments.length) {\n        argumentsCode = node.arguments.map(getArgumentName).join(', ');\n    }\n\n    const callee = node.callee;\n    if (\n        callee.type === TOKEN_TYPES.MEMBER_EXPRESSION &&\n        callee.object.type === TOKEN_TYPES.CALL_EXPRESSION\n    ) {\n        return { name: `.${callee.property.name}(${argumentsCode})`, chain: true };\n    } else if (argumentsCode) {\n        return `${generate(node.callee).code}(${argumentsCode})`;\n    }\n\n    return generate(node).code;\n};\n\nconst getArgumentName = argument => {\n    if (isNodeContainsFunc(argument)) return '*()';\n    if (argument.type === TOKEN_TYPES.OBJECT_EXPRESSION) return objectExpressionConverter();\n\n    if (argument.name) return argument.name;\n    if (argument.value)\n        return argument.type === TOKEN_TYPES.STRING_LITERAL\n            ? `'${argument.value}'`\n            : argument.value;\n\n    return generate(argument).code;\n};\n\nexport const objectExpressionConverter = path => {\n    const name = '{*}';\n    if (path) return { name, pathParentType: path.parent.type };\n\n    return name;\n};\n\nexport const objectPropertyConverter = path => {\n    const node = path.node;\n\n    if (node.value && isFunctionType(node.value.type)) {\n        return node.key.name + ': ';\n    }\n\n    if (node.value && node.value.type === TOKEN_TYPES.OBJECT_EXPRESSION) {\n        return node.key.name + ': ' + objectExpressionConverter();\n    }\n\n    return generate(node).code;\n};\n\nconst getFirstCallee = callee => {\n    if (!callee) return callee;\n    if (\n        callee.type === TOKEN_TYPES.MEMBER_EXPRESSION &&\n        callee.object.type === TOKEN_TYPES.CALL_EXPRESSION\n    ) {\n        return getFirstCallee(callee.object);\n    }\n\n    return callee;\n};\n\nexport const isFunctionType = type => {\n    return [\n        TOKEN_TYPES.FUNCTION_EXPRESSION,\n        TOKEN_TYPES.FUNCTION,\n        TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION,\n        TOKEN_TYPES.FUNCTION_DECLARATION\n    ].includes(type);\n};\n\nexport const isNodeContainsFunc = node => {\n    const functions = [TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION, TOKEN_TYPES.FUNCTION_EXPRESSION];\n\n    return node && functions.indexOf(node.type) !== -1;\n};\n","import { TOKEN_TYPES, TOKEN_KEYS } from 'shared/constants';\nimport {\n    idleConverter,\n    identifierConverter,\n    functionConverter,\n    isNodeContainsFunc,\n    returnConverter,\n    variableDeclaratorConverter,\n    assignmentExpressionConverter,\n    callExpressionConverter,\n    loopConverter,\n    continueConverter,\n    conditionalConverter,\n    catchConverter,\n    tryConverter,\n    switchStatementConverter,\n    caseConverter,\n    breakConverter,\n    withStatementConverter,\n    programConverter,\n    throwStatementConverter,\n    debuggerConverter,\n    objectExpressionConverter,\n    objectPropertyConverter\n} from './converters/core';\n\nimport {\n    importDeclarationConverter,\n    exportNamedDeclarationConverter,\n    exportDefaultDeclarationConverter,\n    classDeclarationConverter,\n    objectPatternConverter,\n    arrayPatternConverter\n} from './converters/Harmony';\n\nconst singleTypeFilter = path => {\n    const statementParent = path.getStatementParent(),\n        parent = path.parent || {};\n\n    if ([TOKEN_KEYS.CONSEQUENT, TOKEN_KEYS.ALTERNATE].includes(path.key)) {\n        return false;\n    }\n\n    return (\n        ['params'].includes(path.listKey) ||\n        (statementParent.isReturnStatement() && path.key !== 'body') ||\n        ((statementParent.isLoop() ||\n            statementParent.isConditional() ||\n            parent.type === TOKEN_TYPES.CONDITIONAL_EXPRESSION) &&\n            ['test', 'left', 'right'].includes(path.parentKey)) ||\n        ([\n            TOKEN_TYPES.RETURN,\n            TOKEN_TYPES.CALL_EXPRESSION,\n            TOKEN_TYPES.BINARY_EXPRESSION,\n            TOKEN_TYPES.UPDATE_EXPRESSION,\n            TOKEN_TYPES.ASSIGNMENT_EXPRESSION,\n            TOKEN_TYPES.LOGICAL_EXPRESSION,\n            TOKEN_TYPES.VARIABLE_DECLARATOR,\n            TOKEN_TYPES.MEMBER_EXPRESSION,\n            TOKEN_TYPES.NEW_EXPRESSION,\n            TOKEN_TYPES.FUNCTION_DECLARATION,\n            TOKEN_TYPES.FUNCTION_EXPRESSION,\n            TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION,\n            TOKEN_TYPES.FUNCTION,\n            TOKEN_TYPES.OBJECT_PROPERTY,\n            TOKEN_TYPES.ASSIGNMENT_PATTERN,\n            TOKEN_TYPES.REST_PROPERTY,\n            TOKEN_TYPES.SPREAD_ELEMENT,\n            TOKEN_TYPES.ARRAY_EXPRESSION,\n            TOKEN_TYPES.UNARY_EXPRESSION,\n            TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER,\n            TOKEN_TYPES.IMPORT_SPECIFIER,\n            TOKEN_TYPES.IMPORT_DECLARATION,\n            TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION,\n            TOKEN_TYPES.EXPORT_NAMED_DECLARATION,\n            TOKEN_TYPES.CLASS_DECLARATION,\n            TOKEN_TYPES.CLASS_METHOD,\n            TOKEN_TYPES.SWITCH_STATEMENT,\n            TOKEN_TYPES.SWITCH_CASE\n        ].includes(parent.type) &&\n            (!parent.body || parent.body.type !== path.node.type))\n    );\n};\n\nexport const DefinitionsMap = {\n    [TOKEN_TYPES.FUNCTION]: {\n        type: TOKEN_TYPES.FUNCTION,\n        getName: functionConverter,\n        body: true\n    },\n    [TOKEN_TYPES.RETURN]: {\n        type: TOKEN_TYPES.RETURN,\n        getName: returnConverter,\n\n        body: true\n    },\n    [TOKEN_TYPES.VARIABLE_DECLARATOR]: {\n        type: TOKEN_TYPES.VARIABLE_DECLARATOR,\n        body: true,\n        getName: variableDeclaratorConverter,\n        ignore: path => {\n            const statementParent = path.getStatementParent();\n            return (\n                !path.node.init || isNodeContainsFunc(path.node.init) || statementParent.isLoop()\n            );\n        }\n    },\n    [TOKEN_TYPES.ASSIGNMENT_EXPRESSION]: {\n        type: TOKEN_TYPES.ASSIGNMENT_EXPRESSION,\n        body: true,\n        getName: assignmentExpressionConverter,\n        ignore: path => {\n            const statementParent = path.getStatementParent();\n\n            return (\n                statementParent.isVariableDeclaration() ||\n                path.parent.type === TOKEN_TYPES.LOGICAL_EXPRESSION ||\n                (statementParent.isConditional() && path.key === TOKEN_KEYS.TEST) ||\n                isNodeContainsFunc(path.node.right)\n            );\n        }\n    },\n    [TOKEN_TYPES.CALL_EXPRESSION]: {\n        type: TOKEN_TYPES.CALL_EXPRESSION,\n        body: false,\n        reversed: true,\n        getName: callExpressionConverter,\n        ignore: path => {\n            const statementParent = path.getStatementParent(),\n                parent = path.parent || {};\n\n            if (parent.type === TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION) return false;\n\n            return (\n                statementParent.isVariableDeclaration() ||\n                [\n                    TOKEN_TYPES.RETURN,\n                    TOKEN_TYPES.CALL_EXPRESSION,\n                    TOKEN_TYPES.NEW_EXPRESSION,\n                    TOKEN_TYPES.UNARY_EXPRESSION,\n                    TOKEN_TYPES.BINARY_EXPRESSION\n                ].includes(parent.type) ||\n                (statementParent.isConditional() &&\n                    parent.test &&\n                    parent.test.type === TOKEN_TYPES.CALL_EXPRESSION) ||\n                path.parent.type === TOKEN_TYPES.ASSIGNMENT_EXPRESSION //TODO: BUG, fix line: list = list.filter(i => i % 2)\n            );\n        }\n    },\n    [TOKEN_TYPES.UPDATE_EXPRESSION]: {\n        type: TOKEN_TYPES.UPDATE_EXPRESSION,\n        getName: idleConverter,\n        ignore: path => path.getStatementParent().isVariableDeclaration()\n    },\n    [TOKEN_TYPES.NEW_EXPRESSION]: {\n        type: TOKEN_TYPES.NEW_EXPRESSION,\n        getName: idleConverter,\n        ignore: path =>\n            path.getStatementParent().isVariableDeclaration() ||\n            path.parent.type === TOKEN_TYPES.ASSIGNMENT_EXPRESSION ||\n            path.parent.type === TOKEN_TYPES.THROW_STATEMENT\n    },\n    [TOKEN_TYPES.LOOP]: {\n        type: TOKEN_TYPES.LOOP,\n        getName: loopConverter,\n        body: true\n    },\n    [TOKEN_TYPES.CONTINUE]: {\n        type: TOKEN_TYPES.CONTINUE,\n        getName: continueConverter,\n        body: true\n    },\n    [TOKEN_TYPES.CONDITIONAL]: {\n        type: TOKEN_TYPES.CONDITIONAL,\n        getName: conditionalConverter,\n        body: true\n    },\n    [TOKEN_TYPES.SWITCH_STATEMENT]: {\n        type: TOKEN_TYPES.SWITCH_STATEMENT,\n        getName: switchStatementConverter,\n        body: true\n    },\n    [TOKEN_TYPES.SWITCH_CASE]: {\n        type: TOKEN_TYPES.SWITCH_CASE,\n        getName: caseConverter,\n        body: true\n    },\n    [TOKEN_TYPES.BREAK]: {\n        type: TOKEN_TYPES.BREAK,\n        getName: breakConverter,\n        body: true\n    },\n    [TOKEN_TYPES.TRY_STATEMENT]: {\n        type: TOKEN_TYPES.TRY_STATEMENT,\n        getName: tryConverter,\n        body: true\n    },\n    [TOKEN_TYPES.CATCH_CLAUSE]: {\n        type: TOKEN_TYPES.CATCH_CLAUSE,\n        getName: catchConverter,\n        body: true\n    },\n    [TOKEN_TYPES.WITH_STATEMENT]: {\n        type: TOKEN_TYPES.WITH_STATEMENT, //TODO: visual\n        getName: withStatementConverter,\n        body: true\n    },\n    [TOKEN_TYPES.PROGRAM]: {\n        type: TOKEN_TYPES.PROGRAM, //TODO: visual\n        getName: programConverter,\n        body: true\n    },\n    [TOKEN_TYPES.THROW_STATEMENT]: {\n        type: TOKEN_TYPES.THROW_STATEMENT,\n        getName: throwStatementConverter,\n        body: true\n    },\n    [TOKEN_TYPES.DEBUGGER_STATEMENT]: {\n        type: TOKEN_TYPES.DEBUGGER_STATEMENT,\n        getName: debuggerConverter,\n        body: true\n    },\n    [TOKEN_TYPES.BINARY_EXPRESSION]: {\n        type: TOKEN_TYPES.BINARY_EXPRESSION,\n        getName: idleConverter,\n        ignore: singleTypeFilter\n    },\n    [TOKEN_TYPES.IDENTIFIER]: {\n        type: TOKEN_TYPES.IDENTIFIER,\n        getName: identifierConverter,\n        ignore: singleTypeFilter\n    },\n    [TOKEN_TYPES.STRING_LITERAL]: {\n        type: TOKEN_TYPES.STRING_LITERAL,\n        getName: idleConverter,\n        ignore: singleTypeFilter\n    },\n    [TOKEN_TYPES.NUMERIC_LITERAL]: {\n        type: TOKEN_TYPES.NUMERIC_LITERAL,\n        getName: idleConverter,\n        ignore: singleTypeFilter\n    },\n    [TOKEN_TYPES.OBJECT_EXPRESSION]: {\n        type: TOKEN_TYPES.OBJECT_EXPRESSION,\n        getName: objectExpressionConverter,\n        ignore: path => {\n            const node = path.node;\n            if (node.properties && !node.properties.length) {\n                return true;\n            }\n\n            return [\n                TOKEN_TYPES.OBJECT_PROPERTY,\n                TOKEN_TYPES.ASSIGNMENT_EXPRESSION,\n                TOKEN_TYPES.VARIABLE_DECLARATOR\n            ].includes(path.parent.type);\n        },\n        body: true\n    },\n    [TOKEN_TYPES.OBJECT_PROPERTY]: {\n        type: TOKEN_TYPES.OBJECT_PROPERTY,\n        getName: objectPropertyConverter,\n        ignore: path => {\n            const parentPath = path.parentPath;\n            return ['params', 'left'].includes(parentPath.parentKey);\n        },\n        body: true\n    },\n\n    //ES Harmony features\n    [TOKEN_TYPES.IMPORT_DECLARATION]: {\n        type: TOKEN_TYPES.IMPORT_DECLARATION,\n        getName: importDeclarationConverter,\n        body: true\n    },\n    [TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER]: {\n        type: TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER,\n        getName: idleConverter\n    },\n    [TOKEN_TYPES.IMPORT_SPECIFIER]: {\n        type: TOKEN_TYPES.IMPORT_SPECIFIER,\n        getName: idleConverter\n    },\n    [TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION]: {\n        type: TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION,\n        getName: exportDefaultDeclarationConverter,\n        body: true\n    },\n    [TOKEN_TYPES.EXPORT_NAMED_DECLARATION]: {\n        type: TOKEN_TYPES.EXPORT_NAMED_DECLARATION,\n        getName: exportNamedDeclarationConverter,\n        body: true\n    },\n    [TOKEN_TYPES.CLASS_DECLARATION]: {\n        type: TOKEN_TYPES.CLASS_DECLARATION,\n        getName: classDeclarationConverter,\n        body: true\n    },\n    [TOKEN_TYPES.OBJECT_PATTERN]: {\n        type: TOKEN_TYPES.OBJECT_PATTERN,\n        getName: objectPatternConverter,\n        ignore: path => {\n            return (\n                path.listKey === 'params' ||\n                [TOKEN_TYPES.VARIABLE_DECLARATOR, TOKEN_TYPES.ASSIGNMENT_PATTERN].includes(\n                    path.parent.type\n                )\n            );\n        },\n        body: true\n    },\n    [TOKEN_TYPES.ARRAY_PATTERN]: {\n        type: TOKEN_TYPES.ARRAY_PATTERN,\n        getName: arrayPatternConverter,\n        ignore: path => {\n            return (\n                path.listKey === 'params' ||\n                [TOKEN_TYPES.VARIABLE_DECLARATOR, TOKEN_TYPES.ASSIGNMENT_PATTERN].includes(\n                    path.parent.type\n                )\n            );\n        },\n        body: true\n    }\n};\n\nexport const DefinitionsList = Object.keys(DefinitionsMap).map(key => DefinitionsMap[key]);\n","import { TOKEN_TYPES, TOKEN_KEYS, MODIFIED_TYPES } from 'shared/constants';\n\nconst extractNodeName = (node, field) => {\n    const name = node.name.split(`.${field}(`)[0];\n\n    if (name.includes('=')) {\n        return name.split('=');\n    }\n\n    return [name];\n};\n\nconst testNode = (node, field) => node.name.includes(`.${field}(`);\n\nexport const DEFINED_MODIFIERS = {\n    forEach: {\n        test: node => testNode(node, 'forEach'),\n        updates: {\n            name: node => `each in  ${extractNodeName(node, 'forEach')[0]}`,\n            type: TOKEN_TYPES.LOOP,\n            body: node => [...node.body[0].body]\n        }\n    },\n\n    filter: {\n        test: node => testNode(node, 'filter'),\n        updates: {\n            name: node =>\n                `in ${extractNodeName(node, 'filter')[1]} to ${extractNodeName(node, 'filter')[0]}`,\n            prefixName: 'filter',\n            type: TOKEN_TYPES.LOOP\n        }\n    },\n\n    map: {\n        test: node => testNode(node, 'map'),\n        updates: {\n            name: node =>\n                `from ${extractNodeName(node, 'map')[1]} to ${extractNodeName(node, 'map')[0]}`,\n            prefixName: 'map',\n            type: TOKEN_TYPES.LOOP\n        }\n    }\n};\n\nexport const destructionModifier = (test, newNameFn) => ({\n    test,\n    updates: {\n        name: newNameFn,\n        body: [],\n        type: MODIFIED_TYPES.DESTRUCTED\n    }\n});\n\nexport const arrowFunctionReturnModifier = () => ({\n    test: node =>\n        node.isBodyEntry &&\n        node.parent &&\n        node.parent.subType === TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION,\n    updates: {\n        name: node => 'return ' + node.name,\n        type: TOKEN_TYPES.RETURN\n    }\n});\n\nexport const expressionCallbacksModifier = () => ({\n    test: node => node.pathParentType === TOKEN_TYPES.CALL_EXPRESSION,\n    updates: {\n        subTreeUpdate: nodes => {\n            nodes.forEach(node => {\n                const parentBody = node.parent.body,\n                    index = parentBody.indexOf(node) + 1;\n\n                for (let i = index; i < parentBody.length; i++) {\n                    let sibling = parentBody[i];\n\n                    if (sibling && sibling.type === TOKEN_TYPES.CALL_EXPRESSION) {\n                        node.parent.body = parentBody.filter(n => n !== node);\n                        sibling.body = [...(sibling.body || []), node];\n\n                        return;\n                    }\n                }\n            });\n        }\n    }\n});\n\nexport const MODIFIER_PRESETS = {\n    es5ArrayIterators: [DEFINED_MODIFIERS.forEach, DEFINED_MODIFIERS.filter, DEFINED_MODIFIERS.map]\n};\n","import { parseCodeToAST } from 'builder/astBuilder';\n\nimport FlowTreeBuilder, {\n    ABSTRACTION_LEVELS,\n    MODIFIER_PRESETS,\n    DEFINED_MODIFIERS\n} from 'builder/FlowTreeBuilder';\nimport SVGRender from 'render/svg/SVGRender';\nimport { TOKEN_TYPES, MODIFIED_TYPES } from 'shared/constants';\n\nconst buildTreeByAbstractionLevels = levels => {\n    const flowTreeBuilder = FlowTreeBuilder();\n    flowTreeBuilder.setAbstractionLevel(levels);\n\n    return astTree => flowTreeBuilder.buildFlowTreeFromAst(astTree);\n};\n\nexport const generateExportSlideTree = buildTreeByAbstractionLevels(ABSTRACTION_LEVELS.EXPORT);\n\nexport const generateImportExportSlideTree = buildTreeByAbstractionLevels([\n    ABSTRACTION_LEVELS.EXPORT,\n    ABSTRACTION_LEVELS.IMPORT\n]);\n\nexport const generateClassFunctionSlideTree = buildTreeByAbstractionLevels([\n    ABSTRACTION_LEVELS.EXPORT,\n    ABSTRACTION_LEVELS.IMPORT,\n    ABSTRACTION_LEVELS.CLASS,\n    ABSTRACTION_LEVELS.FUNCTION\n]);\n\nexport const generateClassFunctionDependenciesSlideTree = buildTreeByAbstractionLevels([\n    ABSTRACTION_LEVELS.EXPORT,\n    ABSTRACTION_LEVELS.IMPORT,\n    ABSTRACTION_LEVELS.CLASS,\n    ABSTRACTION_LEVELS.FUNCTION,\n    ABSTRACTION_LEVELS.FUNCTION_DEPENDENCIES\n]);\n\nexport const generateRegularSlideTree = astTree => {\n    const flowTreeBuilder = FlowTreeBuilder();\n    return flowTreeBuilder.buildFlowTreeFromAst(astTree);\n};\n\nexport default code => ({\n    buildSlides: () => {\n        const svgRender = SVGRender(),\n            astTree = parseCodeToAST(code);\n\n        const slides = [\n            generateExportSlideTree(astTree),\n            generateImportExportSlideTree(astTree),\n            generateClassFunctionSlideTree(astTree),\n            generateClassFunctionDependenciesSlideTree(astTree),\n            generateRegularSlideTree(astTree)\n        ];\n\n        return slides\n            .filter(slide => slide.body.length)\n            .map(svgRender.buildShapesTree)\n            .map(shapesTree => shapesTree.print());\n    }\n});\n","import { calculateShapesBoundaries } from 'shared/utils/geometry';\n\nexport const SVGBase = () => {\n    const state = {\n        shapes: [],\n        arrowConnections: []\n    };\n\n    return {\n        getShapes() {\n            return state.shapes;\n        },\n        addShapes(shapes) {\n            state.shapes = state.shapes.concat(shapes);\n            return this;\n        },\n        addArrowConnections(arrowConnections) {\n            state.arrowConnections = state.arrowConnections.concat(arrowConnections);\n            return this;\n        },\n        printChildren(config) {\n            let svgString = ``;\n\n            [].concat(state.shapes, state.arrowConnections).forEach(node => {\n                svgString += node.print(config);\n            });\n\n            return svgString;\n        },\n        calculateDimensions() {\n            const boundaries = calculateShapesBoundaries(\n                    state.shapes.map(item => item.getBoundaries())\n                ),\n                padding = 25;\n\n            return {\n                w: Math.ceil(boundaries.max.x) + padding,\n                h: Math.ceil(boundaries.max.y) + padding\n            };\n        },\n\n        print(config) {\n            const { w, h } = this.calculateDimensions();\n\n            return `<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n                <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" \n                width=\"${w}\" height=\"${h}\" shape-rendering=\"optimizeSpeed\">\n                ${this.printChildren(config)}\n            </svg>`;\n        }\n    };\n};\n","import {\n    getDefaultTheme,\n    getBlurredTheme,\n    getBlackAndWhiteTheme,\n    getLightTheme,\n    applyStyleToTheme,\n    buildColorsBasedTheme\n} from './appearance/StyleThemeFactory';\nimport { buildSVGObjectsTree } from './svgObjectsBuilder';\nimport { traversal } from 'shared/utils/traversal';\nimport { flatTree } from 'shared/utils/flatten';\nimport { logError } from 'shared/utils/logger';\n\nexport const ShapesTreeEditor = svgObjectsTree => {\n    const updateShapeTheme = (shape, shapeStyles, connectionArrowStyles) => {\n        if (shapeStyles) {\n            shape.updateTheme(shapeStyles);\n        }\n\n        if (connectionArrowStyles) {\n            shape.getAssignedConnectionArrow().updateTheme(connectionArrowStyles);\n            shape.getLoopedConnectionArrow &&\n                shape.getLoopedConnectionArrow().updateTheme(connectionArrowStyles);\n        }\n    };\n\n    return {\n        findShape(fnTest, startIndex = 0) {\n            return svgObjectsTree\n                .getShapes()\n                .filter((shape, index) => index >= startIndex && fnTest(shape));\n        },\n\n        applyShapeStyles(fn, shapeStyles, connectionArrowStyles) {\n            this.findShape(fn).forEach(shape => {\n                updateShapeTheme(shape, shapeStyles, connectionArrowStyles);\n            });\n        },\n\n        blur(fn) {\n            const blurredTheme = getBlurredTheme();\n\n            this.findShape(fn).forEach(shape => {\n                const connectionArrow = shape.getAssignedConnectionArrow();\n\n                updateShapeTheme(\n                    shape,\n                    blurredTheme[shape.getShapeType()],\n                    connectionArrow ? blurredTheme[connectionArrow.getFieldName()] : null\n                );\n            });\n        },\n\n        focus(fn) {\n            this.blur(shape => !fn(shape));\n        },\n\n        blurShapeBranch(fn) {\n            const blurredTheme = getBlurredTheme();\n\n            this.findShape(fn).forEach(shapeBranch =>\n                traversal(\n                    shapeBranch,\n                    shape => {\n                        const connectionArrow = shape.getAssignedConnectionArrow();\n\n                        updateShapeTheme(\n                            shape,\n                            blurredTheme[shape.getShapeType()],\n                            connectionArrow ? blurredTheme[connectionArrow.getFieldName()] : null\n                        );\n                    },\n                    shape => shape.state.body\n                )\n            );\n        },\n\n        focusShapeBranch(fns) {\n            const blurredTheme = getBlurredTheme();\n\n            [].concat(fns).forEach((fn, index) => {\n                this.findShape(fn).forEach(shapeBranch => {\n                    const flatShape = flatTree(shapeBranch, shape => shape.state.body);\n                    let branchIndex = svgObjectsTree.getShapes().indexOf(shapeBranch);\n\n                    this.findShape(\n                        shape => !flatShape.includes(shape),\n                        index > 0 ? branchIndex : 0\n                    ).forEach(shape => {\n                        const connectionArrow = shape.getAssignedConnectionArrow();\n\n                        updateShapeTheme(\n                            shape,\n                            blurredTheme[shape.getShapeType()],\n                            connectionArrow ? blurredTheme[connectionArrow.getFieldName()] : null\n                        );\n                    });\n                });\n            });\n        },\n\n        print(config) {\n            return svgObjectsTree && svgObjectsTree.print(config);\n        }\n    };\n};\n\nexport default (customStyleTheme = {}) => {\n    let theme = applyStyleToTheme(getDefaultTheme(), customStyleTheme);\n\n    return {\n        buildShapesTree(flowTree) {\n            let shapes = [];\n\n            try {\n                shapes = buildSVGObjectsTree(flowTree, theme);\n            } catch (e) {\n                logError('Error at buildShapesTree' + e.message, e.stack);\n                throw e;\n            }\n\n            return shapes;\n        },\n\n        applyTheme(newThemeStyles) {\n            theme = applyStyleToTheme(theme, newThemeStyles);\n        },\n\n        applyDefaultTheme() {\n            this.applyTheme(getDefaultTheme());\n        },\n        applyBlackAndWhiteTheme() {\n            this.applyTheme(getBlackAndWhiteTheme());\n        },\n        applyBlurredTheme() {\n            this.applyTheme(getBlurredTheme());\n        },\n        applyLightTheme() {\n            this.applyTheme(getLightTheme());\n        },\n\n        applyColorBasedTheme(colors) {\n            this.applyTheme(buildColorsBasedTheme(colors));\n        }\n    };\n};\n","import { mergeObjectStructures } from 'shared/utils/composition';\n\nimport DEFAULT, { buildTheme } from './themes/DefaultBaseTheme';\nimport BLACK_AND_WHITE from './themes/BlackAndWhite';\nimport BLURRED from './themes/Blurred';\nimport LIGHT from './themes/Light';\n\nconst ThemeNamesMap = {\n    DEFAULT: 'DEFAULT',\n    BLACK_AND_WHITE: 'BLACK_AND_WHITE',\n    BLURRED: 'BLURRED',\n    LIGHT: 'LIGHT'\n};\n\nexport const Themes = {\n    [ThemeNamesMap.DEFAULT]: DEFAULT,\n    [ThemeNamesMap.BLACK_AND_WHITE]: BLACK_AND_WHITE,\n    [ThemeNamesMap.BLURRED]: BLURRED,\n    [ThemeNamesMap.LIGHT]: LIGHT\n};\n\nexport const getTheme = themeName => {\n    if ((!Themes[themeName] === themeName) === ThemeNamesMap.DEFAULT) {\n        return Themes.DEFAULT;\n    }\n\n    return applyStyleToTheme(DEFAULT, Themes[themeName]);\n};\n\nexport const getDefaultTheme = () => getTheme(ThemeNamesMap.DEFAULT);\n\nexport const getBlackAndWhiteTheme = () => getTheme(ThemeNamesMap.BLACK_AND_WHITE);\n\nexport const getBlurredTheme = () => getTheme(ThemeNamesMap.BLURRED);\n\nexport const getLightTheme = () => getTheme(ThemeNamesMap.LIGHT);\n\nexport const applyStyleToTheme = (theme, styles) => mergeObjectStructures(theme, styles);\n\nexport const buildColorsBasedTheme = colors => buildTheme(colors);\n","import { buildIterator } from 'shared/utils/iteratorBuilder';\n\nexport const MAX_NAME_STR_LENGTH = 50;\n\nexport const NAME_SPLITTER_TOKENS = [\n    '||',\n    '&&',\n    '=',\n    '?',\n    ':',\n    '<==',\n    '>==',\n    '<',\n    '>',\n    '===',\n    '==',\n    ',',\n    '.',\n    '('\n];\n\nexport const getNameSplitterTokensIterator = () => buildIterator(NAME_SPLITTER_TOKENS);\n","import { buildTheme, DefaultColors, getAlignedColors } from './DefaultBaseTheme';\n\nexport const Colors = {\n    ...getAlignedColors(DefaultColors, '#A6A6A6'),\n\n    strokeColor: '#333',\n    defaultFillColor: '#A6A6A6',\n    textColor: '#333',\n    arrowFillColor: '#333'\n};\n\nexport default buildTheme(Colors);\n","import { buildTheme } from './DefaultBaseTheme';\n\nexport const Colors = {\n    strokeColor: '#ccc',\n    defaultFillColor: '#fff',\n    textColor: '#ccc',\n    arrowFillColor: '#ccc',\n    rectangleFillColor: '#ede7f6',\n    rectangleDotFillColor: '#ede7f6',\n    functionFillColor: '#f1f8e9',\n    rootCircleFillColor: '#fffde7',\n    loopFillColor: '#e3f2fd',\n    conditionFillColor: '#f3e5f5',\n    destructedNodeFillColor: '#fff8e1',\n    classFillColor: '#e0f2f1',\n    debuggerFillColor: '#ffebee',\n    exportFillColor: '#e1f5fe',\n    throwFillColor: '#fce4ec',\n    tryFillColor: '#fff8e1',\n    objectFillColor: '#f9fbe7',\n    callFillColor: '#f9fbe7',\n    debugModeFillColor: '#666'\n};\n\nexport default buildTheme(Colors);\n","export const DefaultColors = {\n    strokeColor: '#444',\n    defaultFillColor: '#fff',\n    textColor: '#222',\n    arrowFillColor: '#333',\n    rectangleFillColor: '#90caf9',\n    rectangleDotFillColor: '#ede7f6',\n    functionFillColor: '#a5d6a7',\n    rootCircleFillColor: '#fff59d',\n    loopFillColor: '#b39ddb',\n    conditionFillColor: '#ce93d8',\n    destructedNodeFillColor: '#ffcc80',\n    classFillColor: '#80cbc4',\n    debuggerFillColor: '#EF5350',\n    exportFillColor: '#81d4fa',\n    throwFillColor: '#ef9a9a',\n    tryFillColor: '#FFE082',\n    objectFillColor: '#9fa8da',\n    callFillColor: '#C5E1A5',\n    debugModeFillColor: '#666'\n};\n\nexport const buildTheme = color => {\n    const BaseShape = {\n        strokeColor: color.strokeColor,\n        strokeWidth: 1,\n        fillColor: color.defaultFillColor,\n        textColor: color.textColor,\n        fontFamily: 'monospace',\n        fontSize: 13,\n        lineHeight: 5, //depends on fontSize\n        symbolHeight: 10, //depends on fontSize\n        symbolWidth: 7.8, //depends on fontSize\n        horizontalPadding: 15,\n        verticalPadding: 10,\n        childOffset: 37,\n        margin: 10,\n        roundBorder: 2,\n        complexTypeExtraSpace: 15,\n\n        debugFontSize: 8,\n        debugTextColor: color.debugModeFillColor\n    };\n\n    return {\n        BaseShape,\n        ConnectionArrow: {\n            arrow: {\n                size: {\n                    x: 8,\n                    y: 6\n                },\n                fillColor: color.arrowFillColor\n            },\n            line: {\n                strokeColor: color.strokeColor,\n                strokeWidth: 1,\n                curveTurnRadius: 4\n            },\n            lineTurnOffset: 20\n        },\n\n        Shape: {\n            ...BaseShape\n        },\n\n        Rectangle: {\n            ...BaseShape,\n            fillColor: color.rectangleFillColor,\n            dot: {\n                ...BaseShape,\n                offset: 4,\n                radius: 2,\n                fillColor: color.rectangleDotFillColor\n            },\n            roundBorder: 3\n        },\n\n        VerticalEdgedRectangle: {\n            ...BaseShape,\n            fillColor: color.functionFillColor,\n            edgeOffset: 10\n        },\n\n        RootCircle: {\n            ...BaseShape,\n            radius: 15,\n            padding: 3,\n            fillColor: color.rootCircleFillColor\n        },\n\n        LoopRhombus: {\n            ...BaseShape,\n            fillColor: color.loopFillColor,\n            thinPartOffset: 15,\n            rhombusSize: 50,\n            roundBorder: 3,\n            doubleLayerOffsetA: 4,\n            doubleLayerOffsetB: 8,\n            childOffset: 20,\n            positionTopShift: 20\n        },\n\n        ConditionRhombus: {\n            ...BaseShape,\n            fillColor: color.conditionFillColor,\n            thinPartOffset: 15,\n            roundBorder: 3,\n            childOffset: 20,\n            alternateBranchOffset: 40,\n            markOffset: {\n                x: 15,\n                y: 5\n            },\n            margin: 20\n        },\n\n        RootStartPoint: {\n            center: {\n                x: 25,\n                y: 25\n            },\n            childOffset: {\n                x: 25,\n                y: 65\n            }\n        },\n\n        ReturnStatement: {\n            ...BaseShape,\n            roundBorder: 3,\n            fillColor: color.rectangleFillColor,\n            arrow: {\n                ...BaseShape,\n                handlerLength: 5,\n                sizeX: 16,\n                sizeY: 22,\n                fillColor: color.functionFillColor\n            }\n        },\n\n        DestructedNode: {\n            ...BaseShape,\n            fillColor: color.destructedNodeFillColor,\n            roundBorder: 2,\n            suffix: {\n                ...BaseShape,\n                roundBorder: 2,\n                fillColor: color.destructedNodeFillColor,\n                width: 8,\n                space: 4\n            }\n        },\n\n        ClassDeclaration: {\n            ...BaseShape,\n            fillColor: color.classFillColor,\n            edgeOffset: 10\n        },\n\n        DebuggerStatement: {\n            ...BaseShape,\n            fillColor: color.debuggerFillColor,\n            roundBorder: 2\n        },\n\n        ExportDeclaration: {\n            ...BaseShape,\n            roundBorder: 3,\n            fillColor: color.exportFillColor,\n            arrow: {\n                ...BaseShape,\n                handlerLength: 5,\n                sizeX: 20,\n                sizeY: 28,\n                fillColor: color.defaultFillColor\n            }\n        },\n\n        ImportDeclaration: {\n            ...BaseShape,\n            fillColor: color.defaultFillColor,\n            edgeOffset: 5\n        },\n\n        ImportSpecifier: {\n            ...BaseShape,\n            fillColor: color.exportFillColor\n        },\n\n        ThrowStatement: {\n            ...BaseShape,\n            fillColor: color.throwFillColor\n        },\n\n        TryStatement: {\n            ...BaseShape,\n            fillColor: color.tryFillColor\n        },\n\n        CatchClause: {\n            ...BaseShape,\n            fillColor: color.throwFillColor,\n            arrow: {\n                ...BaseShape,\n                handlerLength: 2,\n                sizeX: 16,\n                sizeY: 28,\n                fillColor: color.throwFillColor\n            }\n        },\n\n        SwitchStatement: {\n            ...BaseShape,\n            fillColor: color.conditionFillColor,\n            thinPartOffset: 15,\n            roundBorder: 3,\n            childOffset: 20,\n            alternateBranchOffset: 40,\n            markOffset: {\n                x: 15,\n                y: 5\n            },\n            margin: 20\n        },\n\n        BreakStatement: {\n            ...BaseShape,\n            fillColor: color.rectangleFillColor,\n            arrow: {\n                ...BaseShape,\n                handlerLength: 5,\n                sizeX: 16,\n                sizeY: 28,\n                fillColor: color.conditionFillColor\n            }\n        },\n\n        SwitchCase: {\n            ...BaseShape,\n            fillColor: color.conditionFillColor\n        },\n\n        ContinueStatement: {\n            ...BaseShape,\n            fillColor: color.rectangleFillColor,\n            arrow: {\n                ...BaseShape,\n                handlerLength: 5,\n                sizeX: 16,\n                sizeY: 28,\n                fillColor: color.loopFillColor\n            }\n        },\n\n        ObjectProperty: {\n            ...BaseShape,\n            fillColor: color.rectangleFillColor\n        },\n\n        CallExpression: {\n            ...BaseShape,\n            dot: {\n                ...BaseShape,\n                offset: 6,\n                radius: 4,\n                fillColor: color.rectangleDotFillColor\n            },\n            fillColor: color.callFillColor\n        }\n    };\n};\n\nexport default buildTheme(DefaultColors);\n\nexport const getAlignedColors = (theme, defaultColor) => {\n    const themeCopy = { ...theme };\n    Object.keys(themeCopy).forEach(color => {\n        themeCopy[color] = defaultColor;\n    });\n\n    return themeCopy;\n};\n","import { buildTheme } from './DefaultBaseTheme';\n\nexport const Colors = {\n    strokeColor: '#555',\n    defaultFillColor: '#fff',\n    textColor: '#333',\n    arrowFillColor: '#444',\n    rectangleFillColor: '#bbdefb',\n    rectangleDotFillColor: '#ede7f6',\n    functionFillColor: '#c8e6c9',\n    rootCircleFillColor: '#fff9c4',\n    loopFillColor: '#d1c4e9',\n    conditionFillColor: '#e1bee7',\n    destructedNodeFillColor: '#ffecb3',\n    classFillColor: '#b2dfdb',\n    debuggerFillColor: '#ffcdd2',\n    exportFillColor: '#b3e5fc',\n    throwFillColor: '#ffccbc',\n    tryFillColor: '#FFE082',\n    objectFillColor: '#d1c4e9',\n    callFillColor: '#dcedc8',\n    debugModeFillColor: '#666'\n};\n\nexport default buildTheme(Colors);\n","import { assignState, mergeObjectStructures } from 'shared/utils/composition';\nimport { getCurvedPath, getClosedPath } from 'shared/utils/svgPrimitives';\nimport { addOffsetToPoints } from 'shared/utils/geometry';\n\nimport { ARROW_TYPE } from 'shared/constants';\n\nconst ENTITY_FIELD_NAME = 'ConnectionArrow';\n\nexport const getFieldName = () => {\n    return ENTITY_FIELD_NAME;\n};\n\nconst setupSelectors = state => ({\n    getFieldName\n});\n\nconst setupUpdateBehaviour = state => ({\n    updateTheme(newTheme) {\n        state.theme = mergeObjectStructures(state.theme, newTheme);\n    }\n});\n\nconst setupPrintBehaviour = state => ({\n    printLine(points) {\n        return getCurvedPath(points, state.theme.line);\n    },\n\n    printArrow(point, arrowPoints) {\n        return getClosedPath(addOffsetToPoints(arrowPoints, point), state.theme.arrow);\n    },\n\n    printArrowByType(type, { x, y }) {\n        const arrowSize = state.theme.arrow.size;\n        let point;\n\n        //TODO: move to svgPrimitives\n        switch (type) {\n            case ARROW_TYPE.RIGHT:\n                point = { x: x - arrowSize.x, y: y - arrowSize.y / 2 };\n\n                return this.printArrow(point, [\n                    { x: 0, y: 0 },\n                    { x: arrowSize.x, y: arrowSize.y / 2 },\n                    { x: 0, y: arrowSize.y }\n                ]);\n\n            case ARROW_TYPE.LEFT:\n                point = { x: x, y: y - arrowSize.y / 2 };\n\n                return this.printArrow(point, [\n                    { x: 0, y: arrowSize.y / 2 },\n                    { x: arrowSize.x, y: 0 },\n                    { x: arrowSize.x, y: arrowSize.y }\n                ]);\n\n            case ARROW_TYPE.DOWN:\n                point = { x: x - arrowSize.y / 2, y: y - arrowSize.x };\n\n                return this.printArrow(point, [\n                    { x: 0, y: 0 },\n                    { x: arrowSize.y / 2, y: arrowSize.x },\n                    { x: arrowSize.y, y: 0 }\n                ]);\n\n            default:\n                return '';\n        }\n    },\n\n    print() {\n        const { linePoints, arrowPoint, arrowType, noArrow } = state.config;\n\n        if (noArrow) {\n            linePoints[linePoints.length - 1].x += state.theme.arrow.size.x;\n        }\n\n        return `\n            <g>\n               ${this.printLine(linePoints)}\n               ${!noArrow && this.printArrowByType(arrowType, arrowPoint)}\n            </g>`;\n    }\n});\n\nexport const ConnectionArrow = state =>\n    assignState(state, [setupUpdateBehaviour, setupPrintBehaviour, setupSelectors]);\n\nexport default (config, theme) => ConnectionArrow({ config, theme, originalTheme: theme });\n","import escape from 'xml-escape';\nimport { mergeObjectStructures } from 'shared/utils/composition';\nimport {\n    generateId,\n    splitNameString,\n    getMaxStringLengthFromList,\n    getPathId\n} from 'shared/utils/string';\nimport { flatTree } from 'shared/utils/flatten';\nimport { calculateShapesBoundaries } from 'shared/utils/geometry';\nimport {\n    MAX_NAME_STR_LENGTH,\n    getNameSplitterTokensIterator\n} from '../appearance/TextContentConfigurator';\n\nexport const delegateInit = (shape, themeFieldName) => {\n    function init(node, position, theme) {\n        return shape(getInitialState(node, position, theme, themeFieldName));\n    }\n\n    init.getThemeFieldName = () => {\n        return themeFieldName;\n    };\n\n    return init;\n};\n\nexport const getInitialState = (node, { x, y }, theme, type) => {\n    const nameParts = splitNameString(\n            node.name,\n            MAX_NAME_STR_LENGTH,\n            getNameSplitterTokensIterator()\n        ),\n        totalNamePartsNumber = nameParts.length,\n        maxNamePartLength = getMaxStringLengthFromList(nameParts);\n\n    return {\n        id: generateId(),\n        nodePathId: getPathId(node),\n        type,\n        body: [],\n        theme,\n        originalTheme: theme,\n        node,\n        name: node.name,\n        prefixName: node.prefixName,\n        nameParts,\n        totalNamePartsNumber,\n        maxNamePartLength,\n        initialPosition: { x, y }\n    };\n};\n\nexport const setupInitialProperties = state => ({\n    fromPoint: calculateFromPoint(state),\n    toPoint: calculateToPoint(state),\n    backPoint: calculateBackPoint(state),\n    childOffsetPoint: calculateChildOffsetPoint(state),\n    boundaries: calculateBoundaries(state)\n});\n\nexport const extractBasicState = state => ({\n    ...state,\n    position: calculatePosition(state),\n    dimensions: calculateDimensions(state)\n});\n\nexport const setupInitialSelectors = state => ({\n    getBody() {\n        return state.body;\n    },\n\n    getBoundaries() {\n        return state.boundaries;\n    },\n\n    getBackPoint() {\n        return state.backPoint;\n    },\n\n    getAssignedConnectionArrow() {\n        return state.connectionArrow;\n    },\n\n    getChildOffsetPoint() {\n        return state.childOffsetPoint;\n    },\n\n    getDimensions() {\n        return state.dimensions;\n    },\n\n    getId() {\n        return state.id;\n    },\n\n    getFromPoint() {\n        return state.fromPoint;\n    },\n\n    getMargin() {\n        return state.theme.margin;\n    },\n\n    getName() {\n        return state.name;\n    },\n\n    getNode() {\n        return state.node;\n    },\n\n    getNodeType() {\n        return state.node.type;\n    },\n\n    getNodePathId() {\n        return state.nodePathId;\n    },\n\n    getNodeKey() {\n        return state.node.key;\n    },\n\n    getParent() {\n        return state.parent;\n    },\n\n    getPosition() {\n        return state.position;\n    },\n\n    getToPoint() {\n        return state.toPoint;\n    },\n\n    getShapeType() {\n        return state.type;\n    }\n});\n\nexport const setupSharedPrint = state => ({\n    //TODO: fix spacing for multi line name\n    printName(newPosition) {\n        const { position, theme, nameParts } = state;\n        const { x, y } = newPosition ? newPosition : position;\n        const name = nameParts\n            .map(\n                (part, i) =>\n                    `<tspan x=\"${x + theme.horizontalPadding}\" y=\"${y +\n                        2 * theme.verticalPadding * (i + 1)}\">${escape(part)}</tspan>`\n            )\n            .join('');\n\n        //TODO: move to svg primitives\n        // 3 because of ellipsis 3 dots\n        return `${\n            nameParts[0].length <= state.name.length + 3\n                ? `<title>${escape(state.name)}</title>`\n                : ''\n        }\n            <text x=\"${x + theme.horizontalPadding}\" y=\"${y + 2 * theme.verticalPadding}\"\n                font-family=\"${theme.fontFamily}\" font-size=\"${theme.fontSize}\" fill=\"${\n            theme.textColor\n        }\">\n                ${name}\n            </text>`;\n    },\n\n    printDebugInfo({ debug } = {}) {\n        if (!debug) return '';\n\n        const { position, dimensions, theme, nodePathId } = state;\n\n        return `<text x=\"${position.x + 3 * theme.horizontalPadding}\" y=\"${position.y +\n            dimensions.h +\n            theme.verticalPadding}\"\n                font-family=\"${theme.fontFamily}\" font-size=\"${theme.debugFontSize}\" fill=\"${\n            theme.debugTextColor\n        }\">\n                ${nodePathId}\n            </text>`;\n    }\n});\n\nexport const setupGetChildBoundaries = state => ({\n    getChildBoundaries(filterFn) {\n        const { body, boundaries } = state;\n\n        if (!body.length) {\n            return boundaries;\n        }\n\n        const flattedTree = flatTree(\n            {\n                getBody: () => (filterFn ? body.filter(filterFn) : body),\n                getBoundaries: () => boundaries\n            },\n            node => node.getBody()\n        );\n\n        return calculateShapesBoundaries(flattedTree.map(item => item.getBoundaries()));\n    }\n});\n\nexport const setupStateModifiers = state => ({\n    addChild(child) {\n        state.body.push(child);\n    },\n\n    setParent(parent) {\n        state.parent = parent;\n    },\n\n    connectChild(child) {\n        this.addChild(child);\n        child.setParent(this);\n    },\n\n    updateTheme(newTheme) {\n        state.theme = mergeObjectStructures(state.theme, newTheme);\n    },\n    assignConnectionArrow(connectionArrow) {\n        state.connectionArrow = connectionArrow;\n    }\n});\n\nexport const setupBasicBehaviour = state =>\n    Object.assign(\n        {},\n        setupSharedPrint(state),\n        setupGetChildBoundaries(state),\n        setupStateModifiers(state)\n    );\n\nexport const setupCompleteState = initialState => {\n    let state = extractBasicState(initialState);\n    return { ...state, ...setupInitialProperties(state) };\n};\n\nexport const calculateNameBasedWidth = ({ maxNamePartLength, theme }) =>\n    maxNamePartLength * theme.symbolWidth;\n\nexport const calculateNameBasedHeight = ({ totalNamePartsNumber, theme }) =>\n    totalNamePartsNumber * theme.symbolHeight + (totalNamePartsNumber - 1) * theme.lineHeight;\n\nexport const calculateWidth = state =>\n    2 * state.theme.horizontalPadding + calculateNameBasedWidth(state);\n\nexport const calculateHeight = state =>\n    2 * state.theme.verticalPadding + calculateNameBasedHeight(state);\n\nexport const calculateDimensions = state => ({\n    w: calculateWidth(state),\n    h: calculateHeight(state)\n});\n\nexport const calculatePosition = state => ({ ...state.initialPosition });\n\nexport const calculateFromPoint = ({ position, dimensions, theme }) => ({\n    x: position.x + theme.childOffset / 2,\n    y: position.y + dimensions.h\n});\n\nexport const calculateToPoint = ({ position, dimensions }) => ({\n    x: position.x,\n    y: position.y + dimensions.h / 2\n});\n\nexport const calculateBackPoint = ({ position, dimensions }) => ({\n    x: position.x + dimensions.w,\n    y: position.y + dimensions.h / 2\n});\n\nexport const calculateChildOffsetPoint = ({ theme, dimensions }) => ({\n    x: theme.childOffset,\n    y: dimensions.h + theme.childOffset / 2\n});\n\nexport const calculateBoundaries = ({ position, dimensions }) => ({\n    min: { x: position.x, y: position.y },\n    max: { x: position.x + dimensions.w, y: position.y + dimensions.h }\n});\n","import { delegateInit } from './BaseShape';\nimport { ReturnStatement } from './ReturnStatement';\n\nconst ENTITY_FIELD_NAME = 'BreakStatement';\n\nexport default delegateInit(ReturnStatement, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { Rectangle } from './Rectangle';\n\nconst ENTITY_FIELD_NAME = 'CallExpression';\n\nexport default delegateInit(Rectangle, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { ReturnStatement } from './ReturnStatement';\n\nconst ENTITY_FIELD_NAME = 'CatchClause';\n\nexport default delegateInit(ReturnStatement, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { VerticalEdgedRectangle } from './VerticalEdgedRectangle';\n\nconst ENTITY_FIELD_NAME = 'ClassDeclaration';\n\nexport default delegateInit(VerticalEdgedRectangle, ENTITY_FIELD_NAME);\n","import { TOKEN_KEYS, TOKEN_TYPES } from 'shared/constants';\nimport { getRhombus, getRoundedRectangle, getText } from 'shared/utils/svgPrimitives';\nimport { assignState } from 'shared/utils/composition';\n\nimport {\n    setupBasicBehaviour,\n    setupInitialSelectors,\n    calculateBackPoint,\n    calculateBoundaries,\n    calculatePosition,\n    delegateInit\n} from './BaseShape';\n\nimport { calculateDimensions, calculateFromPoint, calculateChildOffsetPoint } from './Rhombus';\n\nconst ENTITY_FIELD_NAME = 'ConditionRhombus';\n\nconst calculateAlternateFromPoint = ({ position, dimensions }) => ({\n    x: position.x + dimensions.w,\n    y: position.y + dimensions.h / 2\n});\n\nconst calculateToPoint = ({ position, dimensions }) => ({\n    x: position.x,\n    y: position.y + dimensions.h / 2\n});\n\nconst setupInitialProperties = state => ({\n    fromPoint: calculateFromPoint(state),\n    childOffsetPoint: calculateChildOffsetPoint(state),\n    toPoint: calculateToPoint(state),\n    backPoint: calculateBackPoint(state),\n    boundaries: calculateBoundaries(state),\n\n    alternateFromPoint: calculateAlternateFromPoint(state)\n});\n\nconst setupAdditionalSelectors = state => ({\n    getAlternateFromPoint() {\n        return state.alternateFromPoint;\n    }\n});\n\nexport const setupConditionRhombusBehavior = state => ({\n    getConsequentBranchChildBoundary() {\n        return this.getChildBoundaries(child => child.state.node.key === TOKEN_KEYS.CONSEQUENT);\n    },\n\n    getAlternativeBranchChildOffsetPoint() {\n        const theme = state.theme,\n            position = {};\n\n        position.y = state.position.y + state.childOffsetPoint.y;\n\n        position.x = this.getConsequentBranchChildBoundary().max.x;\n        position.x += theme.alternateBranchOffset;\n\n        const rightLimit = state.position.x + state.dimensions.w + theme.childOffset;\n        if (position.x <= rightLimit) {\n            position.x = rightLimit;\n        }\n\n        return position;\n    },\n\n    checkIfChildExist(key) {\n        return state.body.filter(shape => shape.getNodeKey() === key).length;\n    },\n\n    printConditionMarks() {\n        const theme = state.theme;\n        const { x, y } = state.position,\n            R = state.dimensions.h,\n            w = state.dimensions.w,\n            node = state.node;\n\n        const text = node.subType === TOKEN_TYPES.CONDITIONAL_EXPRESSION ? '?' : 'if',\n            positive = '+',\n            alternative = '-';\n\n        return `${getText(\n            x + R / 2 - text.length * theme.symbolWidth / 2,\n            y + R / 2 + theme.symbolHeight / 2,\n            theme,\n            text\n        )} ${getText(\n            x + R / 2 + theme.symbolWidth,\n            y + R + theme.symbolWidth / 4,\n            theme,\n            positive\n        )} ${\n            this.checkIfChildExist(TOKEN_KEYS.ALTERNATE)\n                ? getText(\n                      x + w + theme.symbolWidth / 2,\n                      y + R / 2 - theme.symbolWidth / 4,\n                      theme,\n                      alternative\n                  )\n                : ''\n        }`;\n    },\n\n    print(config) {\n        const theme = state.theme,\n            { x, y } = state.position,\n            { w, h } = state.dimensions;\n\n        const R = h,\n            rH = h - 2 * theme.thinPartOffset;\n\n        const namePosition = {\n            x: x + R,\n            y: y + rH / 2\n        };\n\n        return `<g>\n            ${getRoundedRectangle(x + h / 2, y + h / 4, w - R / 2, rH, theme)}                \n            ${getRhombus(x, y, R, R, theme)}\n            ${this.printName(namePosition)}\n            ${this.printDebugInfo(config)}\n            ${this.printConditionMarks()}\n        </g>`;\n    }\n});\n\nconst extractBasicState = state => ({\n    ...state,\n    position: calculatePosition(state),\n    dimensions: calculateDimensions(state)\n});\n\nexport const ConditionRhombus = initialState => {\n    let state = extractBasicState(initialState);\n\n    state = { ...state, ...setupInitialProperties(state) };\n\n    return assignState(state, [\n        setupInitialSelectors,\n        setupAdditionalSelectors,\n        setupBasicBehaviour,\n        setupConditionRhombusBehavior\n    ]);\n};\n\nexport default delegateInit(ConditionRhombus, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { ReturnStatement } from './ReturnStatement';\n\nconst ENTITY_FIELD_NAME = 'ContinueStatement';\n\nexport default delegateInit(ReturnStatement, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { Rectangle } from './Rectangle';\n\nconst ENTITY_FIELD_NAME = 'DebuggerStatement';\n\nexport default delegateInit(Rectangle, ENTITY_FIELD_NAME);\n","import { getRoundedRectangle, getLine, getClosedPath } from 'shared/utils/svgPrimitives';\nimport { assignState } from 'shared/utils/composition';\nimport { addOffsetToPoints } from 'shared/utils/geometry';\n\nimport {\n    setupBasicBehaviour,\n    setupInitialProperties,\n    setupInitialSelectors,\n    calculateHeight,\n    calculateNameBasedWidth,\n    calculatePosition,\n    delegateInit\n} from './BaseShape';\n\nconst ENTITY_FIELD_NAME = 'DestructedNode';\n\nconst setupDestructedNodeBehaviour = state => ({\n    print(config) {\n        const theme = state.theme,\n            suffixTheme = theme.suffix;\n\n        const { x, y } = state.position,\n            h = state.dimensions.h,\n            w = state.dimensions.w - 2 * (suffixTheme.width + suffixTheme.space),\n            namePosition = { x, y };\n\n        const suffix1 = getRoundedRectangle(\n            x + w + suffixTheme.space,\n            y,\n            suffixTheme.width,\n            h,\n            suffixTheme\n        );\n        const suffix2 = getRoundedRectangle(\n            x + w + 2 * suffixTheme.space + suffixTheme.width,\n            y,\n            suffixTheme.width,\n            h,\n            suffixTheme\n        );\n\n        return `\n            <g>\n                ${getRoundedRectangle(x, y, w, h, theme)}\n                \n                ${suffix1}\n                ${suffix2}\n                             \n                ${this.printName(namePosition)}\n                ${this.printDebugInfo(config)}\n            </g>`;\n    }\n});\n\nconst calculateWidth = state => {\n    const theme = state.theme,\n        suffix = theme.suffix;\n\n    return (\n        2 * theme.horizontalPadding +\n        2 * (suffix.width + +suffix.space) +\n        calculateNameBasedWidth(state)\n    );\n};\n\nconst calculateDimensions = state => ({\n    w: calculateWidth(state),\n    h: calculateHeight(state)\n});\n\nconst extractBasicState = state => ({\n    ...state,\n    position: calculatePosition(state),\n    dimensions: calculateDimensions(state)\n});\n\nexport const DestructedNode = initialState => {\n    let state = extractBasicState(initialState);\n\n    state = { ...state, ...setupInitialProperties(state) };\n\n    return assignState(state, [\n        setupInitialSelectors,\n        setupBasicBehaviour,\n        setupDestructedNodeBehaviour\n    ]);\n};\n\nexport default delegateInit(DestructedNode, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { ReturnStatement } from './ReturnStatement';\n\nconst ENTITY_FIELD_NAME = 'ExportDeclaration';\n\nexport default delegateInit(ReturnStatement, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { VerticalEdgedRectangle } from './VerticalEdgedRectangle';\n\nconst ENTITY_FIELD_NAME = 'ImportDeclaration';\n\nexport default delegateInit(VerticalEdgedRectangle, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { Rectangle } from './Rectangle';\n\nconst ENTITY_FIELD_NAME = 'ImportSpecifier';\n\nexport default delegateInit(Rectangle, ENTITY_FIELD_NAME);\n","import { getRhombus, getRoundedRectangle, getText } from 'shared/utils/svgPrimitives';\nimport { assignState } from 'shared/utils/composition';\nimport { TOKEN_TYPES } from 'shared/constants';\n\nimport {\n    setupBasicBehaviour,\n    setupInitialSelectors,\n    calculateToPoint,\n    calculateBackPoint,\n    calculateBoundaries,\n    delegateInit\n} from './BaseShape';\n\nimport { calculateDimensions, calculateFromPoint, calculateChildOffsetPoint } from './Rhombus';\n\nconst ENTITY_FIELD_NAME = 'LoopRhombus';\n\nconst LoopMarksMap = {\n    [TOKEN_TYPES.FOR_OF_STATEMENT]: 'for',\n    [TOKEN_TYPES.FOR_IN_STATEMENT]: 'for',\n    [TOKEN_TYPES.FOR_STATEMENT]: 'for',\n    [TOKEN_TYPES.WHILE_STATEMENT]: 'while',\n    [TOKEN_TYPES.DO_WHILE_STATEMENT]: 'while'\n};\n\nconst calculateMidPoint = ({ position, dimensions }) => ({\n    x: position.x + dimensions.h / 2,\n    y: position.y\n});\n\nconst setupInitialProperties = state => ({\n    fromPoint: calculateFromPoint(state),\n    childOffsetPoint: calculateChildOffsetPoint(state),\n    toPoint: calculateToPoint(state),\n    backPoint: calculateBackPoint(state),\n    boundaries: calculateBoundaries(state),\n\n    midPoint: calculateMidPoint(state)\n});\n\nconst setupAdditionalSelectors = state => ({\n    getMidPoint() {\n        return state.midPoint;\n    },\n\n    getLoopedConnectionArrow() {\n        return state.loopedConnectionArrow;\n    }\n});\n\nconst setupLoopRhombusBehavior = state => ({\n    assignLoopedConnectionArrow(loopedConnectionArrow) {\n        state.loopedConnectionArrow = loopedConnectionArrow;\n    },\n\n    printConditionMarks() {\n        const theme = state.theme;\n        const { x, y } = state.position,\n            R = state.dimensions.h,\n            text = state.prefixName || LoopMarksMap[state.node.subType] || 'for';\n\n        return getText(\n            x + R / 2 - text.length * theme.symbolWidth / 2,\n            y + R / 2 + theme.symbolHeight / 2,\n            theme,\n            text\n        );\n    },\n\n    print(config) {\n        const theme = state.theme;\n        const { x, y } = state.position,\n            { w, h } = state.dimensions;\n\n        const R = h,\n            rH = h - 2 * theme.thinPartOffset;\n\n        const namePosition = {\n            x: x + R,\n            y: y + rH / 2\n        };\n\n        return `<g>\n\n            ${getRoundedRectangle(x + h / 2, y + h / 4, w - R / 2, rH, theme)}\n            ${getRhombus(x, y, R, R, theme)}\n                \n            ${this.printName(namePosition)}\n            ${this.printDebugInfo(config)}\n            ${this.printConditionMarks()}\n        </g>`;\n    }\n});\n\nconst calculatePosition = ({ initialPosition, theme }) => ({\n    x: initialPosition.x,\n    y: initialPosition.y + theme.positionTopShift\n});\n\nconst extractBasicState = state => ({\n    ...state,\n    position: calculatePosition(state),\n    dimensions: calculateDimensions(state)\n});\n\nexport const LoopRhombus = initialState => {\n    let state = extractBasicState(initialState);\n\n    state = { ...state, ...setupInitialProperties(state) };\n\n    return assignState(state, [\n        setupInitialSelectors,\n        setupAdditionalSelectors,\n        setupBasicBehaviour,\n        setupLoopRhombusBehavior\n    ]);\n};\n\nexport default delegateInit(LoopRhombus, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { Rectangle } from './Rectangle';\n\nconst ENTITY_FIELD_NAME = 'ObjectProperty';\n\nexport default delegateInit(Rectangle, ENTITY_FIELD_NAME);\n","import { getRoundedRectangle, getCircle } from 'shared/utils/svgPrimitives';\nimport { assignState } from 'shared/utils/composition';\n\nimport {\n    setupCompleteState,\n    setupBasicBehaviour,\n    setupInitialSelectors,\n    delegateInit\n} from './BaseShape';\n\nconst ENTITY_FIELD_NAME = 'Rectangle';\n\nconst setupRectangleBehavior = state => ({\n    print(config = {}) {\n        const theme = state.theme,\n            dotTheme = theme.dot;\n        const { x, y } = state.position,\n            { w, h } = state.dimensions,\n            node = state.node;\n\n        return `\n                <g>\n                   ${getRoundedRectangle(x, y, w, h, theme)}\n                   ${this.printName()}\n                   ${\n                       node.chain\n                           ? getCircle(\n                                 x + dotTheme.offset,\n                                 y + h - dotTheme.offset,\n                                 dotTheme.radius,\n                                 dotTheme\n                             )\n                           : ''\n                   }\n                   ${this.printDebugInfo(config)}\n                </g>`;\n    }\n});\n\nexport const Rectangle = initialState => {\n    const state = setupCompleteState(initialState);\n\n    return assignState(state, [setupInitialSelectors, setupBasicBehaviour, setupRectangleBehavior]);\n};\n\nexport default delegateInit(Rectangle, ENTITY_FIELD_NAME);\n","import { getRoundedRectangle, getLine, getClosedPath } from 'shared/utils/svgPrimitives';\nimport { assignState } from 'shared/utils/composition';\nimport { addOffsetToPoints } from 'shared/utils/geometry';\n\nimport {\n    setupBasicBehaviour,\n    setupInitialProperties,\n    setupInitialSelectors,\n    calculateHeight,\n    calculateNameBasedWidth,\n    calculatePosition,\n    delegateInit\n} from './BaseShape';\n\nconst ENTITY_FIELD_NAME = 'ReturnStatement';\n\nconst setupReturnStatementBehaviour = state => ({\n    print(config) {\n        const theme = state.theme,\n            arrowTheme = theme.arrow;\n\n        const { x, y } = state.position,\n            h = state.dimensions.h,\n            w = state.dimensions.w - arrowTheme.handlerLength - arrowTheme.sizeX,\n            namePosition = { x: x, y };\n\n        //TODO: refactor\n        const arrowSize = { x: arrowTheme.sizeX, y: arrowTheme.sizeY };\n\n        const arrow = getClosedPath(\n            addOffsetToPoints(\n                [{ x: 0, y: 0 }, { x: arrowSize.x, y: arrowSize.y / 2 }, { x: 0, y: arrowSize.y }],\n                {\n                    x: x + w + arrowTheme.handlerLength,\n                    y: y + h / 2 - arrowSize.y / 2\n                }\n            ),\n            arrowTheme\n        );\n\n        return `\n            <g>\n                ${getRoundedRectangle(x, y, w, h, theme)}\n                \n                ${getLine(\n                    x + w,\n                    y + h / 2 - arrowTheme.handlerLength,\n                    x + w + arrowTheme.handlerLength,\n                    y + h / 2 - arrowTheme.handlerLength,\n                    arrowTheme\n                )}\n                \n                ${getLine(\n                    x + w,\n                    y + h / 2 + arrowTheme.handlerLength,\n                    x + w + arrowTheme.handlerLength,\n                    y + h / 2 + arrowTheme.handlerLength,\n                    arrowTheme\n                )}\n\n                ${arrow}\n                             \n                ${this.printName(namePosition)}\n                ${this.printDebugInfo(config)}\n            </g>`;\n    }\n});\n\nconst calculateWidth = state => {\n    const theme = state.theme,\n        arrowTheme = theme.arrow;\n\n    return (\n        2 * theme.horizontalPadding +\n        arrowTheme.handlerLength +\n        arrowTheme.sizeX +\n        calculateNameBasedWidth(state)\n    );\n};\n\nconst calculateDimensions = state => ({\n    w: calculateWidth(state),\n    h: calculateHeight(state)\n});\n\nconst extractBasicState = state => ({\n    ...state,\n    position: calculatePosition(state),\n    dimensions: calculateDimensions(state)\n});\n\nexport const ReturnStatement = initialState => {\n    let state = extractBasicState(initialState);\n\n    state = { ...state, ...setupInitialProperties(state) };\n\n    return assignState(state, [\n        setupInitialSelectors,\n        setupBasicBehaviour,\n        setupReturnStatementBehaviour\n    ]);\n};\n\nexport default delegateInit(ReturnStatement, ENTITY_FIELD_NAME);\n","import {\n    calculateWidth as calculateWidthBaseShape,\n    calculateHeight as calculateHeightBaseHeight\n} from './BaseShape';\n\nexport const calculateDimensions = state => ({\n    w: calculateWidth(state),\n    h: calculateHeight(state)\n});\n\nexport const calculateWidth = state => calculateHeight(state) + calculateWidthBaseShape(state);\nexport const calculateHeight = state =>\n    2 * state.theme.thinPartOffset + calculateHeightBaseHeight(state);\n\nexport const calculateFromPoint = ({ position, dimensions }) => ({\n    x: position.x + dimensions.h / 2,\n    y: position.y + dimensions.h\n});\n\nexport const calculateChildOffsetPoint = ({ dimensions, theme }) => ({\n    x: dimensions.h / 2 + theme.childOffset,\n    y: dimensions.h + theme.childOffset / 2\n});\n","import { getCircle, getRectangle } from 'shared/utils/svgPrimitives';\nimport { assignState } from 'shared/utils/composition';\n\nimport {\n    extractBasicState,\n    setupBasicBehaviour,\n    setupInitialSelectors,\n    calculateBoundaries,\n    delegateInit\n} from './BaseShape';\n\nconst ENTITY_FIELD_NAME = 'RootCircle';\n\nconst calculateFromPoint = ({ position, theme }) => {\n    const r = theme.radius;\n    return { x: position.x, y: position.y + r };\n};\n\nconst setupInitialProperties = state => ({\n    fromPoint: calculateFromPoint(state),\n    boundaries: calculateBoundaries(state)\n});\n\nconst setupCircleBehavior = state => ({\n    print() {\n        const theme = state.theme;\n        const { x, y } = state.position,\n            { w, h } = state.dimensions,\n            r = theme.radius;\n\n        const namePosition = { x: x + r, y: y - r };\n\n        return `\n            <g>\n               ${getRectangle(x, y - r + r / 4, w + r, h - theme.padding * 2, theme)}\n               ${getCircle(x, y, r, theme)}\n               ${this.printName(namePosition)}\n            </g>`;\n    },\n\n    setChildOffsetPoint(point) {\n        state.childOffsetPoint = point;\n    }\n});\n\nexport const RootCircle = initialState => {\n    let state = extractBasicState(initialState);\n\n    state = { ...state, ...setupInitialProperties(state) };\n\n    return assignState(state, [setupInitialSelectors, setupBasicBehaviour, setupCircleBehavior]);\n};\n\nexport default delegateInit(RootCircle, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { Rectangle } from './Rectangle';\n\nconst ENTITY_FIELD_NAME = 'SwitchCase';\n\nexport default delegateInit(Rectangle, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { ConditionRhombus } from './ConditionRhombus';\n\nconst ENTITY_FIELD_NAME = 'SwitchStatement';\n\nexport default delegateInit(ConditionRhombus, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { Rectangle } from './Rectangle';\n\nconst ENTITY_FIELD_NAME = 'ThrowStatement';\n\nexport default delegateInit(Rectangle, ENTITY_FIELD_NAME);\n","import { delegateInit } from './BaseShape';\nimport { Rectangle } from './Rectangle';\n\nconst ENTITY_FIELD_NAME = 'TryStatement';\n\nexport default delegateInit(Rectangle, ENTITY_FIELD_NAME);\n","import { getRectangle, getLine } from 'shared/utils/svgPrimitives';\nimport { assignState } from 'shared/utils/composition';\n\nimport {\n    setupBasicBehaviour,\n    setupInitialProperties,\n    setupInitialSelectors,\n    calculateHeight,\n    calculateNameBasedWidth,\n    calculatePosition,\n    delegateInit\n} from './BaseShape';\n\nconst ENTITY_FIELD_NAME = 'VerticalEdgedRectangle';\n\nconst setupVerticalEdgedRectangleBehavior = state => ({\n    print(config) {\n        const theme = state.theme;\n        const { x, y } = state.position,\n            { w, h } = state.dimensions,\n            namePosition = { x: x + theme.edgeOffset, y };\n\n        return `\n            <g>\n                ${getRectangle(x, y, w, h, theme)}\n                    \n                ${getLine(x + theme.edgeOffset, y, x + theme.edgeOffset, y + h, theme)}\n                ${getLine(x + w - theme.edgeOffset, y, x + w - theme.edgeOffset, y + h, theme)}\n             \n                ${this.printName(namePosition)}\n                ${this.printDebugInfo(config)}\n            </g>`;\n    }\n});\n\nconst calculateWidth = state =>\n    2 * (state.theme.horizontalPadding + state.theme.edgeOffset) + calculateNameBasedWidth(state);\n\nconst calculateDimensions = state => ({\n    w: calculateWidth(state),\n    h: calculateHeight(state)\n});\n\nconst extractBasicState = state => ({\n    ...state,\n    position: calculatePosition(state),\n    dimensions: calculateDimensions(state)\n});\n\nexport const VerticalEdgedRectangle = initialState => {\n    let state = extractBasicState(initialState);\n\n    state = { ...state, ...setupInitialProperties(state) };\n\n    return assignState(state, [\n        setupInitialSelectors,\n        setupBasicBehaviour,\n        setupVerticalEdgedRectangleBehavior\n    ]);\n};\n\nexport default delegateInit(VerticalEdgedRectangle, ENTITY_FIELD_NAME);\n","import { TOKEN_TYPES, MODIFIED_TYPES } from 'shared/constants';\n\nimport VerticalEdgedRectangle from './shapes/VerticalEdgedRectangle';\nimport Rectangle from './shapes/Rectangle';\nimport ConditionRhombus from './shapes/ConditionRhombus';\nimport LoopRhombus from './shapes/LoopRhombus';\nimport RootCircle from './shapes/RootCircle';\nimport ReturnStatement from './shapes/ReturnStatement';\nimport DestructedNode from './shapes/DestructedNode';\nimport ClassDeclaration from './shapes/ClassDeclaration';\nimport DebuggerStatement from './shapes/DebuggerStatement';\nimport ExportDeclaration from './shapes/ExportDeclaration';\nimport ImportDeclaration from './shapes/ImportDeclaration';\nimport ImportSpecifier from './shapes/ImportSpecifier';\nimport ThrowStatement from './shapes/ThrowStatement';\nimport TryStatement from './shapes/TryStatement';\nimport CatchClause from './shapes/CatchClause';\nimport SwitchStatement from './shapes/SwitchStatement';\nimport BreakStatement from './shapes/BreakStatement';\nimport SwitchCase from './shapes/SwitchCase';\nimport ContinueStatement from './shapes/ContinueStatement';\nimport CallExpression from './shapes/CallExpression';\nimport ObjectProperty from './shapes/ObjectProperty';\n\nexport const getShapeForNode = node => {\n    switch (node.type) {\n        case TOKEN_TYPES.FUNCTION:\n            return VerticalEdgedRectangle;\n\n        case TOKEN_TYPES.LOOP:\n            return LoopRhombus;\n\n        case TOKEN_TYPES.CONDITIONAL:\n            return ConditionRhombus;\n\n        case TOKEN_TYPES.RETURN:\n            return ReturnStatement;\n\n        case MODIFIED_TYPES.DESTRUCTED:\n            return DestructedNode;\n\n        case TOKEN_TYPES.CLASS_DECLARATION:\n            return ClassDeclaration;\n\n        case TOKEN_TYPES.DEBUGGER_STATEMENT:\n            return DebuggerStatement;\n\n        case TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION:\n        case TOKEN_TYPES.EXPORT_NAMED_DECLARATION:\n            return ExportDeclaration;\n\n        case TOKEN_TYPES.IMPORT_DECLARATION:\n            return ImportDeclaration;\n\n        case TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER:\n        case TOKEN_TYPES.IMPORT_SPECIFIER:\n            return ImportSpecifier;\n\n        case TOKEN_TYPES.THROW_STATEMENT:\n            return ThrowStatement;\n\n        case TOKEN_TYPES.PROGRAM:\n            return RootCircle;\n\n        case TOKEN_TYPES.TRY_STATEMENT:\n            return TryStatement;\n\n        case TOKEN_TYPES.CATCH_CLAUSE:\n            return CatchClause;\n\n        case TOKEN_TYPES.SWITCH_STATEMENT:\n            return SwitchStatement;\n\n        case TOKEN_TYPES.BREAK:\n            return BreakStatement;\n\n        case TOKEN_TYPES.SWITCH_CASE:\n            return SwitchCase;\n\n        case TOKEN_TYPES.CONTINUE:\n            return ContinueStatement;\n\n        case TOKEN_TYPES.OBJECT_PROPERTY:\n            return ObjectProperty;\n\n        case TOKEN_TYPES.CALL_EXPRESSION:\n            return CallExpression;\n\n        default:\n            return Rectangle;\n    }\n};\n","import { ARROW_TYPE } from 'shared/constants';\nimport { getShapeForNode } from './shapesDefinitionsMap';\nimport ConnectionArrow, {\n    getFieldName as getConnectionArrowFieldName\n} from './connections/ConnectionArrow';\n\nexport const createShapeForNode = (node, position, styleTheme) => {\n    const shape = getShapeForNode(node),\n        shapeStyle = styleTheme[shape.getThemeFieldName()];\n\n    return shape(node, position, shapeStyle);\n};\n\nexport const createRootCircle = (node, styleTheme) => {\n    const shape = getShapeForNode(node),\n        shapeStyle = styleTheme[shape.getThemeFieldName()];\n\n    const { center, childOffset } = { ...styleTheme.RootStartPoint };\n    const root = shape(node, center, shapeStyle);\n\n    root.setChildOffsetPoint(childOffset);\n\n    return root;\n};\n\nexport const createConnectionArrow = (config, styleTheme) => {\n    const connectionArrowStyle = styleTheme[getConnectionArrowFieldName()],\n        arrowConfig = getConnectionConfig(config, connectionArrowStyle);\n\n    return ConnectionArrow({ ...config, ...arrowConfig }, connectionArrowStyle);\n};\n\nexport const getConnectionConfig = ({ startPoint, endPoint, boundaryPoint, arrowType }, theme) => {\n    const config = {\n        linePoints: [],\n        arrowPoint: { x: endPoint.x, y: endPoint.y }\n    };\n\n    switch (arrowType) {\n        case ARROW_TYPE.RIGHT:\n            config.linePoints = [{ x: startPoint.x, y: startPoint.y }];\n\n            if (boundaryPoint) {\n                config.linePoints = config.linePoints.concat([\n                    { x: boundaryPoint.x, y: startPoint.y },\n                    { x: boundaryPoint.x, y: endPoint.y },\n                    { x: endPoint.x, y: endPoint.y }\n                ]);\n            } else {\n                config.linePoints = config.linePoints.concat([\n                    { x: startPoint.x, y: endPoint.y },\n                    { x: endPoint.x, y: endPoint.y }\n                ]);\n            }\n            break;\n\n        case ARROW_TYPE.LEFT:\n            config.linePoints = [\n                { x: startPoint.x, y: startPoint.y },\n                { x: boundaryPoint.x + theme.lineTurnOffset, y: startPoint.y },\n                { x: boundaryPoint.x + theme.lineTurnOffset, y: endPoint.y },\n                { x: endPoint.x - theme.lineTurnOffset, y: endPoint.y }\n            ];\n            break;\n\n        case ARROW_TYPE.DOWN:\n            config.linePoints = [\n                { x: startPoint.x, y: startPoint.y },\n                { x: boundaryPoint.x + theme.lineTurnOffset, y: startPoint.y },\n                {\n                    x: boundaryPoint.x + theme.lineTurnOffset,\n                    y: endPoint.y - theme.lineTurnOffset\n                },\n                { x: endPoint.x, y: endPoint.y - theme.lineTurnOffset },\n                { x: endPoint.x, y: endPoint.y }\n            ];\n            break;\n    }\n\n    return config;\n};\n","import { complexTraversal } from 'shared/utils/traversalWithTreeLevelsPointer';\nimport { SVGBase } from './SVGBase';\nimport { createShapeForNode, createRootCircle, createConnectionArrow } from './shapesFactory';\nimport { TOKEN_TYPES, TOKEN_KEYS, ARROW_TYPE } from 'shared/constants';\n\nexport const buildSVGObjectsTree = (flowTree, styleTheme) => {\n    const svg = SVGBase();\n\n    const shapeStructures = buildShapeStructures(flowTree, styleTheme);\n    const connections = buildConnections(shapeStructures.root, styleTheme);\n\n    svg.addShapes(shapeStructures.list).addShapes(shapeStructures.root);\n    svg.addArrowConnections(connections);\n\n    return svg;\n};\n\nexport const buildShapeStructures = (flowTree, styleTheme) => {\n    const root = createRootCircle(flowTree, styleTheme),\n        position = { ...root.getChildOffsetPoint() },\n        shapesList = [];\n\n    let latestNode;\n\n    complexTraversal(\n        flowTree,\n        root,\n        (parentNode, parentShape) => {\n            position.x += parentShape.getChildOffsetPoint().x;\n        },\n        (node, parentShape) => {\n            position.y += addExtraSpacingBeforeShape(styleTheme, node, latestNode);\n\n            //TODO: refactor, move cases out of func, it will to many of them soon\n            if (\n                parentShape.getNodeType() === TOKEN_TYPES.CONDITIONAL &&\n                node.key === TOKEN_KEYS.ALTERNATE &&\n                !parentShape.checkIfChildExist(TOKEN_KEYS.ALTERNATE)\n            ) {\n                const alternatePoint = parentShape.getAlternativeBranchChildOffsetPoint();\n                position.x = alternatePoint.x + parentShape.getMargin();\n                position.y = alternatePoint.y;\n            }\n\n            const shape = createShapeForNode(node, { x: position.x, y: position.y }, styleTheme);\n\n            position.x = shape.getPosition().x;\n            position.y = shape.getPosition().y;\n\n            shapesList.push(shape);\n            parentShape.connectChild(shape);\n            position.y += shape.getChildOffsetPoint().y;\n\n            latestNode = node;\n            return shape;\n        },\n        (parentNode, parentShape) => {\n            if (parentNode.type === TOKEN_TYPES.CONDITIONAL) {\n                position.y = parentShape.getChildBoundaries().max.y + parentShape.getMargin();\n            }\n\n            position.x = parentShape.getPosition().x;\n        }\n    );\n\n    return {\n        list: shapesList,\n        root: root\n    };\n};\n\nconst addExtraSpacingBeforeShape = (theme, node, latestNode = {}) => {\n    const complexNodeTypes = [\n        TOKEN_TYPES.FUNCTION,\n        TOKEN_TYPES.FUNCTION_DECLARATION,\n        TOKEN_TYPES.FUNCTION_EXPRESSION,\n        TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION,\n        TOKEN_TYPES.CLASS_DECLARATION,\n        TOKEN_TYPES.IMPORT_DECLARATION,\n        TOKEN_TYPES.EXPORT_NAMED_DECLARATION,\n        TOKEN_TYPES.EXPORT_DEFAULT_DECLARATION\n    ];\n\n    if (\n        complexNodeTypes.includes(node.type) &&\n        !complexNodeTypes.includes(latestNode.type) &&\n        node.pathParentType !== TOKEN_TYPES.CALL_EXPRESSION\n    ) {\n        return theme.BaseShape.complexTypeExtraSpace;\n    }\n\n    return 0;\n};\n\nexport const buildConnections = (shapesTree, styleTheme) => {\n    const connections = [],\n        pushArrow = config => {\n            const connection = createConnectionArrow(config, styleTheme);\n            connections.push(connection);\n\n            return connection;\n        };\n\n    let latestShape = null,\n        latestParentShape = null;\n\n    complexTraversal(\n        shapesTree,\n        shapesTree,\n        parentShape => {},\n        (shape, parentShape) => {\n            latestShape = shape;\n\n            const config = buildConnectionConfig(shape, parentShape),\n                arrow = pushArrow(config);\n\n            shape.assignConnectionArrow(arrow);\n\n            return shape;\n        },\n        parentShape => {\n            latestParentShape = parentShape;\n            if (parentShape.getNodeType() !== TOKEN_TYPES.LOOP) return;\n\n            const { max } = parentShape.getChildBoundaries();\n\n            parentShape.assignLoopedConnectionArrow(\n                pushArrow({\n                    startPoint: latestShape.getBackPoint(),\n                    endPoint: parentShape.getMidPoint(),\n                    boundaryPoint: { x: max.x },\n                    arrowType: ARROW_TYPE.DOWN\n                })\n            );\n        },\n        {\n            getBody: node => node.getBody()\n        }\n    );\n\n    return connections;\n};\n\nconst isNoArrow = (toShape, fromShape) => {\n    if (\n        [\n            TOKEN_TYPES.IMPORT_SPECIFIER,\n            TOKEN_TYPES.IMPORT_DEFAULT_SPECIFIER,\n            TOKEN_TYPES.OBJECT_PROPERTY\n        ].includes(toShape.getNodeType())\n    ) {\n        return true;\n    }\n\n    if (\n        [\n            TOKEN_TYPES.FUNCTION_DECLARATION,\n            TOKEN_TYPES.FUNCTION_EXPRESSION,\n            TOKEN_TYPES.FUNCTION,\n            TOKEN_TYPES.ARROW_FUNCTION_EXPRESSION\n        ].includes(toShape.getNodeType()) &&\n        [\n            TOKEN_TYPES.CALL_EXPRESSION,\n            TOKEN_TYPES.VARIABLE_DECLARATOR,\n            TOKEN_TYPES.ASSIGNMENT_EXPRESSION,\n            TOKEN_TYPES.NEW_EXPRESSION\n        ].includes(fromShape.getNodeType())\n    ) {\n        return true;\n    }\n};\n\nconst buildConnectionConfig = (toShape, fromShape) => {\n    const config = {\n        endPoint: toShape.getToPoint(),\n        arrowType: ARROW_TYPE.RIGHT,\n        noArrow: isNoArrow(toShape, fromShape)\n    };\n\n    if (\n        toShape.getNodeKey() === TOKEN_KEYS.ALTERNATE &&\n        fromShape.getAlternativeBranchChildOffsetPoint\n    ) {\n        const boundaryPoint = fromShape.getAlternativeBranchChildOffsetPoint();\n\n        config.startPoint = fromShape.getAlternateFromPoint();\n        config.boundaryPoint = { x: boundaryPoint.x };\n    } else {\n        config.startPoint = fromShape.getFromPoint();\n    }\n\n    return config;\n};\n","export const TOKEN_TYPES = {\n    FUNCTION: 'Function',\n    FUNCTION_EXPRESSION: 'FunctionExpression',\n    FUNCTION_DECLARATION: 'FunctionDeclaration',\n    VARIABLE_DECLARATOR: 'VariableDeclarator',\n    ASSIGNMENT_EXPRESSION: 'AssignmentExpression',\n    MEMBER_EXPRESSION: 'MemberExpression',\n    VARIABLE_DECLARATION: 'VariableDeclaration',\n    UPDATE_EXPRESSION: 'UpdateExpression',\n    CALL_EXPRESSION: 'CallExpression',\n    NEW_EXPRESSION: 'NewExpression',\n    LOOP: 'Loop',\n    FOR_IN_STATEMENT: 'ForInStatement',\n    FOR_STATEMENT: 'ForStatement',\n    WHILE_STATEMENT: 'WhileStatement',\n    DO_WHILE_STATEMENT: 'DoWhileStatement',\n    CONTINUE: 'ContinueStatement',\n    CONDITIONAL: 'Conditional',\n    SWITCH_CASE: 'SwitchCase',\n    SWITCH_STATEMENT: 'SwitchStatement',\n    PROGRAM: 'Program',\n    RETURN: 'ReturnStatement',\n    BREAK: 'BreakStatement',\n    TRY_STATEMENT: 'TryStatement',\n    CATCH_CLAUSE: 'CatchClause',\n    WITH_STATEMENT: 'WithStatement',\n    THROW_STATEMENT: 'ThrowStatement',\n    DEBUGGER_STATEMENT: 'DebuggerStatement',\n    IDENTIFIER: 'Identifier',\n    ARRAY_EXPRESSION: 'ArrayExpression',\n    OBJECT_EXPRESSION: 'ObjectExpression',\n    OBJECT_PROPERTY: 'ObjectProperty',\n    OBJECT_METHOD: 'ObjectMethod',\n    BINARY_EXPRESSION: 'BinaryExpression',\n    EXPRESSION_STATEMENT: 'ExpressionStatement',\n    UNARY_EXPRESSION: 'UnaryExpression',\n    CONDITIONAL_EXPRESSION: 'ConditionalExpression',\n    STRING_LITERAL: 'StringLiteral',\n    NUMERIC_LITERAL: 'NumericLiteral',\n    THIS_EXPRESSION: 'ThisExpression',\n    LOGICAL_EXPRESSION: 'LogicalExpression',\n\n    //ES Harmony features\n    ARROW_FUNCTION_EXPRESSION: 'ArrowFunctionExpression',\n    IMPORT_DECLARATION: 'ImportDeclaration',\n    IMPORT_DEFAULT_SPECIFIER: 'ImportDefaultSpecifier',\n    IMPORT_SPECIFIER: 'ImportSpecifier',\n    EXPORT_NAMED_DECLARATION: 'ExportNamedDeclaration',\n    EXPORT_DEFAULT_DECLARATION: 'ExportDefaultDeclaration',\n    CLASS_DECLARATION: 'ClassDeclaration',\n    CLASS_METHOD: 'ClassMethod',\n    FOR_OF_STATEMENT: 'ForOfStatement',\n    SPREAD_ELEMENT: 'SpreadElement',\n    SPREAD_PROPERTY: 'SpreadProperty',\n    REST_PROPERTY: 'RestProperty',\n    OBJECT_PATTERN: 'ObjectPattern',\n    ARRAY_PATTERN: 'ArrayPattern',\n    ASSIGNMENT_PATTERN: 'AssignmentPattern'\n};\n\nexport const TOKEN_KEYS = {\n    BODY: 'body',\n    PROGRAM: 'program',\n    CONSEQUENT: 'consequent',\n    ALTERNATE: 'alternate',\n    TEST: 'test'\n};\n\nexport const ARROW_TYPE = {\n    RIGHT: 'RIGHT',\n    LEFT: 'LEFT',\n    UP: 'UP',\n    DOWN: 'DOWN'\n};\n\nexport const CLASS_FUNCTION_KINDS = {\n    CONSTRUCTOR: 'constructor',\n    METHOD: 'method'\n};\n\nexport const MODIFIED_TYPES = {\n    DESTRUCTED: 'DESTRUCTED',\n    CUSTOM: 'CUSTOM'\n};\n","import merge from 'deepmerge';\n\nexport const assignState = (state, extensionsList) => {\n    return Object.assign.apply(null, [{ state }, ...extensionsList.map(fn => fn(state))]);\n};\n\nexport const mergeObjectStructures = (destination, source) => merge(destination, source);\n","export const flatTree = (tree, getBody = node => node.body) => {\n    let flatList = [];\n\n    [].concat(tree).forEach(node => {\n        const body = getBody(node);\n\n        if (body && body.length) {\n            flatList = flatList.concat(node, flatTree(body, getBody));\n        } else {\n            flatList.push(node);\n        }\n    });\n\n    return flatList;\n};\n","export const calculateShapesBoundaries = list => {\n    if (!list || !list.length) {\n        throw new Error('List is not specified.');\n    }\n\n    const first = list[0];\n    let minX = first.min.x,\n        maxX = first.max.x,\n        minY = first.min.y,\n        maxY = first.max.y;\n\n    list.forEach(({ min, max }) => {\n        if (min.x < minX) {\n            minX = min.x;\n        }\n\n        if (min.y < minY) {\n            minY = min.y;\n        }\n\n        if (max.x > maxX) {\n            maxX = max.x;\n        }\n\n        if (max.y > maxY) {\n            maxY = max.y;\n        }\n    });\n\n    return {\n        min: { x: minX, y: minY },\n        max: { x: maxX, y: maxY }\n    };\n};\n\nexport const addOffsetToPoints = (points, offsetPoint) =>\n    [].concat(points).map(point => ({\n        x: point.x + offsetPoint.x,\n        y: point.y + offsetPoint.y\n    }));\n","export const buildIterator = list => ({\n    index: 0,\n    getNext() {\n        return list[this.index++];\n    },\n    reset() {\n        this.index = 0;\n    }\n});\n","export const logError = message => {\n    console.error(message);\n};\n","import stringWidth from 'string-width';\n\nexport const generateId = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (Math.random() * 16) | 0,\n            v = c === 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\n\nexport const getPathId = node => {\n    const queue = [node];\n    let id = `node-id:|${node.name}|`;\n\n    while (queue.length) {\n        let item = queue.shift();\n\n        if (item) {\n            id += item.name ? item.name[0] : '-';\n\n            if (item.parent) {\n                queue.push(item.parent);\n            }\n        }\n    }\n\n    return id.replace(/\\s/g, '').toUpperCase();\n};\n\nexport const splitNameString = (str, maxLineLength, nameSplitterTokensIterator) => {\n    const strLength = str.length;\n\n    if (strLength <= maxLineLength) return [str];\n\n    return [str.slice(0, maxLineLength) + '...'];\n    //TODO: fix\n\n    let parts = [],\n        currentPositionIndex = 0,\n        splitter = nameSplitterTokensIterator.getNext();\n\n    while (currentPositionIndex < strLength) {\n        const splitterIndex = str.indexOf(splitter, currentPositionIndex);\n\n        if (splitterIndex !== -1) {\n            parts.push(str.slice(currentPositionIndex, splitterIndex + splitter.length));\n            currentPositionIndex += splitterIndex + splitter.length;\n        } else {\n            //TODO: try other splitters then\n            //splitter = nameSplitterTokensIterator.getNext(),\n            parts.push(str.slice(currentPositionIndex, str.length));\n            currentPositionIndex = str.length;\n        }\n    }\n\n    return parts;\n};\n\nexport const getMaxStringLengthFromList = list =>\n    list.reduce((max, current) => {\n        const currentLength = stringWidth(current);\n        return currentLength >= max ? currentLength : max;\n    }, 0);\n","const SvgStyleFieldsMap = [\n    {\n        from: 'fillColor',\n        to: 'fill'\n    },\n    {\n        from: 'strokeColor',\n        to: 'stroke'\n    },\n    {\n        from: 'strokeWidth',\n        to: 'stroke-width'\n    },\n    {\n        from: 'fillOpacity',\n        to: 'fill-opacity'\n    },\n    {\n        from: 'strokeOpacity',\n        to: 'stroke-opacity'\n    }\n];\n\nexport const extractStylePropsFromTheme = theme => {\n    return SvgStyleFieldsMap.map(\n        item => (theme[item.from] ? `${item.to}:${theme[item.from]}` : null)\n    )\n        .filter(i => i)\n        .join('; ');\n};\n\nexport const extractStyleAttrsFromTheme = theme => {\n    return SvgStyleFieldsMap.map(\n        item => (theme[item.from] ? `${item.to}=\"${theme[item.from]}\"` : null)\n    )\n        .filter(i => i)\n        .join(' ');\n};\n\nexport const getRhombus = (x, y, w, h, theme) => {\n    return `<polygon points=\"${x},${y + h / 2} ${x + w / 2},${y} ${x + w},${y + h / 2} ${x +\n        w / 2},${y + h}\"\n            style=\"${extractStylePropsFromTheme(theme)}\" />`;\n};\n\nexport const getRoundedRectangle = (x, y, w, h, theme) => {\n    return `<rect x=\"${x}\" y=\"${y}\"\n            width=\"${w}\" height=\"${h}\"\n            rx=\"${theme.roundBorder}\" ry=\"${theme.roundBorder}\"\n            style=\"${extractStylePropsFromTheme(theme)}\" />`;\n};\n\nexport const getRectangle = (x, y, w, h, theme) => {\n    return `<rect x=\"${x}\" y=\"${y}\"\n            width=\"${w}\" height=\"${h}\"\n            style=\"${extractStylePropsFromTheme(theme)}\" />`;\n};\n\nexport const getLine = (x1, y1, x2, y2, theme) => {\n    return `<line x1=\"${x1}\" y1=\"${y1}\" x2=\"${x2}\" y2=\"${y2}\"\n                style=\"${extractStylePropsFromTheme(theme)}\" />`;\n};\n\nexport const getCircle = (x, y, r, theme) => {\n    return `<circle cx=\"${x}\" cy=\"${y}\" r=\"${r}\"\n        style=\"${extractStylePropsFromTheme(theme)}\" />`;\n};\n\nexport const getText = (x, y, theme, text) => {\n    return `<text x=\"${x}\" y=\"${y}\"\n        font-family=\"${theme.fontFamily}\" font-size=\"${theme.fontSize}\" fill=\"${\n        theme.textColor\n    }\">${text}</text>`;\n};\n\nexport const getClosedPath = (points, theme) => {\n    const pointStr = points\n        .map((point, i) => {\n            if (!i) return `M${point.x}, ${point.y}`;\n\n            return `L${point.x}, ${point.y}`;\n        })\n        .join(' ');\n\n    return `<path d=\"${pointStr} Z\" \n        ${extractStyleAttrsFromTheme(theme)} />`;\n};\n\nexport const getCurvedPath = (points, theme) => {\n    const pointStr = points\n        .map((point, i) => {\n            if (!i) return `M${point.x}, ${point.y}`;\n\n            let previousPoint = points[i - 1];\n\n            if (i <= 1) {\n                return getLinePointStr(point, previousPoint, theme.curveTurnRadius);\n            }\n\n            return `Q${previousPoint.x} ${previousPoint.y}\n                ${getArcEndPointStr(point, previousPoint, theme.curveTurnRadius)}\n                ${getLinePointStr(point, previousPoint, 2 * theme.curveTurnRadius)}`;\n        })\n        .join(' ');\n\n    return `<path d=\"${pointStr}\"\n        style=\"fill:none; ${extractStylePropsFromTheme(theme)}\" />`;\n};\n\nconst getLinePointStr = (point, previousPoint, radius) => {\n    if (point.x === previousPoint.x) {\n        return `L${point.x} ${getShiftedByArcNextPointValue(point.y, previousPoint.y, radius)}`;\n    }\n\n    if (point.y === previousPoint.y) {\n        return `L${getShiftedByArcNextPointValue(point.x, previousPoint.x, radius)} ${point.y} `;\n    }\n};\n\nconst getShiftedByArcNextPointValue = (pointValue, previousPointValue, radius) =>\n    pointValue > previousPointValue ? pointValue - radius : pointValue + radius;\n\nconst getArcEndPointStr = (point, previousPoint, radius) => {\n    if (point.x === previousPoint.x) {\n        return `${previousPoint.x} ${getArcEndPointValue(point.y, previousPoint.y, radius)}`;\n    }\n\n    if (point.y === previousPoint.y) {\n        return `${getArcEndPointValue(point.x, previousPoint.x, radius)} ${previousPoint.y}`;\n    }\n};\n\nconst getArcEndPointValue = (pointValue, previousPointValue, radius) =>\n    pointValue > previousPointValue ? previousPointValue + radius : previousPointValue - radius;\n","export const levelsTraversal = (tree, stepIn, onNode, stepOut, options = {}) => {\n    const getBody = options.getBody || (node => node.body);\n    stepIn(tree);\n\n    getBody(tree).forEach(node => {\n        onNode(node);\n\n        if (getBody(node)) {\n            levelsTraversal(node, stepIn, onNode, stepOut, options);\n        }\n    });\n\n    stepOut(tree);\n};\n\nexport const traversal = (tree, fn, getBody = node => node.body) => {\n    let queue = [].concat(tree);\n\n    while (queue.length) {\n        let node = queue.shift();\n\n        fn(node);\n\n        const nodeBody = getBody(node);\n        if (nodeBody) {\n            queue = [...queue, ...nodeBody];\n        }\n    }\n};\n\nexport const traversalSearch = (tree, fn) => {\n    const result = [];\n\n    traversal(tree, node => {\n        if (fn(node)) {\n            result.push(node);\n        }\n    });\n\n    return result;\n};\n","import { levelsTraversal } from './traversal';\nimport { setupPointer } from './treeLevelsPointer';\n\nexport const complexTraversal = (tree, root, onStepIn, onNode, onStepOut, options) => {\n    const levelsPointer = setupPointer();\n    let latestShape = root;\n\n    levelsTraversal(\n        tree,\n        parentNode => {\n            levelsPointer.stepIn(latestShape);\n            onStepIn(parentNode, levelsPointer.getCurrent());\n        },\n        node => {\n            latestShape = onNode(node, levelsPointer.getCurrent());\n        },\n        parentNode => {\n            levelsPointer.getCurrent() && onStepOut(parentNode, levelsPointer.getCurrent());\n            levelsPointer.stepOut();\n        },\n        options\n    );\n};\n","export const setupPointer = cache => ({\n    list: cache ? [cache] : [],\n\n    getCurrent() {\n        if (!this.list.length) return;\n        return this.list[this.list.length - 1];\n    },\n\n    stepIn(step) {\n        this.list.push(step);\n    },\n\n    stepOut() {\n        this.list.pop();\n    }\n});\n"],"sourceRoot":""}